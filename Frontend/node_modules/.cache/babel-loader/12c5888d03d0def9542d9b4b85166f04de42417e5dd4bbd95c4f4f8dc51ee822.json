{"ast":null,"code":"import { positionalKeys } from '../../render/utils/keys-position.mjs';\nimport { findDimensionValueType } from '../../value/types/dimensions.mjs';\nimport { getVariableValue } from '../utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken, containsCSSVariable } from '../utils/is-css-variable.mjs';\nimport { KeyframeResolver } from './KeyframesResolver.mjs';\nimport { isNone } from './utils/is-none.mjs';\nimport { makeNoneKeyframesAnimatable } from './utils/make-none-animatable.mjs';\nimport { positionalValues, isNumOrPxType } from './utils/unit-conversion.mjs';\nclass DOMKeyframesResolver extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n  }\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      element,\n      name\n    } = this;\n    if (!element || !element.current) return;\n    super.readKeyframes();\n    /**\n     * If any keyframe is a CSS variable, we need to find its value by sampling the element\n     */\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      let keyframe = unresolvedKeyframes[i];\n      if (typeof keyframe === \"string\") {\n        keyframe = keyframe.trim();\n        if (isCSSVariableToken(keyframe)) {\n          const resolved = getVariableValue(keyframe, element.current);\n          if (resolved !== undefined) {\n            unresolvedKeyframes[i] = resolved;\n          }\n          if (i === unresolvedKeyframes.length - 1) {\n            this.finalKeyframe = keyframe;\n          }\n        }\n      }\n    }\n    /**\n     * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n     * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n     * have a far bigger performance impact.\n     */\n    this.resolveNoneKeyframes();\n    /**\n     * Check to see if unit type has changed. If so schedule jobs that will\n     * temporarily set styles to the destination keyframes.\n     * Skip if we have more than two keyframes or this isn't a positional value.\n     * TODO: We can throw if there are multiple keyframes and the value type changes.\n     */\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return;\n    }\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    /**\n     * If one keyframe contains embedded CSS variables (e.g. in calc()) and the other\n     * doesn't, we need to measure to convert to pixels. This handles GitHub issue #3410.\n     */\n    const originHasVar = containsCSSVariable(origin);\n    const targetHasVar = containsCSSVariable(target);\n    if (originHasVar !== targetHasVar && positionalValues[name]) {\n      this.needsMeasurement = true;\n      return;\n    }\n    /**\n     * Either we don't recognise these value types or we can animate between them.\n     */\n    if (originType === targetType) return;\n    /**\n     * If both values are numbers or pixels, we can animate between them by\n     * converting them to numbers.\n     */\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else if (positionalValues[name]) {\n      /**\n       * Else, the only way to resolve this is by measuring the element.\n       */\n      this.needsMeasurement = true;\n    }\n  }\n  resolveNoneKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name\n    } = this;\n    const noneKeyframeIndexes = [];\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (unresolvedKeyframes[i] === null || isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n  }\n  measureInitialState() {\n    const {\n      element,\n      unresolvedKeyframes,\n      name\n    } = this;\n    if (!element || !element.current) return;\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin;\n    // Set final key frame to measure after next render\n    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n    if (measureKeyframe !== undefined) {\n      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n    }\n  }\n  measureEndState() {\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element || !element.current) return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n      this.finalKeyframe = finalKeyframe;\n    }\n    // If we removed transform values, reapply them before the next render\n    if (this.removedTransforms?.length) {\n      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n    this.resolveNoneKeyframes();\n  }\n}\nexport { DOMKeyframesResolver };","map":{"version":3,"names":["DOMKeyframesResolver","KeyframeResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","isCSSVariableToken","resolved","getVariableValue","undefined","finalKeyframe","resolveNoneKeyframes","positionalKeys","has","origin","target","originType","findDimensionValueType","targetType","originHasVar","containsCSSVariable","targetHasVar","positionalValues","needsMeasurement","isNumOrPxType","value","parseFloat","noneKeyframeIndexes","isNone","push","makeNoneKeyframesAnimatable","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/animation/keyframes/DOMKeyframesResolver.ts"],"sourcesContent":["import { positionalKeys } from \"../../render/utils/keys-position\"\nimport { MotionValue } from \"../../value\"\nimport { findDimensionValueType } from \"../../value/types/dimensions\"\nimport { AnyResolvedKeyframe } from \"../types\"\nimport { getVariableValue } from \"../utils/css-variables-conversion\"\nimport {\n    containsCSSVariable,\n    isCSSVariableToken,\n} from \"../utils/is-css-variable\"\nimport {\n    KeyframeResolver,\n    OnKeyframesResolved,\n    UnresolvedKeyframes,\n} from \"./KeyframesResolver\"\nimport { WithRender } from \"./types\"\nimport { isNone } from \"./utils/is-none\"\nimport { makeNoneKeyframesAnimatable } from \"./utils/make-none-animatable\"\nimport { isNumOrPxType, positionalValues } from \"./utils/unit-conversion\"\n\nexport class DOMKeyframesResolver<\n    T extends AnyResolvedKeyframe\n> extends KeyframeResolver<T> {\n    name: string\n    element?: WithRender\n\n    private removedTransforms?: [string, AnyResolvedKeyframe][]\n    private measuredOrigin?: AnyResolvedKeyframe\n\n    constructor(\n        unresolvedKeyframes: UnresolvedKeyframes<AnyResolvedKeyframe>,\n        onComplete: OnKeyframesResolved<T>,\n        name?: string,\n        motionValue?: MotionValue<T>,\n        element?: WithRender\n    ) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true)\n    }\n\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this\n\n        if (!element || !element.current) return\n\n        super.readKeyframes()\n\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i]\n\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim()\n\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current)\n\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved as T\n                    }\n\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe as T\n                    }\n                }\n            }\n        }\n\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes()\n\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return\n        }\n\n        const [origin, target] = unresolvedKeyframes\n        const originType = findDimensionValueType(origin)\n        const targetType = findDimensionValueType(target)\n\n        /**\n         * If one keyframe contains embedded CSS variables (e.g. in calc()) and the other\n         * doesn't, we need to measure to convert to pixels. This handles GitHub issue #3410.\n         */\n        const originHasVar = containsCSSVariable(origin)\n        const targetHasVar = containsCSSVariable(target)\n\n        if (originHasVar !== targetHasVar && positionalValues[name]) {\n            this.needsMeasurement = true\n            return\n        }\n\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType) return\n\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i]\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value as string)\n                }\n            }\n        } else if (positionalValues[name]) {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true\n        }\n    }\n\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this\n\n        const noneKeyframeIndexes: number[] = []\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (\n                unresolvedKeyframes[i] === null ||\n                isNone(unresolvedKeyframes[i])\n            ) {\n                noneKeyframeIndexes.push(i)\n            }\n        }\n\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(\n                unresolvedKeyframes,\n                noneKeyframeIndexes,\n                name\n            )\n        }\n    }\n\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this\n\n        if (!element || !element.current) return\n\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset\n        }\n\n        this.measuredOrigin = positionalValues[name](\n            element.measureViewportBox(),\n            window.getComputedStyle(element.current)\n        )\n\n        unresolvedKeyframes[0] = this.measuredOrigin\n\n        // Set final key frame to measure after next render\n        const measureKeyframe =\n            unresolvedKeyframes[unresolvedKeyframes.length - 1]\n\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false)\n        }\n    }\n\n    measureEndState() {\n        const { element, name, unresolvedKeyframes } = this\n\n        if (!element || !element.current) return\n\n        const value = element.getValue(name)\n        value && value.jump(this.measuredOrigin, false)\n\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex]\n\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](\n            element.measureViewportBox(),\n            window.getComputedStyle(element.current)\n        ) as any\n\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe as T\n        }\n\n        // If we removed transform values, reapply them before the next render\n        if (this.removedTransforms?.length) {\n            this.removedTransforms.forEach(\n                ([unsetTransformName, unsetTransformValue]) => {\n                    element\n                        .getValue(unsetTransformName)!\n                        .set(unsetTransformValue)\n                }\n            )\n        }\n\n        this.resolveNoneKeyframes()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}