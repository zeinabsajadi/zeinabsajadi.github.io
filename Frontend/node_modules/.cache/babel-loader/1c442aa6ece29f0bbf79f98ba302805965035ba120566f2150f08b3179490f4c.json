{"ast":null,"code":"\"use client\";\n\nimport { isMotionValue, isForcedMotionValue, buildHTMLStyles } from 'motion-dom';\nimport { useMemo } from 'react';\nimport { createHtmlRenderState } from './utils/create-render-state.mjs';\nfunction copyRawValuesOnly(target, source, props) {\n  for (const key in source) {\n    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction useInitialMotionValues({\n  transformTemplate\n}, visualState) {\n  return useMemo(() => {\n    const state = createHtmlRenderState();\n    buildHTMLStyles(state, visualState, transformTemplate);\n    return Object.assign({}, state.vars, state.style);\n  }, [visualState]);\n}\nfunction useStyle(props, visualState) {\n  const styleProp = props.style || {};\n  const style = {};\n  /**\n   * Copy non-Motion Values straight into style\n   */\n  copyRawValuesOnly(style, styleProp, props);\n  Object.assign(style, useInitialMotionValues(props, visualState));\n  return style;\n}\nfunction useHTMLProps(props, visualState) {\n  // The `any` isn't ideal but it is the type of createElement props argument\n  const htmlProps = {};\n  const style = useStyle(props, visualState);\n  if (props.drag && props.dragListener !== false) {\n    // Disable the ghost element when a user drags\n    htmlProps.draggable = false;\n    // Disable text selection\n    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = \"none\";\n    // Disable scrolling on the draggable direction\n    style.touchAction = props.drag === true ? \"none\" : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`;\n  }\n  if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {\n    htmlProps.tabIndex = 0;\n  }\n  htmlProps.style = style;\n  return htmlProps;\n}\nexport { copyRawValuesOnly, useHTMLProps };","map":{"version":3,"names":["key","source","isMotionValue","isForcedMotionValue","props","useInitialMotionValues","transformTemplate","visualState","state","createHtmlRenderState","buildHTMLStyles","Object","assign","vars","style","useStyle","styleProp","copyRawValuesOnly","useHTMLProps","htmlProps","draggable","userSelect","WebkitUserSelect","WebkitTouchCallout","touchAction","drag","tabIndex","undefined","onTap","onTapStart","whileTap"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/render/html/use-props.ts"],"sourcesContent":["\"use client\"\n\nimport { AnyResolvedKeyframe, buildHTMLStyles, isForcedMotionValue, isMotionValue, MotionValue } from \"motion-dom\"\nimport { HTMLProps, useMemo } from \"react\"\nimport { MotionProps } from \"../../motion/types\"\nimport { ResolvedValues } from \"../types\"\nimport { createHtmlRenderState } from \"./utils/create-render-state\"\n\nexport function copyRawValuesOnly(\n    target: ResolvedValues,\n    source: { [key: string]: AnyResolvedKeyframe | MotionValue },\n    props: MotionProps\n) {\n    for (const key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key] as AnyResolvedKeyframe\n        }\n    }\n}\n\nfunction useInitialMotionValues(\n    { transformTemplate }: MotionProps,\n    visualState: ResolvedValues\n) {\n    return useMemo(() => {\n        const state = createHtmlRenderState()\n\n        buildHTMLStyles(state, visualState, transformTemplate)\n\n        return Object.assign({}, state.vars, state.style)\n    }, [visualState])\n}\n\nfunction useStyle(\n    props: MotionProps,\n    visualState: ResolvedValues\n): ResolvedValues {\n    const styleProp = props.style || {}\n    const style = {}\n\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp as any, props)\n\n    Object.assign(style, useInitialMotionValues(props, visualState))\n\n    return style\n}\n\nexport function useHTMLProps(\n    props: MotionProps & HTMLProps<HTMLElement>,\n    visualState: ResolvedValues\n) {\n    // The `any` isn't ideal but it is the type of createElement props argument\n    const htmlProps: any = {}\n    const style = useStyle(props, visualState)\n\n    if (props.drag && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false\n\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n            style.WebkitTouchCallout =\n                \"none\"\n\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? \"none\"\n                : `pan-${props.drag === \"x\" ? \"y\" : \"x\"}`\n    }\n\n    if (\n        props.tabIndex === undefined &&\n        (props.onTap || props.onTapStart || props.whileTap)\n    ) {\n        htmlProps.tabIndex = 0\n    }\n\n    htmlProps.style = style\n\n    return htmlProps\n}\n"],"mappings":";;;;;;EAaI,WAAAA,GAAA,IAAAC,MAAA;IACI,KAAAC,aAAA,CAAAD,MAAA,CAAAD,GAAA,OAAAG,mBAAA,CAAAH,GAAA,EAAAI,KAAA;;;;AAIR;AAEA,SAAAC,uBAAA;EAAAC;AAAA,GAAAC,WAAA;;IAKQ,MAAAC,KAAA,GAAAC,qBAAA;IAEAC,eAAA,CAAAF,KAAA,EAAAD,WAAA,EAAAD,iBAAA;IAEA,OAAAK,MAAA,CAAAC,MAAA,KAAAJ,KAAA,CAAAK,IAAA,EAAAL,KAAA,CAAAM,KAAA;EACJ,IAAAP,WAAA;AACJ;AAEA,SAAAQ,SAAAX,KAAA,EAAAG,WAAA;EAII,MAAAS,SAAA,GAAAZ,KAAA,CAAAU,KAAA;;EAGA;;AAEG;EACHG,iBAAA,CAAAH,KAAA,EAAAE,SAAA,EAAAZ,KAAA;EAEAO,MAAA,CAAAC,MAAA,CAAAE,KAAA,EAAAT,sBAAA,CAAAD,KAAA,EAAAG,WAAA;EAEA,OAAAO,KAAA;AACJ;AAEgB,SAAAI,aAAAd,KAAA,EAAAG,WAAA;;;;;;IAURY,SAAA,CAAAC,SAAA;;IAGAN,KAAA,CAAAO,UAAA,GACIP,KAAA,CAAAQ,gBAAA,GACAR,KAAA,CAAAS,kBAAA,GACI;;IAGRT,KAAA,CAAAU,WAAA,G,sBAEQ,SACA,OAAApB,KAAA,CAAAqB,IAAA;;EAGZ,IAAArB,KAAA,CAAAsB,QAAA,KAAAC,SAAA,KAEIvB,KAAA,CAAAwB,KAAA,IAAAxB,KAAA,CAAAyB,UAAA,IAAAzB,KAAA,CAAA0B,QAAA;IAEAX,SAAA,CAAAO,QAAA;;EAGJP,SAAA,CAAAL,KAAA,GAAAA,KAAA;EAEA,OAAAK,SAAA;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}