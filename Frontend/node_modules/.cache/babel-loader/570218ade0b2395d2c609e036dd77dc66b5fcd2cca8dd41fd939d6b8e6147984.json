{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { invariant } from 'motion-utils';\nimport { forwardRef, useRef, useEffect } from 'react';\nimport { ReorderContext } from '../../context/ReorderContext.mjs';\nimport { motion } from '../../render/components/motion/proxy.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { checkReorder } from './utils/check-reorder.mjs';\nfunction ReorderGroupComponent({\n  children,\n  as = \"ul\",\n  axis = \"y\",\n  onReorder,\n  values,\n  ...props\n}, externalRef) {\n  const Component = useConstant(() => motion[as]);\n  const order = [];\n  const isReordering = useRef(false);\n  const groupRef = useRef(null);\n  invariant(Boolean(values), \"Reorder.Group must be provided a values prop\", \"reorder-values\");\n  const context = {\n    axis,\n    groupRef,\n    registerItem: (value, layout) => {\n      // If the entry was already added, update it rather than adding it again\n      const idx = order.findIndex(entry => value === entry.value);\n      if (idx !== -1) {\n        order[idx].layout = layout[axis];\n      } else {\n        order.push({\n          value: value,\n          layout: layout[axis]\n        });\n      }\n      order.sort(compareMin);\n    },\n    updateOrder: (item, offset, velocity) => {\n      if (isReordering.current) return;\n      const newOrder = checkReorder(order, item, offset, velocity);\n      if (order !== newOrder) {\n        isReordering.current = true;\n        onReorder(newOrder.map(getValue).filter(value => values.indexOf(value) !== -1));\n      }\n    }\n  };\n  useEffect(() => {\n    isReordering.current = false;\n  });\n  // Combine refs if external ref is provided\n  const setRef = element => {\n    groupRef.current = element;\n    if (typeof externalRef === \"function\") {\n      externalRef(element);\n    } else if (externalRef) {\n      externalRef.current = element;\n    }\n  };\n  /**\n   * Disable browser scroll anchoring on the group container.\n   * When items reorder, scroll anchoring can cause the browser to adjust\n   * the scroll position, which interferes with drag position calculations.\n   */\n  const groupStyle = {\n    overflowAnchor: \"none\",\n    ...props.style\n  };\n  return jsx(Component, {\n    ...props,\n    style: groupStyle,\n    ref: setRef,\n    ignoreStrict: true,\n    children: jsx(ReorderContext.Provider, {\n      value: context,\n      children: children\n    })\n  });\n}\nconst ReorderGroup = /*@__PURE__*/forwardRef(ReorderGroupComponent);\nfunction getValue(item) {\n  return item.value;\n}\nfunction compareMin(a, b) {\n  return a.layout.min - b.layout.min;\n}\nexport { ReorderGroup, ReorderGroupComponent };","map":{"version":3,"names":["ReorderGroupComponent","children","as","axis","onReorder","values","props","externalRef","Component","useConstant","motion","isReordering","useRef","groupRef","context","registerItem","value","layout","idx","order","findIndex","entry","push","sort","compareMin","newOrder","checkReorder","item","offset","velocity","current","filter","indexOf","setRef","element","groupStyle","overflowAnchor","jsx","style","ref","ignoreStrict","ReorderContext","Provider","ReorderGroup","forwardRef","getValue","a","b"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/components/Reorder/Group.tsx"],"sourcesContent":["\"use client\"\n\nimport { invariant } from \"motion-utils\"\nimport * as React from \"react\"\nimport { forwardRef, FunctionComponent, JSX, useEffect, useRef } from \"react\"\nimport { ReorderContext } from \"../../context/ReorderContext\"\nimport { motion } from \"../../render/components/motion/proxy\"\nimport { HTMLMotionProps } from \"../../render/html/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport {\n    DefaultGroupElement,\n    ItemData,\n    ReorderContextProps,\n    ReorderElementTag,\n} from \"./types\"\nimport { checkReorder } from \"./utils/check-reorder\"\n\nexport interface Props<\n    V,\n    TagName extends ReorderElementTag = DefaultGroupElement\n> {\n    /**\n     * A HTML element to render this component as. Defaults to `\"ul\"`.\n     *\n     * @public\n     */\n    as?: TagName\n\n    /**\n     * The axis to reorder along. By default, items will be draggable on this axis.\n     * To make draggable on both axes, set `<Reorder.Item drag />`\n     *\n     * @public\n     */\n    axis?: \"x\" | \"y\"\n\n    /**\n     * A callback to fire with the new value order. For instance, if the values\n     * are provided as a state from `useState`, this could be the set state function.\n     *\n     * @public\n     */\n    onReorder: (newOrder: V[]) => void\n\n    /**\n     * The latest values state.\n     *\n     * ```jsx\n     * function Component() {\n     *   const [items, setItems] = useState([0, 1, 2])\n     *\n     *   return (\n     *     <Reorder.Group values={items} onReorder={setItems}>\n     *         {items.map((item) => <Reorder.Item key={item} value={item} />)}\n     *     </Reorder.Group>\n     *   )\n     * }\n     * ```\n     *\n     * @public\n     */\n    values: V[]\n}\n\ntype ReorderGroupProps<\n    V,\n    TagName extends ReorderElementTag = DefaultGroupElement\n> = Props<V, TagName> &\n    Omit<HTMLMotionProps<TagName>, \"values\"> &\n    React.PropsWithChildren<{}>\n\nexport function ReorderGroupComponent<\n    V,\n    TagName extends ReorderElementTag = DefaultGroupElement\n>(\n    {\n        children,\n        as = \"ul\" as TagName,\n        axis = \"y\",\n        onReorder,\n        values,\n        ...props\n    }: ReorderGroupProps<V, TagName>,\n    externalRef?: React.ForwardedRef<any>\n): JSX.Element {\n    const Component = useConstant(\n        () => motion[as as keyof typeof motion]\n    ) as FunctionComponent<\n        React.PropsWithChildren<HTMLMotionProps<any> & { ref?: React.Ref<any> }>\n    >\n\n    const order: ItemData<V>[] = []\n    const isReordering = useRef(false)\n    const groupRef = useRef<Element>(null)\n\n    invariant(\n        Boolean(values),\n        \"Reorder.Group must be provided a values prop\",\n        \"reorder-values\"\n    )\n\n    const context: ReorderContextProps<V> = {\n        axis,\n        groupRef,\n        registerItem: (value, layout) => {\n            // If the entry was already added, update it rather than adding it again\n            const idx = order.findIndex((entry) => value === entry.value)\n            if (idx !== -1) {\n                order[idx].layout = layout[axis]\n            } else {\n                order.push({ value: value, layout: layout[axis] })\n            }\n            order.sort(compareMin)\n        },\n        updateOrder: (item, offset, velocity) => {\n            if (isReordering.current) return\n\n            const newOrder = checkReorder(order, item, offset, velocity)\n\n            if (order !== newOrder) {\n                isReordering.current = true\n                onReorder(\n                    newOrder\n                        .map(getValue)\n                        .filter((value) => values.indexOf(value) !== -1)\n                )\n            }\n        },\n    }\n\n    useEffect(() => {\n        isReordering.current = false\n    })\n\n    // Combine refs if external ref is provided\n    const setRef = (element: Element | null) => {\n        ;(groupRef as React.MutableRefObject<Element | null>).current = element\n        if (typeof externalRef === \"function\") {\n            externalRef(element)\n        } else if (externalRef) {\n            ;(\n                externalRef as React.MutableRefObject<Element | null>\n            ).current = element\n        }\n    }\n\n    /**\n     * Disable browser scroll anchoring on the group container.\n     * When items reorder, scroll anchoring can cause the browser to adjust\n     * the scroll position, which interferes with drag position calculations.\n     */\n    const groupStyle = {\n        overflowAnchor: \"none\" as const,\n        ...props.style,\n    }\n\n    return (\n        <Component {...props} style={groupStyle} ref={setRef} ignoreStrict>\n            <ReorderContext.Provider value={context}>\n                {children}\n            </ReorderContext.Provider>\n        </Component>\n    )\n}\n\nexport const ReorderGroup = /*@__PURE__*/ forwardRef(ReorderGroupComponent) as <\n    V,\n    TagName extends ReorderElementTag = DefaultGroupElement\n>(\n    props: ReorderGroupProps<V, TagName> & { ref?: React.ForwardedRef<any> }\n) => ReturnType<typeof ReorderGroupComponent>\n\nfunction getValue<V>(item: ItemData<V>) {\n    return item.value\n}\n\nfunction compareMin<V>(a: ItemData<V>, b: ItemData<V>) {\n    return a.layout.min - b.layout.min\n}\n"],"mappings":";;;;;;;;;AAuEM,SAAAA,sBAAA;EAAAC,QAAA;EAAAC,EAAA;EAAAC,IAAA;EAAAC,SAAA;EAAAC,MAAA;EAAA,GAAAC;AAAA,GAAAC,WAAA;EAcF,MAAAC,SAAA,GAAAC,WAAA,OAAAC,MAAA,CAAAR,EAAA;;EAOA,MAAAS,YAAA,GAAAC,MAAA;EACA,MAAAC,QAAA,GAAAD,MAAA;;EAQA,MAAAE,OAAA;;;IAGIC,YAAA,EAAAA,CAAAC,KAAA,EAAAC,MAAA;;MAEI,MAAAC,GAAA,GAAAC,KAAA,CAAAC,SAAA,CAAAC,KAAA,IAAAL,KAAA,KAAAK,KAAA,CAAAL,KAAA;MACA,IAAAE,GAAA;;;QAGIC,KAAA,CAAAG,IAAA;UAAAN,KAAA,EAAAA,KAAA;UAAAC,MAAA,EAAAA,MAAA,CAAAd,IAAA;QAAA;;MAEJgB,KAAA,CAAAI,IAAA,CAAAC,UAAA;;;;MAKA,MAAAC,QAAA,GAAAC,YAAA,CAAAP,KAAA,EAAAQ,IAAA,EAAAC,MAAA,EAAAC,QAAA;MAEA,IAAAV,KAAA,KAAAM,QAAA;QACId,YAAA,CAAAmB,OAAA;QACA1B,SAAA,CAAAqB,QAAA,C,cAGSM,MAAA,CAAAf,KAAA,IAAAX,MAAA,CAAA2B,OAAA,CAAAhB,KAAA;;;;;IAOjBL,YAAA,CAAAmB,OAAA;EACJ;;EAGA,MAAAG,MAAA,GAAAC,OAAA;IACMrB,QAAA,CAAAiB,OAAA,GAAAI,OAAA;IACF,WAAA3B,WAAA;;;MAIQA,WAAA,CAAAuB,OAAA,GAAAI,OAAA;;EAGZ;EAEA;;;;AAIG;EACH,MAAAC,UAAA;IACIC,cAAA;;;EAIJ,OAAAC,GAAA,CAAA7B,SAAA;IAAA,GAAAF,KAAA;IAAAgC,KAAA,EAAAH,UAAA;IAAAI,GAAA,EAAAN,MAAA;IAAAO,YAAA;IAAAvC,QAAA,EAAAoC,GAAA,CAAAI,cAAA,CAAAC,QAAA;MAAA1B,KAAA,EAAAF,OAAA;MAAAb,QAAA,EAAAA;IAAA;EAAA;AAOJ;AAEa,MAAA0C,YAAA,gBAAAC,UAAA,CAAA5C,qBAAA;AAOb,SAAA6C,SAAAlB,IAAA;;AAEA;AAEA,SAAAH,WAAAsB,CAAA,EAAAC,CAAA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}