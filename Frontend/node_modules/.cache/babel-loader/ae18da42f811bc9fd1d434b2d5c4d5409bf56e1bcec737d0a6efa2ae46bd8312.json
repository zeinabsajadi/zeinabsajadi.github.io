{"ast":null,"code":"import { optimizedAppearDataId, startWaapiAnimation, getOptimisedAppearId } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionIsMounted) {\n    return;\n  }\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n  if (!readyAnimation) {\n    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n    /**\n     * 10 secs is basically just a super-safe duration to give Chrome\n     * long enough to get the animation ready.\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\n     * If there's no readyAnimation then there's been no instantiation\n     * of handoff animations.\n     */\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\n       * Keep a map of elementIds that have started animating. We check\n       * via ID instead of Element because of hydration errors and\n       * pre-hydration checks. We also actively record IDs as they start\n       * animating rather than simply checking for data-appear-id as\n       * this attrbute might be present but not lead to an animation, for\n       * instance if the element's appear animation is on a different\n       * breakpoint.\n       */\n      if (!valueName) {\n        return appearComplete.has(elementId);\n      }\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n    window.MotionHandoffMarkAsComplete = elementId => {\n      if (appearComplete.has(elementId)) {\n        appearComplete.set(elementId, true);\n      }\n    };\n    window.MotionHandoffIsComplete = elementId => {\n      return appearComplete.get(elementId) === true;\n    };\n    /**\n     * We only need to cancel transform animations as\n     * they're the ones that will interfere with the\n     * layout animation measurements.\n     */\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n      if (frame && canResume === undefined) {\n        /**\n         * Wait until the end of the subsequent frame to cancel the animation\n         * to ensure we don't remove the animation before the main thread has\n         * had a chance to resolve keyframes and render.\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\n         * If there are no more animations left, we can remove the cancel function.\n         * This will let us know when we can stop checking for conflicting layout animations.\n         */\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = window.MotionHasOptimisedAnimation?.(appearId, valueName);\n      const externalAnimationValue = visualElement.props.values?.[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        if (externalAnimationValue.get() !== latestValue) {\n          window.MotionCancelOptimisedAnimation?.(appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n    /**\n     * Record the time of the first started animation. We call performance.now() once\n     * here and once in handoff to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n  appearComplete.set(id, false);\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\nexport { startOptimizedAppearAnimation };","map":{"version":3,"names":["startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","optimizedAppearDataId","MotionHandoffAnimation","handoffOptimizedAppearAnimation","storeId","appearStoreId","startWaapiAnimation","duration","ease","appearAnimationStore","set","MotionHasOptimisedAnimation","elementId","valueName","appearComplete","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","appearId","getOptimisedAppearId","valueIsOptimised","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch","noop"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/animation/optimized-appear/start.ts"],"sourcesContent":["import {\n    AnyResolvedKeyframe,\n    Batcher,\n    getOptimisedAppearId,\n    MotionValue,\n    optimizedAppearDataId,\n    startWaapiAnimation,\n    ValueAnimationTransition,\n    type WithAppearProps,\n} from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { handoffOptimizedAppearAnimation } from \"./handoff\"\nimport { appearAnimationStore, appearComplete, AppearStoreEntry } from \"./store\"\nimport { appearStoreId } from \"./store-id\"\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime: number\n\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation: Animation\n\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set<AppearStoreEntry>()\n\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play()\n        data.animation.startTime = data.startTime\n    })\n    suspendedAnimations.clear()\n}\n\nexport function startOptimizedAppearAnimation(\n    element: HTMLElement,\n    name: string,\n    keyframes: string[] | number[],\n    options: ValueAnimationTransition<number | string>,\n    onReady?: (animation: Animation) => void\n): void {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return\n    }\n\n    const id = element.dataset[optimizedAppearDataId]\n    if (!id) return\n\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation\n\n    const storeId = appearStoreId(id, name)\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(\n            element,\n            name,\n            [keyframes[0] as number, keyframes[0] as number],\n            /**\n             * 10 secs is basically just a super-safe duration to give Chrome\n             * long enough to get the animation ready.\n             */\n            { duration: 10000, ease: \"linear\" }\n        )\n\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        })\n\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation\n\n        window.MotionHasOptimisedAnimation = (\n            elementId?: string,\n            valueName?: string\n        ) => {\n            if (!elementId) return false\n\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId)\n            }\n\n            const animationId = appearStoreId(elementId, valueName)\n            return Boolean(appearAnimationStore.get(animationId))\n        }\n\n        window.MotionHandoffMarkAsComplete = (elementId: string): void => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true)\n            }\n        }\n\n        window.MotionHandoffIsComplete = (elementId: string): boolean => {\n            return appearComplete.get(elementId) === true\n        }\n\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (\n            elementId: string,\n            valueName: string,\n            frame?: Batcher,\n            canResume?: boolean\n        ) => {\n            const animationId = appearStoreId(elementId, valueName)\n            const data = appearAnimationStore.get(animationId)\n\n            if (!data) return\n\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel()\n                    })\n                })\n            } else {\n                data.animation.cancel()\n            }\n\n            if (frame && canResume) {\n                suspendedAnimations.add(data)\n                frame.render(resumeSuspendedAnimations)\n            } else {\n                appearAnimationStore.delete(animationId)\n\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined\n                }\n            }\n        }\n\n        window.MotionCheckAppearSync = (\n            visualElement: WithAppearProps,\n            valueName: string,\n            value: MotionValue\n        ) => {\n            const appearId = getOptimisedAppearId(visualElement)\n\n            if (!appearId) return\n\n            const valueIsOptimised = window.MotionHasOptimisedAnimation?.(\n                appearId,\n                valueName\n            )\n            const externalAnimationValue =\n                visualElement.props.values?.[valueName]\n\n            if (!valueIsOptimised || !externalAnimationValue) return\n\n            const removeSyncCheck = value.on(\n                \"change\",\n                (latestValue: AnyResolvedKeyframe) => {\n                    if (externalAnimationValue.get() !== latestValue) {\n                        window.MotionCancelOptimisedAnimation?.(\n                            appearId,\n                            valueName\n                        )\n                        removeSyncCheck()\n                    }\n                }\n            )\n\n            return removeSyncCheck\n        }\n    }\n\n    const startAnimation = () => {\n        readyAnimation.cancel()\n\n        const appearAnimation = startWaapiAnimation(\n            element,\n            name,\n            keyframes,\n            options\n        )\n\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now()\n        }\n\n        appearAnimation.startTime = startFrameTime\n\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        })\n\n        if (onReady) onReady(appearAnimation)\n    }\n\n    appearComplete.set(id, false)\n\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop)\n    } else {\n        startAnimation()\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}