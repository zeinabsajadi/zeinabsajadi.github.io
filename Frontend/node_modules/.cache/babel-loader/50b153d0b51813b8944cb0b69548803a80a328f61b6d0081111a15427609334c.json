{"ast":null,"code":"import { warnOnce, secondsToMilliseconds, isNumericalString, isZeroValueString, SubscriptionManager } from 'motion-utils';\nimport { KeyframeResolver } from '../animation/keyframes/KeyframesResolver.mjs';\nimport { NativeAnimation } from '../animation/NativeAnimation.mjs';\nimport { acceleratedValues } from '../animation/waapi/utils/accelerated-values.mjs';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { motionValue } from '../value/index.mjs';\nimport { complex } from '../value/types/complex/index.mjs';\nimport { getAnimatableNone } from '../value/types/utils/animatable-none.mjs';\nimport { findValueType } from '../value/types/utils/find.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\nimport { visualElementStore } from './store.mjs';\nimport { isControllingVariants, isVariantNode } from './utils/is-controlling-variants.mjs';\nimport { transformProps } from './utils/keys-transform.mjs';\nimport { updateMotionValuesFromProps } from './utils/motion-values.mjs';\nimport { initPrefersReducedMotion } from './utils/reduced-motion/index.mjs';\nimport { resolveVariantFromProps } from './utils/resolve-variants.mjs';\nimport { hasReducedMotionListener, prefersReducedMotion } from './utils/reduced-motion/state.mjs';\nimport { frame, cancelFrame } from '../frameloop/frame.mjs';\nconst propEventHandlers = [\"AnimationStart\", \"AnimationComplete\", \"Update\", \"BeforeLayoutMeasure\", \"LayoutMeasure\", \"LayoutAnimationStart\", \"LayoutAnimationComplete\"];\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions = {};\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nfunction setFeatureDefinitions(definitions) {\n  featureDefinitions = definitions;\n}\n/**\n * Get the current feature definitions\n */\nfunction getFeatureDefinitions() {\n  return featureDefinitions;\n}\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nclass VisualElement {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {\n    return {};\n  }\n  constructor({\n    parent,\n    props,\n    presenceContext,\n    reducedMotionConfig,\n    skipAnimations,\n    blockInitialAnimation,\n    visualState\n  }, options = {}) {\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    this.current = null;\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    this.children = new Set();\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    this.isVariantNode = false;\n    this.isControllingVariants = false;\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    this.shouldReduceMotion = null;\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n    this.shouldSkipAnimations = false;\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    this.values = new Map();\n    this.KeyframeResolver = KeyframeResolver;\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    this.features = {};\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    this.valueSubscriptions = new Map();\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    this.prevMotionValues = {};\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n    this.hasBeenMounted = false;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    this.propEventSubscriptions = {};\n    this.notifyUpdate = () => this.notify(\"Update\", this.latestValues);\n    this.render = () => {\n      if (!this.current) return;\n      this.triggerBuild();\n      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);\n    };\n    this.renderScheduledAt = 0.0;\n    this.scheduleRender = () => {\n      const now = time.now();\n      if (this.renderScheduledAt < now) {\n        this.renderScheduledAt = now;\n        frame.render(this.render, false, true);\n      }\n    };\n    const {\n      latestValues,\n      renderState\n    } = visualState;\n    this.latestValues = latestValues;\n    this.baseTarget = {\n      ...latestValues\n    };\n    this.initialValues = props.initial ? {\n      ...latestValues\n    } : {};\n    this.renderState = renderState;\n    this.parent = parent;\n    this.props = props;\n    this.presenceContext = presenceContext;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.reducedMotionConfig = reducedMotionConfig;\n    this.skipAnimationsConfig = skipAnimations;\n    this.options = options;\n    this.blockInitialAnimation = Boolean(blockInitialAnimation);\n    this.isControllingVariants = isControllingVariants(props);\n    this.isVariantNode = isVariantNode(props);\n    if (this.isVariantNode) {\n      this.variantChildren = new Set();\n    }\n    this.manuallyAnimateOnMount = Boolean(parent && parent.current);\n    /**\n     * Any motion values that are provided to the element when created\n     * aren't yet bound to the element, as this would technically be impure.\n     * However, we iterate through the motion values and set them to the\n     * initial values for this component.\n     *\n     * TODO: This is impure and we should look at changing this to run on mount.\n     * Doing so will break some tests but this isn't necessarily a breaking change,\n     * more a reflection of the test.\n     */\n    const {\n      willChange,\n      ...initialMotionValues\n    } = this.scrapeMotionValuesFromProps(props, {}, this);\n    for (const key in initialMotionValues) {\n      const value = initialMotionValues[key];\n      if (latestValues[key] !== undefined && isMotionValue(value)) {\n        value.set(latestValues[key]);\n      }\n    }\n  }\n  mount(instance) {\n    /**\n     * If this element has been mounted before (e.g. after a Suspense\n     * unmount/remount), reset motion values to their initial state\n     * so animations replay correctly from initial → animate.\n     */\n    if (this.hasBeenMounted) {\n      for (const key in this.initialValues) {\n        this.values.get(key)?.jump(this.initialValues[key]);\n        this.latestValues[key] = this.initialValues[key];\n      }\n    }\n    this.current = instance;\n    visualElementStore.set(instance, this);\n    if (this.projection && !this.projection.instance) {\n      this.projection.mount(instance);\n    }\n    if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n      this.removeFromVariantTree = this.parent.addVariantChild(this);\n    }\n    this.values.forEach((value, key) => this.bindToMotionValue(key, value));\n    /**\n     * Determine reduced motion preference. Only initialize the matchMedia\n     * listener if we actually need the dynamic value (i.e., when config\n     * is neither \"never\" nor \"always\").\n     */\n    if (this.reducedMotionConfig === \"never\") {\n      this.shouldReduceMotion = false;\n    } else if (this.reducedMotionConfig === \"always\") {\n      this.shouldReduceMotion = true;\n    } else {\n      if (!hasReducedMotionListener.current) {\n        initPrefersReducedMotion();\n      }\n      this.shouldReduceMotion = prefersReducedMotion.current;\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(this.shouldReduceMotion !== true, \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\", \"reduced-motion-disabled\");\n    }\n    /**\n     * Set whether animations should be skipped based on the config.\n     */\n    this.shouldSkipAnimations = this.skipAnimationsConfig ?? false;\n    this.parent?.addChild(this);\n    this.update(this.props, this.presenceContext);\n    this.hasBeenMounted = true;\n  }\n  unmount() {\n    this.projection && this.projection.unmount();\n    cancelFrame(this.notifyUpdate);\n    cancelFrame(this.render);\n    this.valueSubscriptions.forEach(remove => remove());\n    this.valueSubscriptions.clear();\n    this.removeFromVariantTree && this.removeFromVariantTree();\n    this.parent?.removeChild(this);\n    for (const key in this.events) {\n      this.events[key].clear();\n    }\n    for (const key in this.features) {\n      const feature = this.features[key];\n      if (feature) {\n        feature.unmount();\n        feature.isMounted = false;\n      }\n    }\n    this.current = null;\n  }\n  addChild(child) {\n    this.children.add(child);\n    this.enteringChildren ?? (this.enteringChildren = new Set());\n    this.enteringChildren.add(child);\n  }\n  removeChild(child) {\n    this.children.delete(child);\n    this.enteringChildren && this.enteringChildren.delete(child);\n  }\n  bindToMotionValue(key, value) {\n    if (this.valueSubscriptions.has(key)) {\n      this.valueSubscriptions.get(key)();\n    }\n    if (value.accelerate && acceleratedValues.has(key) && this.current instanceof HTMLElement) {\n      const {\n        factory,\n        keyframes,\n        times,\n        ease,\n        duration\n      } = value.accelerate;\n      const animation = new NativeAnimation({\n        element: this.current,\n        name: key,\n        keyframes,\n        times,\n        ease,\n        duration: secondsToMilliseconds(duration)\n      });\n      const cleanup = factory(animation);\n      this.valueSubscriptions.set(key, () => {\n        cleanup();\n        animation.cancel();\n      });\n      return;\n    }\n    const valueIsTransform = transformProps.has(key);\n    if (valueIsTransform && this.onBindTransform) {\n      this.onBindTransform();\n    }\n    const removeOnChange = value.on(\"change\", latestValue => {\n      this.latestValues[key] = latestValue;\n      this.props.onUpdate && frame.preRender(this.notifyUpdate);\n      if (valueIsTransform && this.projection) {\n        this.projection.isTransformDirty = true;\n      }\n      this.scheduleRender();\n    });\n    let removeSyncCheck;\n    if (typeof window !== \"undefined\" && window.MotionCheckAppearSync) {\n      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);\n    }\n    this.valueSubscriptions.set(key, () => {\n      removeOnChange();\n      if (removeSyncCheck) removeSyncCheck();\n      if (value.owner) value.stop();\n    });\n  }\n  sortNodePosition(other) {\n    /**\n     * If these nodes aren't even of the same type we can't compare their depth.\n     */\n    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {\n      return 0;\n    }\n    return this.sortInstanceNodePosition(this.current, other.current);\n  }\n  updateFeatures() {\n    let key = \"animation\";\n    for (key in featureDefinitions) {\n      const featureDefinition = featureDefinitions[key];\n      if (!featureDefinition) continue;\n      const {\n        isEnabled,\n        Feature: FeatureConstructor\n      } = featureDefinition;\n      /**\n       * If this feature is enabled but not active, make a new instance.\n       */\n      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {\n        this.features[key] = new FeatureConstructor(this);\n      }\n      /**\n       * If we have a feature, mount or update it.\n       */\n      if (this.features[key]) {\n        const feature = this.features[key];\n        if (feature.isMounted) {\n          feature.update();\n        } else {\n          feature.mount();\n          feature.isMounted = true;\n        }\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();\n  }\n  getStaticValue(key) {\n    return this.latestValues[key];\n  }\n  setStaticValue(key, value) {\n    this.latestValues[key] = value;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(props, presenceContext) {\n    if (props.transformTemplate || this.props.transformTemplate) {\n      this.scheduleRender();\n    }\n    this.prevProps = this.props;\n    this.props = props;\n    this.prevPresenceContext = this.presenceContext;\n    this.presenceContext = presenceContext;\n    /**\n     * Update prop event handlers ie onAnimationStart, onAnimationComplete\n     */\n    for (let i = 0; i < propEventHandlers.length; i++) {\n      const key = propEventHandlers[i];\n      if (this.propEventSubscriptions[key]) {\n        this.propEventSubscriptions[key]();\n        delete this.propEventSubscriptions[key];\n      }\n      const listenerName = \"on\" + key;\n      const listener = props[listenerName];\n      if (listener) {\n        this.propEventSubscriptions[key] = this.on(key, listener);\n      }\n    }\n    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this), this.prevMotionValues);\n    if (this.handleChildMotionValue) {\n      this.handleChildMotionValue();\n    }\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(name) {\n    return this.props.variants ? this.props.variants[name] : undefined;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(child) {\n    const closestVariantNode = this.getClosestVariantNode();\n    if (closestVariantNode) {\n      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);\n      return () => closestVariantNode.variantChildren.delete(child);\n    }\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(key, value) {\n    // Remove existing value if it exists\n    const existingValue = this.values.get(key);\n    if (value !== existingValue) {\n      if (existingValue) this.removeValue(key);\n      this.bindToMotionValue(key, value);\n      this.values.set(key, value);\n      this.latestValues[key] = value.get();\n    }\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(key) {\n    this.values.delete(key);\n    const unsubscribe = this.valueSubscriptions.get(key);\n    if (unsubscribe) {\n      unsubscribe();\n      this.valueSubscriptions.delete(key);\n    }\n    delete this.latestValues[key];\n    this.removeValueFromRenderState(key, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(key) {\n    return this.values.has(key);\n  }\n  getValue(key, defaultValue) {\n    if (this.props.values && this.props.values[key]) {\n      return this.props.values[key];\n    }\n    let value = this.values.get(key);\n    if (value === undefined && defaultValue !== undefined) {\n      value = motionValue(defaultValue === null ? undefined : defaultValue, {\n        owner: this\n      });\n      this.addValue(key, value);\n    }\n    return value;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(key, target) {\n    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : this.getBaseTargetFromProps(this.props, key) ?? this.readValueFromInstance(this.current, key, this.options);\n    if (value !== undefined && value !== null) {\n      if (typeof value === \"string\" && (isNumericalString(value) || isZeroValueString(value))) {\n        // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n        value = parseFloat(value);\n      } else if (!findValueType(value) && complex.test(target)) {\n        value = getAnimatableNone(key, target);\n      }\n      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);\n    }\n    return isMotionValue(value) ? value.get() : value;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(key, value) {\n    this.baseTarget[key] = value;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(key) {\n    const {\n      initial\n    } = this.props;\n    let valueFromInitial;\n    if (typeof initial === \"string\" || typeof initial === \"object\") {\n      const variant = resolveVariantFromProps(this.props, initial, this.presenceContext?.custom);\n      if (variant) {\n        valueFromInitial = variant[key];\n      }\n    }\n    /**\n     * If this value still exists in the current initial variant, read that.\n     */\n    if (initial && valueFromInitial !== undefined) {\n      return valueFromInitial;\n    }\n    /**\n     * Alternatively, if this VisualElement config has defined a getBaseTarget\n     * so we can read the value from an alternative source, try that.\n     */\n    const target = this.getBaseTargetFromProps(this.props, key);\n    if (target !== undefined && !isMotionValue(target)) return target;\n    /**\n     * If the value was initially defined on initial, but it doesn't any more,\n     * return undefined. Otherwise return the value as initially read from the DOM.\n     */\n    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    return this.events[eventName].add(callback);\n  }\n  notify(eventName, ...args) {\n    if (this.events[eventName]) {\n      this.events[eventName].notify(...args);\n    }\n  }\n  scheduleRenderMicrotask() {\n    microtask.render(this.render);\n  }\n}\nexport { VisualElement, getFeatureDefinitions, setFeatureDefinitions };","map":{"version":3,"names":["propEventHandlers","featureDefinitions","setFeatureDefinitions","definitions","getFeatureDefinitions","VisualElement","scrapeMotionValuesFromProps","_props","_prevProps","_visualElement","constructor","parent","props","presenceContext","reducedMotionConfig","skipAnimations","blockInitialAnimation","visualState","options","current","children","Set","isVariantNode","isControllingVariants","shouldReduceMotion","shouldSkipAnimations","values","Map","KeyframeResolver","features","valueSubscriptions","prevMotionValues","hasBeenMounted","events","propEventSubscriptions","notifyUpdate","notify","latestValues","render","triggerBuild","renderInstance","renderState","style","projection","renderScheduledAt","scheduleRender","now","time","frame","baseTarget","initialValues","initial","depth","skipAnimationsConfig","Boolean","variantChildren","manuallyAnimateOnMount","willChange","initialMotionValues","key","value","undefined","isMotionValue","set","mount","instance","get","jump","visualElementStore","removeFromVariantTree","addVariantChild","forEach","bindToMotionValue","hasReducedMotionListener","initPrefersReducedMotion","prefersReducedMotion","process","env","NODE_ENV","warnOnce","addChild","update","unmount","cancelFrame","remove","clear","removeChild","feature","isMounted","child","add","enteringChildren","delete","has","accelerate","acceleratedValues","HTMLElement","factory","keyframes","times","ease","duration","animation","NativeAnimation","element","name","secondsToMilliseconds","cleanup","cancel","valueIsTransform","transformProps","onBindTransform","removeOnChange","on","latestValue","onUpdate","preRender","isTransformDirty","removeSyncCheck","window","MotionCheckAppearSync","owner","stop","sortNodePosition","other","sortInstanceNodePosition","type","updateFeatures","featureDefinition","isEnabled","Feature","FeatureConstructor","build","measureViewportBox","measureInstanceViewportBox","createBox","getStaticValue","setStaticValue","transformTemplate","prevProps","prevPresenceContext","i","length","listenerName","listener","updateMotionValuesFromProps","handleChildMotionValue","getProps","getVariant","variants","getDefaultTransition","transition","getTransformPagePoint","transformPagePoint","getClosestVariantNode","closestVariantNode","addValue","existingValue","removeValue","unsubscribe","removeValueFromRenderState","hasValue","getValue","defaultValue","motionValue","readValue","target","getBaseTargetFromProps","readValueFromInstance","isNumericalString","isZeroValueString","parseFloat","findValueType","complex","test","getAnimatableNone","setBaseTarget","getBaseTarget","valueFromInitial","variant","resolveVariantFromProps","custom","eventName","callback","SubscriptionManager","args","scheduleRenderMicrotask","microtask"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/render/VisualElement.ts"],"sourcesContent":["import {\n    Box,\n    isNumericalString,\n    isZeroValueString,\n    secondsToMilliseconds,\n    SubscriptionManager,\n    warnOnce,\n} from \"motion-utils\"\nimport { KeyframeResolver } from \"../animation/keyframes/KeyframesResolver\"\nimport { NativeAnimation } from \"../animation/NativeAnimation\"\nimport type { AnyResolvedKeyframe } from \"../animation/types\"\nimport { acceleratedValues } from \"../animation/waapi/utils/accelerated-values\"\nimport { cancelFrame, frame } from \"../frameloop\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { time } from \"../frameloop/sync-time\"\nimport type { MotionNodeOptions } from \"../node/types\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { motionValue, MotionValue } from \"../value\"\nimport { complex } from \"../value/types/complex\"\nimport { getAnimatableNone } from \"../value/types/utils/animatable-none\"\nimport { findValueType } from \"../value/types/utils/find\"\nimport { isMotionValue } from \"../value/utils/is-motion-value\"\nimport { Feature } from \"./Feature\"\nimport { visualElementStore } from \"./store\"\nimport {\n    FeatureDefinitions,\n    MotionConfigContextProps,\n    PresenceContextProps,\n    ReducedMotionConfig,\n    ResolvedValues,\n    VisualElementEventCallbacks,\n    VisualElementOptions,\n} from \"./types\"\nimport { AnimationState } from \"./utils/animation-state\"\nimport {\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n} from \"./utils/is-controlling-variants\"\nimport { transformProps } from \"./utils/keys-transform\"\nimport { updateMotionValuesFromProps } from \"./utils/motion-values\"\nimport {\n    hasReducedMotionListener,\n    initPrefersReducedMotion,\n    prefersReducedMotion,\n} from \"./utils/reduced-motion\"\nimport { resolveVariantFromProps } from \"./utils/resolve-variants\"\n\nconst propEventHandlers = [\n    \"AnimationStart\",\n    \"AnimationComplete\",\n    \"Update\",\n    \"BeforeLayoutMeasure\",\n    \"LayoutMeasure\",\n    \"LayoutAnimationStart\",\n    \"LayoutAnimationComplete\",\n] as const\n\n/**\n * Static feature definitions - can be injected by framework layer\n */\nlet featureDefinitions: Partial<FeatureDefinitions> = {}\n\n/**\n * Set feature definitions for all VisualElements.\n * This should be called by the framework layer (e.g., framer-motion) during initialization.\n */\nexport function setFeatureDefinitions(\n    definitions: Partial<FeatureDefinitions>\n) {\n    featureDefinitions = definitions\n}\n\n/**\n * Get the current feature definitions\n */\nexport function getFeatureDefinitions(): Partial<FeatureDefinitions> {\n    return featureDefinitions\n}\n\n/**\n * Motion style type - a subset of CSS properties that can contain motion values\n */\nexport type MotionStyle = {\n    [K: string]: AnyResolvedKeyframe | MotionValue | undefined\n}\n\n/**\n * A VisualElement is an imperative abstraction around UI elements such as\n * HTMLElement, SVGElement, Three.Object3D etc.\n */\nexport abstract class VisualElement<\n    Instance = unknown,\n    RenderState = unknown,\n    Options extends {} = {}\n> {\n    /**\n     * VisualElements are arranged in trees mirroring that of the React tree.\n     * Each type of VisualElement has a unique name, to detect when we're crossing\n     * type boundaries within that tree.\n     */\n    abstract type: string\n\n    /**\n     * An `Array.sort` compatible function that will compare two Instances and\n     * compare their respective positions within the tree.\n     */\n    abstract sortInstanceNodePosition(a: Instance, b: Instance): number\n\n    /**\n     * Measure the viewport-relative bounding box of the Instance.\n     */\n    abstract measureInstanceViewportBox(\n        instance: Instance,\n        props: MotionNodeOptions & Partial<MotionConfigContextProps>\n    ): Box\n\n    /**\n     * When a value has been removed from all animation props we need to\n     * pick a target to animate back to. For instance, for HTMLElements\n     * we can look in the style prop.\n     */\n    abstract getBaseTargetFromProps(\n        props: MotionNodeOptions,\n        key: string\n    ): AnyResolvedKeyframe | undefined | MotionValue\n\n    /**\n     * When we first animate to a value we need to animate it *from* a value.\n     * Often this have been specified via the initial prop but it might be\n     * that the value needs to be read from the Instance.\n     */\n    abstract readValueFromInstance(\n        instance: Instance,\n        key: string,\n        options: Options\n    ): AnyResolvedKeyframe | null | undefined\n\n    /**\n     * When a value has been removed from the VisualElement we use this to remove\n     * it from the inherting class' unique render state.\n     */\n    abstract removeValueFromRenderState(\n        key: string,\n        renderState: RenderState\n    ): void\n\n    /**\n     * Run before a React or VisualElement render, builds the latest motion\n     * values into an Instance-specific format. For example, HTMLVisualElement\n     * will use this step to build `style` and `var` values.\n     */\n    abstract build(\n        renderState: RenderState,\n        latestValues: ResolvedValues,\n        props: MotionNodeOptions\n    ): void\n\n    /**\n     * Apply the built values to the Instance. For example, HTMLElements will have\n     * styles applied via `setProperty` and the style attribute, whereas SVGElements\n     * will have values applied to attributes.\n     */\n    abstract renderInstance(\n        instance: Instance,\n        renderState: RenderState,\n        styleProp?: MotionStyle,\n        projection?: any\n    ): void\n\n    /**\n     * This method is called when a transform property is bound to a motion value.\n     * It's currently used to measure SVG elements when a new transform property is bound.\n     */\n    onBindTransform?(): void\n\n    /**\n     * If the component child is provided as a motion value, handle subscriptions\n     * with the renderer-specific VisualElement.\n     */\n    handleChildMotionValue?(): void\n\n    /**\n     * This method takes React props and returns found MotionValues. For example, HTML\n     * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n     *\n     * This isn't an abstract method as it needs calling in the constructor, but it is\n     * intended to be one.\n     */\n    scrapeMotionValuesFromProps(\n        _props: MotionNodeOptions,\n        _prevProps: MotionNodeOptions,\n        _visualElement: VisualElement\n    ): {\n        [key: string]: MotionValue | AnyResolvedKeyframe\n    } {\n        return {}\n    }\n\n    /**\n     * A reference to the current underlying Instance, e.g. a HTMLElement\n     * or Three.Mesh etc.\n     */\n    current: Instance | null = null\n\n    /**\n     * A reference to the parent VisualElement (if exists).\n     */\n    parent: VisualElement | undefined\n\n    /**\n     * A set containing references to this VisualElement's children.\n     */\n    children = new Set<VisualElement>()\n\n    /**\n     * A set containing the latest children of this VisualElement. This is flushed\n     * at the start of every commit. We use it to calculate the stagger delay\n     * for newly-added children.\n     */\n    enteringChildren?: Set<VisualElement>\n\n    /**\n     * The depth of this VisualElement within the overall VisualElement tree.\n     */\n    depth: number\n\n    /**\n     * The current render state of this VisualElement. Defined by inherting VisualElements.\n     */\n    renderState: RenderState\n\n    /**\n     * An object containing the latest static values for each of this VisualElement's\n     * MotionValues.\n     */\n    latestValues: ResolvedValues\n\n    /**\n     * Determine what role this visual element should take in the variant tree.\n     */\n    isVariantNode: boolean = false\n    isControllingVariants: boolean = false\n\n    /**\n     * If this component is part of the variant tree, it should track\n     * any children that are also part of the tree. This is essentially\n     * a shadow tree to simplify logic around how to stagger over children.\n     */\n    variantChildren?: Set<VisualElement>\n\n    /**\n     * Decides whether this VisualElement should animate in reduced motion\n     * mode.\n     *\n     * TODO: This is currently set on every individual VisualElement but feels\n     * like it could be set globally.\n     */\n    shouldReduceMotion: boolean | null = null\n\n    /**\n     * Decides whether animations should be skipped for this VisualElement.\n     * Useful for E2E tests and visual regression testing.\n     */\n    shouldSkipAnimations: boolean = false\n\n    /**\n     * Normally, if a component is controlled by a parent's variants, it can\n     * rely on that ancestor to trigger animations further down the tree.\n     * However, if a component is created after its parent is mounted, the parent\n     * won't trigger that mount animation so the child needs to.\n     *\n     * TODO: This might be better replaced with a method isParentMounted\n     */\n    manuallyAnimateOnMount: boolean\n\n    /**\n     * This can be set by AnimatePresence to force components that mount\n     * at the same time as it to mount as if they have initial={false} set.\n     */\n    blockInitialAnimation: boolean\n\n    /**\n     * A reference to this VisualElement's projection node, used in layout animations.\n     */\n    projection?: any\n\n    /**\n     * A map of all motion values attached to this visual element. Motion\n     * values are source of truth for any given animated value. A motion\n     * value might be provided externally by the component via props.\n     */\n    values = new Map<string, MotionValue>()\n\n    /**\n     * The AnimationState, this is hydrated by the animation Feature.\n     */\n    animationState?: AnimationState\n\n    KeyframeResolver = KeyframeResolver\n\n    /**\n     * The options used to create this VisualElement. The Options type is defined\n     * by the inheriting VisualElement and is passed straight through to the render functions.\n     */\n    readonly options: Options\n\n    /**\n     * A reference to the latest props provided to the VisualElement's host React component.\n     */\n    props: MotionNodeOptions\n    prevProps?: MotionNodeOptions\n\n    presenceContext: PresenceContextProps | null\n    prevPresenceContext?: PresenceContextProps | null\n\n    /**\n     * Cleanup functions for active features (hover/tap/exit etc)\n     */\n    private features: {\n        [K in keyof FeatureDefinitions]?: Feature<Instance>\n    } = {}\n\n    /**\n     * A map of every subscription that binds the provided or generated\n     * motion values onChange listeners to this visual element.\n     */\n    private valueSubscriptions = new Map<string, VoidFunction>()\n\n    /**\n     * A reference to the ReducedMotionConfig passed to the VisualElement's host React component.\n     */\n    private reducedMotionConfig: ReducedMotionConfig | undefined\n\n    /**\n     * A reference to the skipAnimations config passed to the VisualElement's host React component.\n     */\n    private skipAnimationsConfig: boolean | undefined\n\n    /**\n     * On mount, this will be hydrated with a callback to disconnect\n     * this visual element from its parent on unmount.\n     */\n    private removeFromVariantTree: undefined | VoidFunction\n\n    /**\n     * A reference to the previously-provided motion values as returned\n     * from scrapeMotionValuesFromProps. We use the keys in here to determine\n     * if any motion values need to be removed after props are updated.\n     */\n    private prevMotionValues: MotionStyle = {}\n\n    /**\n     * When values are removed from all animation props we need to search\n     * for a fallback value to animate to. These values are tracked in baseTarget.\n     */\n    private baseTarget: ResolvedValues\n\n    /**\n     * Create an object of the values we initially animated from (if initial prop present).\n     */\n    private initialValues: ResolvedValues\n\n    /**\n     * Track whether this element has been mounted before, to detect\n     * remounts after Suspense unmount/remount cycles.\n     */\n    private hasBeenMounted = false\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    /**\n     * An object containing an unsubscribe function for each prop event subscription.\n     * For example, every \"Update\" event can have multiple subscribers via\n     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.\n     */\n    private propEventSubscriptions: {\n        [key: string]: VoidFunction\n    } = {}\n\n    constructor(\n        {\n            parent,\n            props,\n            presenceContext,\n            reducedMotionConfig,\n            skipAnimations,\n            blockInitialAnimation,\n            visualState,\n        }: VisualElementOptions<Instance, RenderState>,\n        options: Options = {} as any\n    ) {\n        const { latestValues, renderState } = visualState\n        this.latestValues = latestValues\n        this.baseTarget = { ...latestValues }\n        this.initialValues = props.initial ? { ...latestValues } : {}\n        this.renderState = renderState\n        this.parent = parent\n        this.props = props\n        this.presenceContext = presenceContext\n        this.depth = parent ? parent.depth + 1 : 0\n        this.reducedMotionConfig = reducedMotionConfig\n        this.skipAnimationsConfig = skipAnimations\n        this.options = options\n        this.blockInitialAnimation = Boolean(blockInitialAnimation)\n\n        this.isControllingVariants = checkIsControllingVariants(props)\n        this.isVariantNode = checkIsVariantNode(props)\n        if (this.isVariantNode) {\n            this.variantChildren = new Set()\n        }\n\n        this.manuallyAnimateOnMount = Boolean(parent && parent.current)\n\n        /**\n         * Any motion values that are provided to the element when created\n         * aren't yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn't necessarily a breaking change,\n         * more a reflection of the test.\n         */\n        const { willChange, ...initialMotionValues } =\n            this.scrapeMotionValuesFromProps(props, {}, this)\n\n        for (const key in initialMotionValues) {\n            const value = initialMotionValues[key]\n\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key])\n            }\n        }\n    }\n\n    mount(instance: Instance) {\n        /**\n         * If this element has been mounted before (e.g. after a Suspense\n         * unmount/remount), reset motion values to their initial state\n         * so animations replay correctly from initial → animate.\n         */\n        if (this.hasBeenMounted) {\n            for (const key in this.initialValues) {\n                this.values.get(key)?.jump(this.initialValues[key])\n                this.latestValues[key] = this.initialValues[key]\n            }\n        }\n\n        this.current = instance\n\n        visualElementStore.set(instance, this)\n\n        if (this.projection && !this.projection.instance) {\n            this.projection.mount(instance)\n        }\n\n        if (this.parent && this.isVariantNode && !this.isControllingVariants) {\n            this.removeFromVariantTree = this.parent.addVariantChild(this)\n        }\n\n        this.values.forEach((value, key) => this.bindToMotionValue(key, value))\n\n        /**\n         * Determine reduced motion preference. Only initialize the matchMedia\n         * listener if we actually need the dynamic value (i.e., when config\n         * is neither \"never\" nor \"always\").\n         */\n        if (this.reducedMotionConfig === \"never\") {\n            this.shouldReduceMotion = false\n        } else if (this.reducedMotionConfig === \"always\") {\n            this.shouldReduceMotion = true\n        } else {\n            if (!hasReducedMotionListener.current) {\n                initPrefersReducedMotion()\n            }\n            this.shouldReduceMotion = prefersReducedMotion.current\n        }\n\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                this.shouldReduceMotion !== true,\n                \"You have Reduced Motion enabled on your device. Animations may not appear as expected.\",\n                \"reduced-motion-disabled\"\n            )\n        }\n\n        /**\n         * Set whether animations should be skipped based on the config.\n         */\n        this.shouldSkipAnimations = this.skipAnimationsConfig ?? false\n\n        this.parent?.addChild(this)\n\n        this.update(this.props, this.presenceContext)\n\n        this.hasBeenMounted = true\n    }\n\n    unmount() {\n        this.projection && this.projection.unmount()\n        cancelFrame(this.notifyUpdate)\n        cancelFrame(this.render)\n        this.valueSubscriptions.forEach((remove) => remove())\n        this.valueSubscriptions.clear()\n        this.removeFromVariantTree && this.removeFromVariantTree()\n        this.parent?.removeChild(this)\n\n        for (const key in this.events) {\n            this.events[key].clear()\n        }\n\n        for (const key in this.features) {\n            const feature = this.features[key as keyof typeof this.features]\n            if (feature) {\n                feature.unmount()\n                feature.isMounted = false\n            }\n        }\n        this.current = null\n    }\n\n    addChild(child: VisualElement) {\n        this.children.add(child)\n        this.enteringChildren ??= new Set()\n        this.enteringChildren.add(child)\n    }\n\n    removeChild(child: VisualElement) {\n        this.children.delete(child)\n        this.enteringChildren && this.enteringChildren.delete(child)\n    }\n\n    private bindToMotionValue(key: string, value: MotionValue) {\n        if (this.valueSubscriptions.has(key)) {\n            this.valueSubscriptions.get(key)!()\n        }\n\n        if (\n            value.accelerate &&\n            acceleratedValues.has(key) &&\n            this.current instanceof HTMLElement\n        ) {\n            const { factory, keyframes, times, ease, duration } =\n                value.accelerate\n\n            const animation = new NativeAnimation({\n                element: this.current,\n                name: key,\n                keyframes,\n                times,\n                ease,\n                duration: secondsToMilliseconds(duration),\n            })\n\n            const cleanup = factory(animation)\n\n            this.valueSubscriptions.set(key, () => {\n                cleanup()\n                animation.cancel()\n            })\n            return\n        }\n\n        const valueIsTransform = transformProps.has(key)\n\n        if (valueIsTransform && this.onBindTransform) {\n            this.onBindTransform()\n        }\n\n        const removeOnChange = value.on(\n            \"change\",\n            (latestValue: AnyResolvedKeyframe) => {\n                this.latestValues[key] = latestValue\n\n                this.props.onUpdate && frame.preRender(this.notifyUpdate)\n\n                if (valueIsTransform && this.projection) {\n                    this.projection.isTransformDirty = true\n                }\n\n                this.scheduleRender()\n            }\n        )\n\n        let removeSyncCheck: VoidFunction | void\n        if (\n            typeof window !== \"undefined\" &&\n            (window as any).MotionCheckAppearSync\n        ) {\n            removeSyncCheck = (window as any).MotionCheckAppearSync(\n                this,\n                key,\n                value\n            )\n        }\n\n        this.valueSubscriptions.set(key, () => {\n            removeOnChange()\n            if (removeSyncCheck) removeSyncCheck()\n            if (value.owner) value.stop()\n        })\n    }\n\n    sortNodePosition(other: VisualElement<Instance>) {\n        /**\n         * If these nodes aren't even of the same type we can't compare their depth.\n         */\n        if (\n            !this.current ||\n            !this.sortInstanceNodePosition ||\n            this.type !== other.type\n        ) {\n            return 0\n        }\n\n        return this.sortInstanceNodePosition(\n            this.current as Instance,\n            other.current as Instance\n        )\n    }\n\n    updateFeatures() {\n        let key: keyof typeof featureDefinitions = \"animation\"\n\n        for (key in featureDefinitions) {\n            const featureDefinition = featureDefinitions[key]\n\n            if (!featureDefinition) continue\n\n            const { isEnabled, Feature: FeatureConstructor } = featureDefinition\n\n            /**\n             * If this feature is enabled but not active, make a new instance.\n             */\n            if (\n                !this.features[key] &&\n                FeatureConstructor &&\n                isEnabled(this.props)\n            ) {\n                this.features[key] = new FeatureConstructor(this) as any\n            }\n\n            /**\n             * If we have a feature, mount or update it.\n             */\n            if (this.features[key]) {\n                const feature = this.features[key]!\n                if (feature.isMounted) {\n                    feature.update()\n                } else {\n                    feature.mount()\n                    feature.isMounted = true\n                }\n            }\n        }\n    }\n\n    notifyUpdate = () => this.notify(\"Update\", this.latestValues)\n\n    triggerBuild() {\n        this.build(this.renderState, this.latestValues, this.props)\n    }\n\n    render = () => {\n        if (!this.current) return\n        this.triggerBuild()\n        this.renderInstance(\n            this.current,\n            this.renderState,\n            (this.props as any).style,\n            this.projection\n        )\n    }\n\n    private renderScheduledAt = 0.0\n    scheduleRender = () => {\n        const now = time.now()\n        if (this.renderScheduledAt < now) {\n            this.renderScheduledAt = now\n            frame.render(this.render, false, true)\n        }\n    }\n\n    /**\n     * Measure the current viewport box with or without transforms.\n     * Only measures axis-aligned boxes, rotate and skew must be manually\n     * removed with a re-render to work.\n     */\n    measureViewportBox() {\n        return this.current\n            ? this.measureInstanceViewportBox(this.current, this.props)\n            : createBox()\n    }\n\n    getStaticValue(key: string) {\n        return this.latestValues[key]\n    }\n\n    setStaticValue(key: string, value: AnyResolvedKeyframe) {\n        this.latestValues[key] = value\n    }\n\n    /**\n     * Update the provided props. Ensure any newly-added motion values are\n     * added to our map, old ones removed, and listeners updated.\n     */\n    update(\n        props: MotionNodeOptions,\n        presenceContext: PresenceContextProps | null\n    ) {\n        if (props.transformTemplate || this.props.transformTemplate) {\n            this.scheduleRender()\n        }\n\n        this.prevProps = this.props\n        this.props = props\n\n        this.prevPresenceContext = this.presenceContext\n        this.presenceContext = presenceContext\n\n        /**\n         * Update prop event handlers ie onAnimationStart, onAnimationComplete\n         */\n        for (let i = 0; i < propEventHandlers.length; i++) {\n            const key = propEventHandlers[i]\n            if (this.propEventSubscriptions[key]) {\n                this.propEventSubscriptions[key]()\n                delete this.propEventSubscriptions[key]\n            }\n\n            const listenerName = (\"on\" + key) as keyof typeof props\n            const listener = props[listenerName]\n            if (listener) {\n                this.propEventSubscriptions[key] = this.on(key as any, listener)\n            }\n        }\n\n        this.prevMotionValues = updateMotionValuesFromProps(\n            this,\n            this.scrapeMotionValuesFromProps(props, this.prevProps || {}, this),\n            this.prevMotionValues\n        )\n\n        if (this.handleChildMotionValue) {\n            this.handleChildMotionValue()\n        }\n    }\n\n    getProps() {\n        return this.props\n    }\n\n    /**\n     * Returns the variant definition with a given name.\n     */\n    getVariant(name: string) {\n        return this.props.variants ? this.props.variants[name] : undefined\n    }\n\n    /**\n     * Returns the defined default transition on this component.\n     */\n    getDefaultTransition() {\n        return this.props.transition\n    }\n\n    getTransformPagePoint() {\n        return (this.props as any).transformPagePoint\n    }\n\n    getClosestVariantNode(): VisualElement | undefined {\n        return this.isVariantNode\n            ? this\n            : this.parent\n            ? this.parent.getClosestVariantNode()\n            : undefined\n    }\n\n    /**\n     * Add a child visual element to our set of children.\n     */\n    addVariantChild(child: VisualElement) {\n        const closestVariantNode = this.getClosestVariantNode()\n        if (closestVariantNode) {\n            closestVariantNode.variantChildren &&\n                closestVariantNode.variantChildren.add(child)\n            return () => closestVariantNode.variantChildren!.delete(child)\n        }\n    }\n\n    /**\n     * Add a motion value and bind it to this visual element.\n     */\n    addValue(key: string, value: MotionValue) {\n        // Remove existing value if it exists\n        const existingValue = this.values.get(key)\n\n        if (value !== existingValue) {\n            if (existingValue) this.removeValue(key)\n            this.bindToMotionValue(key, value)\n            this.values.set(key, value)\n            this.latestValues[key] = value.get()\n        }\n    }\n\n    /**\n     * Remove a motion value and unbind any active subscriptions.\n     */\n    removeValue(key: string) {\n        this.values.delete(key)\n        const unsubscribe = this.valueSubscriptions.get(key)\n        if (unsubscribe) {\n            unsubscribe()\n            this.valueSubscriptions.delete(key)\n        }\n        delete this.latestValues[key]\n        this.removeValueFromRenderState(key, this.renderState)\n    }\n\n    /**\n     * Check whether we have a motion value for this key\n     */\n    hasValue(key: string) {\n        return this.values.has(key)\n    }\n\n    /**\n     * Get a motion value for this key. If called with a default\n     * value, we'll create one if none exists.\n     */\n    getValue(key: string): MotionValue | undefined\n    getValue(key: string, defaultValue: AnyResolvedKeyframe | null): MotionValue\n    getValue(\n        key: string,\n        defaultValue?: AnyResolvedKeyframe | null\n    ): MotionValue | undefined {\n        if (this.props.values && this.props.values[key]) {\n            return this.props.values[key]\n        }\n\n        let value = this.values.get(key)\n\n        if (value === undefined && defaultValue !== undefined) {\n            value = motionValue(\n                defaultValue === null ? undefined : defaultValue,\n                { owner: this }\n            )\n            this.addValue(key, value)\n        }\n\n        return value\n    }\n\n    /**\n     * If we're trying to animate to a previously unencountered value,\n     * we need to check for it in our state and as a last resort read it\n     * directly from the instance (which might have performance implications).\n     */\n    readValue(key: string, target?: AnyResolvedKeyframe | null) {\n        let value =\n            this.latestValues[key] !== undefined || !this.current\n                ? this.latestValues[key]\n                : this.getBaseTargetFromProps(this.props, key) ??\n                  this.readValueFromInstance(this.current, key, this.options)\n\n        if (value !== undefined && value !== null) {\n            if (\n                typeof value === \"string\" &&\n                (isNumericalString(value) || isZeroValueString(value))\n            ) {\n                // If this is a number read as a string, ie \"0\" or \"200\", convert it to a number\n                value = parseFloat(value)\n            } else if (!findValueType(value) && complex.test(target)) {\n                value = getAnimatableNone(key, target as string)\n            }\n\n            this.setBaseTarget(key, isMotionValue(value) ? value.get() : value)\n        }\n\n        return isMotionValue(value) ? value.get() : value\n    }\n\n    /**\n     * Set the base target to later animate back to. This is currently\n     * only hydrated on creation and when we first read a value.\n     */\n    setBaseTarget(key: string, value: AnyResolvedKeyframe) {\n        this.baseTarget[key] = value\n    }\n\n    /**\n     * Find the base target for a value thats been removed from all animation\n     * props.\n     */\n    getBaseTarget(key: string): ResolvedValues[string] | undefined | null {\n        const { initial } = this.props\n\n        let valueFromInitial: ResolvedValues[string] | undefined | null\n\n        if (typeof initial === \"string\" || typeof initial === \"object\") {\n            const variant = resolveVariantFromProps(\n                this.props,\n                initial as any,\n                this.presenceContext?.custom\n            )\n            if (variant) {\n                valueFromInitial = variant[\n                    key as keyof typeof variant\n                ] as string\n            }\n        }\n\n        /**\n         * If this value still exists in the current initial variant, read that.\n         */\n        if (initial && valueFromInitial !== undefined) {\n            return valueFromInitial\n        }\n\n        /**\n         * Alternatively, if this VisualElement config has defined a getBaseTarget\n         * so we can read the value from an alternative source, try that.\n         */\n        const target = this.getBaseTargetFromProps(this.props, key)\n        if (target !== undefined && !isMotionValue(target)) return target\n\n        /**\n         * If the value was initially defined on initial, but it doesn't any more,\n         * return undefined. Otherwise return the value as initially read from the DOM.\n         */\n        return this.initialValues[key] !== undefined &&\n            valueFromInitial === undefined\n            ? undefined\n            : this.baseTarget[key]\n    }\n\n    on<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        callback: VisualElementEventCallbacks[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        return this.events[eventName].add(callback)\n    }\n\n    notify<EventName extends keyof VisualElementEventCallbacks>(\n        eventName: EventName,\n        ...args: any\n    ) {\n        if (this.events[eventName]) {\n            this.events[eventName].notify(...args)\n        }\n    }\n\n    scheduleRenderMicrotask() {\n        microtask.render(this.render)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}