{"ast":null,"code":"import _objectSpread from \"/home/zeinab/ziblog/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/zeinab/ziblog/Frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"autoTransform\", \"matrix\", \"axisLock\", \"dragLimits\", \"onHover\", \"onDragStart\", \"onDrag\", \"onDragEnd\", \"children\", \"dragConfig\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\nconst initialModelPosition = /* @__PURE__ */new THREE.Vector3();\nconst mousePosition2D = /* @__PURE__ */new THREE.Vector2();\nconst mousePosition3D = /* @__PURE__ */new THREE.Vector3();\nconst dragOffset = /* @__PURE__ */new THREE.Vector3();\nconst dragPlaneNormal = /* @__PURE__ */new THREE.Vector3();\nconst dragPlane = /* @__PURE__ */new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef((_ref, fRef) => {\n  let {\n      autoTransform = true,\n      matrix,\n      axisLock,\n      dragLimits,\n      onHover,\n      onDragStart,\n      onDrag,\n      onDragEnd,\n      children,\n      dragConfig\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: _ref2 => {\n      let {\n        hovering\n      } = _ref2;\n      return onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false);\n    },\n    onDragStart: _ref3 => {\n      let {\n        event\n      } = _ref3;\n      if (defaultControls) defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: _ref4 => {\n      let {\n        xy: [dragX, dragY],\n        intentional\n      } = _ref4;\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (defaultControls) defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: _objectSpread({\n      filterTaps: true,\n      threshold: 1\n    }, typeof dragConfig === 'object' ? dragConfig : {})\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\nexport { DragControls };","map":{"version":3,"names":["_extends","React","THREE","useThree","useGesture","initialModelPosition","Vector3","mousePosition2D","Vector2","mousePosition3D","dragOffset","dragPlaneNormal","dragPlane","Plane","DragControls","forwardRef","_ref","fRef","autoTransform","matrix","axisLock","dragLimits","onHover","onDragStart","onDrag","onDragEnd","children","dragConfig","props","_objectWithoutProperties","_excluded","defaultControls","state","controls","camera","size","raycaster","invalidate","ref","useRef","bind","_ref2","hovering","_ref3","event","enabled","point","current","decompose","Quaternion","copy","sub","_ref4","xy","dragX","dragY","intentional","normalizedMouseX","left","width","normalizedMouseY","top","height","set","setFromCamera","getWorldDirection","negate","setFromNormalAndCoplanarPoint","ray","intersectPlane","previousLocalMatrix","clone","previousWorldMatrix","matrixWorld","intendedNewPosition","x","y","z","Math","max","min","setPosition","deltaLocalMatrix","multiply","invert","deltaWorldMatrix","tempMatrix","Matrix4","drag","_objectSpread","filterTaps","threshold","useImperativeHandle","useLayoutEffect","createElement","matrixAutoUpdate"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/@react-three/drei/web/DragControls.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport * as THREE from 'three';\nimport { useThree } from '@react-three/fiber';\nimport { useGesture } from '@use-gesture/react';\n\nconst initialModelPosition = /* @__PURE__ */new THREE.Vector3();\nconst mousePosition2D = /* @__PURE__ */new THREE.Vector2();\nconst mousePosition3D = /* @__PURE__ */new THREE.Vector3();\nconst dragOffset = /* @__PURE__ */new THREE.Vector3();\nconst dragPlaneNormal = /* @__PURE__ */new THREE.Vector3();\nconst dragPlane = /* @__PURE__ */new THREE.Plane();\nconst DragControls = /*#__PURE__*/React.forwardRef(({\n  autoTransform = true,\n  matrix,\n  axisLock,\n  dragLimits,\n  onHover,\n  onDragStart,\n  onDrag,\n  onDragEnd,\n  children,\n  dragConfig,\n  ...props\n}, fRef) => {\n  const defaultControls = useThree(state => state.controls);\n  const {\n    camera,\n    size,\n    raycaster,\n    invalidate\n  } = useThree();\n  const ref = React.useRef(null);\n  const bind = useGesture({\n    onHover: ({\n      hovering\n    }) => onHover && onHover(hovering !== null && hovering !== void 0 ? hovering : false),\n    onDragStart: ({\n      event\n    }) => {\n      if (defaultControls) defaultControls.enabled = false;\n      const {\n        point\n      } = event;\n      ref.current.matrix.decompose(initialModelPosition, new THREE.Quaternion(), new THREE.Vector3());\n      mousePosition3D.copy(point);\n      dragOffset.copy(mousePosition3D).sub(initialModelPosition);\n      onDragStart && onDragStart(initialModelPosition);\n      invalidate();\n    },\n    onDrag: ({\n      xy: [dragX, dragY],\n      intentional\n    }) => {\n      if (!intentional) return;\n      const normalizedMouseX = (dragX - size.left) / size.width * 2 - 1;\n      const normalizedMouseY = -((dragY - size.top) / size.height) * 2 + 1;\n      mousePosition2D.set(normalizedMouseX, normalizedMouseY);\n      raycaster.setFromCamera(mousePosition2D, camera);\n      if (!axisLock) {\n        camera.getWorldDirection(dragPlaneNormal).negate();\n      } else {\n        switch (axisLock) {\n          case 'x':\n            dragPlaneNormal.set(1, 0, 0);\n            break;\n          case 'y':\n            dragPlaneNormal.set(0, 1, 0);\n            break;\n          case 'z':\n            dragPlaneNormal.set(0, 0, 1);\n            break;\n        }\n      }\n      dragPlane.setFromNormalAndCoplanarPoint(dragPlaneNormal, mousePosition3D);\n      raycaster.ray.intersectPlane(dragPlane, mousePosition3D);\n      const previousLocalMatrix = ref.current.matrix.clone();\n      const previousWorldMatrix = ref.current.matrixWorld.clone();\n      const intendedNewPosition = new THREE.Vector3(mousePosition3D.x - dragOffset.x, mousePosition3D.y - dragOffset.y, mousePosition3D.z - dragOffset.z);\n      if (dragLimits) {\n        intendedNewPosition.x = dragLimits[0] ? Math.max(Math.min(intendedNewPosition.x, dragLimits[0][1]), dragLimits[0][0]) : intendedNewPosition.x;\n        intendedNewPosition.y = dragLimits[1] ? Math.max(Math.min(intendedNewPosition.y, dragLimits[1][1]), dragLimits[1][0]) : intendedNewPosition.y;\n        intendedNewPosition.z = dragLimits[2] ? Math.max(Math.min(intendedNewPosition.z, dragLimits[2][1]), dragLimits[2][0]) : intendedNewPosition.z;\n      }\n      if (autoTransform) {\n        ref.current.matrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = ref.current.matrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = ref.current.matrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(ref.current.matrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      } else {\n        const tempMatrix = new THREE.Matrix4().copy(ref.current.matrix);\n        tempMatrix.setPosition(intendedNewPosition);\n        const deltaLocalMatrix = tempMatrix.clone().multiply(previousLocalMatrix.invert());\n        const deltaWorldMatrix = tempMatrix.clone().multiply(previousWorldMatrix.invert());\n        onDrag && onDrag(tempMatrix, deltaLocalMatrix, ref.current.matrixWorld, deltaWorldMatrix);\n      }\n      invalidate();\n    },\n    onDragEnd: () => {\n      if (defaultControls) defaultControls.enabled = true;\n      onDragEnd && onDragEnd();\n      invalidate();\n    }\n  }, {\n    drag: {\n      filterTaps: true,\n      threshold: 1,\n      ...(typeof dragConfig === 'object' ? dragConfig : {})\n    }\n  });\n  React.useImperativeHandle(fRef, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    if (!matrix) return;\n\n    // If the matrix is a real matrix4 it means that the user wants to control the gizmo\n    // In that case it should just be set, as a bare prop update would merely copy it\n    ref.current.matrix = matrix;\n  }, [matrix]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, bind(), {\n    matrix: matrix,\n    matrixAutoUpdate: false\n  }, props), children);\n});\n\nexport { DragControls };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}