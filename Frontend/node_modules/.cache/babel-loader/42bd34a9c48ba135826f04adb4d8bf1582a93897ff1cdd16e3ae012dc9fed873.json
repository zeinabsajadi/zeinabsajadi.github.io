{"ast":null,"code":"import _objectSpread from \"/home/zeinab/ziblog/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/zeinab/ziblog/Frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-Bj1xl_EK.js';\nimport { c as createDecodeFunction, L as LoaderBaseShared, e as extractGainmapFromJPEG, X as XMPMetadataNotFoundError, G as GainMapNotFoundError } from './Loader-DLI-_JDP.js';\nexport { M as MPFExtractor, a as extractXMP } from './Loader-DLI-_JDP.js';\nimport { ShaderMaterial, NoBlending, Vector3, WebGLRenderer, FileLoader } from 'three';\nconst vertexShader = /* glsl */\"\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vUv = uv;\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n}\\n\";\nconst fragmentShader = /* glsl */\"\\n// min half float value\\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\\n// max half float value\\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\\n\\nuniform sampler2D sdr;\\nuniform sampler2D gainMap;\\nuniform vec3 gamma;\\nuniform vec3 offsetHdr;\\nuniform vec3 offsetSdr;\\nuniform vec3 gainMapMin;\\nuniform vec3 gainMapMax;\\nuniform float weightFactor;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\\n  vec3 logRecovery = pow( recovery, gamma );\\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\\n}\\n\";\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n  /**\n   *\n   * @param params\n   */\n  constructor(_ref) {\n    let {\n      gamma,\n      offsetHdr,\n      offsetSdr,\n      gainMapMin,\n      gainMapMax,\n      maxDisplayBoost,\n      hdrCapacityMin,\n      hdrCapacityMax,\n      sdr,\n      gainMap\n    } = _ref;\n    super({\n      name: 'GainMapDecoderMaterial',\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    _defineProperty(this, \"_maxDisplayBoost\", void 0);\n    _defineProperty(this, \"_hdrCapacityMin\", void 0);\n    _defineProperty(this, \"_hdrCapacityMax\", void 0);\n    this._maxDisplayBoost = maxDisplayBoost;\n    this._hdrCapacityMin = hdrCapacityMin;\n    this._hdrCapacityMax = hdrCapacityMax;\n    this.needsUpdate = true;\n    this.uniformsNeedUpdate = true;\n  }\n  get sdr() {\n    return this.uniforms.sdr.value;\n  }\n  set sdr(value) {\n    this.uniforms.sdr.value = value;\n  }\n  get gainMap() {\n    return this.uniforms.gainMap.value;\n  }\n  set gainMap(value) {\n    this.uniforms.gainMap.value = value;\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetHdr}\n   */\n  get offsetHdr() {\n    return this.uniforms.offsetHdr.value.toArray();\n  }\n  set offsetHdr(value) {\n    this.uniforms.offsetHdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetSdr}\n   */\n  get offsetSdr() {\n    return this.uniforms.offsetSdr.value.toArray();\n  }\n  set offsetSdr(value) {\n    this.uniforms.offsetSdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMin}\n   */\n  get gainMapMin() {\n    return this.uniforms.gainMapMin.value.toArray();\n  }\n  set gainMapMin(value) {\n    this.uniforms.gainMapMin.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMax}\n   */\n  get gainMapMax() {\n    return this.uniforms.gainMapMax.value.toArray();\n  }\n  set gainMapMax(value) {\n    this.uniforms.gainMapMax.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gamma}\n   */\n  get gamma() {\n    const g = this.uniforms.gamma.value;\n    return [1 / g.x, 1 / g.y, 1 / g.z];\n  }\n  set gamma(value) {\n    const g = this.uniforms.gamma.value;\n    g.x = 1.0 / value[0];\n    g.y = 1.0 / value[1];\n    g.z = 1.0 / value[2];\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMin() {\n    return this._hdrCapacityMin;\n  }\n  set hdrCapacityMin(value) {\n    this._hdrCapacityMin = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMax() {\n    return this._hdrCapacityMax;\n  }\n  set hdrCapacityMax(value) {\n    this._hdrCapacityMax = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n   * @remarks Non Logarithmic space\n   */\n  get maxDisplayBoost() {\n    return this._maxDisplayBoost;\n  }\n  set maxDisplayBoost(value) {\n    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n    this.calculateWeight();\n  }\n  calculateWeight() {\n    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n  }\n}\nconst decodeImpl = createDecodeFunction({\n  renderer: WebGLRenderer,\n  createMaterial: params => new GainMapDecoderMaterial(params),\n  createQuadRenderer: params => new QuadRenderer(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = params => {\n  // Ensure renderer is defined for the base function\n  if (!params.renderer) {\n    throw new Error('Renderer is required for decode function');\n  }\n  const quadRenderer = decodeImpl(_objectSpread(_objectSpread({}, params), {}, {\n    renderer: params.renderer\n  }));\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends LoaderBaseShared {\n  constructor(renderer, manager) {\n    super({\n      renderer,\n      createMaterial: params => new GainMapDecoderMaterial(params),\n      createQuadRenderer: params => new QuadRenderer(params)\n    }, manager);\n  }\n  /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n    const {\n      sdrImage,\n      gainMapImage,\n      needsFlip\n    } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n    const {\n      gainMap,\n      sdr\n    } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n    this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n    quadRenderer.render();\n  }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a gainmap using separate data\n   * * sdr image\n   * * gain map image\n   * * metadata json\n   *\n   * useful for webp gain maps\n   *\n   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load(_ref2, onLoad, onProgress, onError) {\n    let [sdrUrl, gainMapUrl, metadataUrl] = _ref2;\n    const quadRenderer = this.prepareQuadRenderer();\n    let sdr;\n    let gainMap;\n    let metadata;\n    const loadCheck = async () => {\n      if (sdr && gainMap && metadata) {\n        // solves #16\n        try {\n          await this.render(quadRenderer, metadata, sdr, gainMap);\n        } catch (error) {\n          this.manager.itemError(sdrUrl);\n          this.manager.itemError(gainMapUrl);\n          this.manager.itemError(metadataUrl);\n          if (typeof onError === 'function') onError(error);\n          quadRenderer.disposeOnDemandRenderer();\n          return;\n        }\n        if (typeof onLoad === 'function') onLoad(quadRenderer);\n        this.manager.itemEnd(sdrUrl);\n        this.manager.itemEnd(gainMapUrl);\n        this.manager.itemEnd(metadataUrl);\n        quadRenderer.disposeOnDemandRenderer();\n      }\n    };\n    let sdrLengthComputable = true;\n    let sdrTotal = 0;\n    let sdrLoaded = 0;\n    let gainMapLengthComputable = true;\n    let gainMapTotal = 0;\n    let gainMapLoaded = 0;\n    let metadataLengthComputable = true;\n    let metadataTotal = 0;\n    let metadataLoaded = 0;\n    const progressHandler = () => {\n      if (typeof onProgress === 'function') {\n        const total = sdrTotal + gainMapTotal + metadataTotal;\n        const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n        const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n        onProgress(new ProgressEvent('progress', {\n          lengthComputable,\n          loaded,\n          total\n        }));\n      }\n    };\n    this.manager.itemStart(sdrUrl);\n    this.manager.itemStart(gainMapUrl);\n    this.manager.itemStart(metadataUrl);\n    const sdrLoader = new FileLoader(this._internalLoadingManager);\n    sdrLoader.setResponseType('arraybuffer');\n    sdrLoader.setRequestHeader(this.requestHeader);\n    sdrLoader.setPath(this.path);\n    sdrLoader.setWithCredentials(this.withCredentials);\n    sdrLoader.load(sdrUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');\n      sdr = buffer;\n      await loadCheck();\n    }, e => {\n      sdrLengthComputable = e.lengthComputable;\n      sdrLoaded = e.loaded;\n      sdrTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(sdrUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const gainMapLoader = new FileLoader(this._internalLoadingManager);\n    gainMapLoader.setResponseType('arraybuffer');\n    gainMapLoader.setRequestHeader(this.requestHeader);\n    gainMapLoader.setPath(this.path);\n    gainMapLoader.setWithCredentials(this.withCredentials);\n    gainMapLoader.load(gainMapUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');\n      gainMap = buffer;\n      await loadCheck();\n    }, e => {\n      gainMapLengthComputable = e.lengthComputable;\n      gainMapLoaded = e.loaded;\n      gainMapTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(gainMapUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const metadataLoader = new FileLoader(this._internalLoadingManager);\n    // metadataLoader.setResponseType('json')\n    metadataLoader.setRequestHeader(this.requestHeader);\n    metadataLoader.setPath(this.path);\n    metadataLoader.setWithCredentials(this.withCredentials);\n    metadataLoader.load(metadataUrl, async json => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof json !== 'string') throw new Error('Invalid metadata string');\n      // TODO: implement check on JSON file and remove this eslint disable\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      metadata = JSON.parse(json);\n      await loadCheck();\n    }, e => {\n      metadataLengthComputable = e.lengthComputable;\n      metadataLoaded = e.loaded;\n      metadataTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(metadataUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a JPEG containing gain map metadata\n   * Renders a normal SDR image if gainmap data is not found\n   *\n   * @param url Path to a JPEG file containing embedded gain map metadata\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load(url, onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    const loader = new FileLoader(this._internalLoadingManager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    this.manager.itemStart(url);\n    loader.load(url, async jpeg => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n      const jpegBuffer = new Uint8Array(jpeg);\n      let sdrJPEG;\n      let gainMapJPEG;\n      let metadata;\n      try {\n        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n        // gain map is successfully reconstructed\n        sdrJPEG = extractionResult.sdr;\n        gainMapJPEG = extractionResult.gainMap;\n        metadata = extractionResult.metadata;\n      } catch (e) {\n        // render the SDR version if this is not a gainmap\n        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n          console.warn(\"Failure to reconstruct an HDR image from \".concat(url, \": Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg\"));\n          metadata = {\n            gainMapMin: [0, 0, 0],\n            gainMapMax: [1, 1, 1],\n            gamma: [1, 1, 1],\n            hdrCapacityMin: 0,\n            hdrCapacityMax: 1,\n            offsetHdr: [0, 0, 0],\n            offsetSdr: [0, 0, 0]\n          };\n          sdrJPEG = jpegBuffer;\n        } else {\n          throw e;\n        }\n      }\n      // solves #16\n      try {\n        var _gainMapJPEG;\n        await this.render(quadRenderer, metadata, sdrJPEG.buffer, (_gainMapJPEG = gainMapJPEG) === null || _gainMapJPEG === void 0 ? void 0 : _gainMapJPEG.buffer);\n      } catch (error) {\n        this.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n        quadRenderer.disposeOnDemandRenderer();\n        return;\n      }\n      if (typeof onLoad === 'function') onLoad(quadRenderer);\n      this.manager.itemEnd(url);\n      quadRenderer.disposeOnDemandRenderer();\n    }, onProgress, error => {\n      this.manager.itemError(url);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\nexport { GainMapDecoderMaterial, GainMapLoader, GainMapNotFoundError, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, LoaderBaseShared, QuadRenderer, XMPMetadataNotFoundError, createDecodeFunction, decode, extractGainmapFromJPEG };","map":{"version":3,"names":["Q","QuadRenderer","c","createDecodeFunction","L","LoaderBaseShared","e","extractGainmapFromJPEG","X","XMPMetadataNotFoundError","G","GainMapNotFoundError","M","MPFExtractor","a","extractXMP","ShaderMaterial","NoBlending","Vector3","WebGLRenderer","FileLoader","vertexShader","fragmentShader","GainMapDecoderMaterial","constructor","_ref","gamma","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","name","uniforms","value","fromArray","weightFactor","Math","log2","blending","depthTest","depthWrite","_defineProperty","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","toArray","g","x","y","z","calculateWeight","max","min","val","decodeImpl","renderer","createMaterial","params","createQuadRenderer","decode","Error","quadRenderer","_objectSpread","render","disposeOnDemandRenderer","LoaderBaseWebGL","manager","metadata","sdrBuffer","gainMapBuffer","sdrImage","gainMapImage","needsFlip","processImages","createTextures","updateQuadRenderer","GainMapLoader","load","_ref2","onLoad","onProgress","onError","sdrUrl","gainMapUrl","metadataUrl","prepareQuadRenderer","loadCheck","error","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","ProgressEvent","itemStart","sdrLoader","_internalLoadingManager","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","buffer","gainMapLoader","metadataLoader","json","JSON","parse","HDRJPGLoader","url","loader","jpeg","jpegBuffer","Uint8Array","sdrJPEG","gainMapJPEG","extractionResult","console","warn","concat","_gainMapJPEG","JPEGRLoader"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/@monogrid/gainmap-js/dist/decode.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-Bj1xl_EK.js';\nimport { c as createDecodeFunction, L as LoaderBaseShared, e as extractGainmapFromJPEG, X as XMPMetadataNotFoundError, G as GainMapNotFoundError } from './Loader-DLI-_JDP.js';\nexport { M as MPFExtractor, a as extractXMP } from './Loader-DLI-_JDP.js';\nimport { ShaderMaterial, NoBlending, Vector3, WebGLRenderer, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    _maxDisplayBoost;\n    _hdrCapacityMin;\n    _hdrCapacityMax;\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\nconst decodeImpl = createDecodeFunction({\n    renderer: WebGLRenderer,\n    createMaterial: (params) => new GainMapDecoderMaterial(params),\n    createQuadRenderer: (params) => new QuadRenderer(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    // Ensure renderer is defined for the base function\n    if (!params.renderer) {\n        throw new Error('Renderer is required for decode function');\n    }\n    const quadRenderer = decodeImpl({\n        ...params,\n        renderer: params.renderer\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends LoaderBaseShared {\n    constructor(renderer, manager) {\n        super({\n            renderer,\n            createMaterial: (params) => new GainMapDecoderMaterial(params),\n            createQuadRenderer: (params) => new QuadRenderer(params)\n        }, manager);\n    }\n    /**\n     * @private\n     * @param quadRenderer\n     * @param metadata\n     * @param sdrBuffer\n     * @param gainMapBuffer\n     */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n        const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n        this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url Path to a JPEG file containing embedded gain map metadata\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, GainMapNotFoundError, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, LoaderBaseShared, QuadRenderer, XMPMetadataNotFoundError, createDecodeFunction, decode, extractGainmapFromJPEG };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}