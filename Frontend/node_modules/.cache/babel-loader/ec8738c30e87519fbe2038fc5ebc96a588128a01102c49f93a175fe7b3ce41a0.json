{"ast":null,"code":"import { resolveElements } from 'motion-dom';\nconst thresholds = {\n  some: 0,\n  all: 1\n};\nfunction inView(elementOrSelector, onStart, {\n  root,\n  margin: rootMargin,\n  amount = \"some\"\n} = {}) {\n  const elements = resolveElements(elementOrSelector);\n  const activeIntersections = new WeakMap();\n  const onIntersectionChange = entries => {\n    entries.forEach(entry => {\n      const onEnd = activeIntersections.get(entry.target);\n      /**\n       * If there's no change to the intersection, we don't need to\n       * do anything here.\n       */\n      if (entry.isIntersecting === Boolean(onEnd)) return;\n      if (entry.isIntersecting) {\n        const newOnEnd = onStart(entry.target, entry);\n        if (typeof newOnEnd === \"function\") {\n          activeIntersections.set(entry.target, newOnEnd);\n        } else {\n          observer.unobserve(entry.target);\n        }\n      } else if (typeof onEnd === \"function\") {\n        onEnd(entry);\n        activeIntersections.delete(entry.target);\n      }\n    });\n  };\n  const observer = new IntersectionObserver(onIntersectionChange, {\n    root,\n    rootMargin,\n    threshold: typeof amount === \"number\" ? amount : thresholds[amount]\n  });\n  elements.forEach(element => observer.observe(element));\n  return () => observer.disconnect();\n}\nexport { inView };","map":{"version":3,"names":["thresholds","some","all","inView","elementOrSelector","onStart","root","margin","rootMargin","amount","elements","resolveElements","activeIntersections","WeakMap","onIntersectionChange","entries","forEach","entry","onEnd","get","target","isIntersecting","Boolean","newOnEnd","set","observer","unobserve","delete","IntersectionObserver","threshold","element","observe","disconnect"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/render/dom/viewport/index.ts"],"sourcesContent":["import { ElementOrSelector, resolveElements } from \"motion-dom\"\n\nexport type ViewChangeHandler = (entry: IntersectionObserverEntry) => void\n\ntype MarginValue = `${number}${\"px\" | \"%\"}`\ntype MarginType =\n    | MarginValue\n    | `${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue}`\n    | `${MarginValue} ${MarginValue} ${MarginValue} ${MarginValue}`\n\nexport interface InViewOptions {\n    root?: Element | Document\n    margin?: MarginType\n    amount?: \"some\" | \"all\" | number\n}\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n}\n\nexport function inView(\n    elementOrSelector: ElementOrSelector,\n    onStart: (\n        element: Element,\n        entry: IntersectionObserverEntry\n    ) => void | ViewChangeHandler,\n    { root, margin: rootMargin, amount = \"some\" }: InViewOptions = {}\n): VoidFunction {\n    const elements = resolveElements(elementOrSelector)\n\n    const activeIntersections = new WeakMap<Element, ViewChangeHandler>()\n\n    const onIntersectionChange: IntersectionObserverCallback = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target)\n\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd)) return\n\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry.target, entry)\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd)\n                } else {\n                    observer.unobserve(entry.target)\n                }\n            } else if (typeof onEnd === \"function\") {\n                onEnd(entry)\n                activeIntersections.delete(entry.target)\n            }\n        })\n    }\n\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    })\n\n    elements.forEach((element) => observer.observe(element))\n\n    return () => observer.disconnect()\n}\n"],"mappings":";AAiBA,MAAMA,UAAU,GAAG;EACfC,IAAI,EAAE,CAAC;EACPC,GAAG,EAAE;CACR;SAEeC,MAAMA,CAClBC,iBAAoC,EACpCC,OAG6B,EAC7B;EAAEC,IAAI;EAAEC,MAAM,EAAEC,UAAU;EAAEC,MAAM,GAAG;AAAM,IAAoB,EAAE;EAEjE,MAAMC,QAAQ,GAAGC,eAAe,CAACP,iBAAiB,CAAC;EAEnD,MAAMQ,mBAAmB,GAAG,IAAIC,OAAO,EAA8B;EAErE,MAAMC,oBAAoB,GAAkCC,OAAO,IAAI;IACnEA,OAAO,CAACC,OAAO,CAAEC,KAAK,IAAI;MACtB,MAAMC,KAAK,GAAGN,mBAAmB,CAACO,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC;MAEnD;;;AAGG;MACH,IAAIH,KAAK,CAACI,cAAc,KAAKC,OAAO,CAACJ,KAAK,CAAC,EAAE;MAE7C,IAAID,KAAK,CAACI,cAAc,EAAE;QACtB,MAAME,QAAQ,GAAGlB,OAAO,CAACY,KAAK,CAACG,MAAM,EAAEH,KAAK,CAAC;QAC7C,IAAI,OAAOM,QAAQ,KAAK,UAAU,EAAE;UAChCX,mBAAmB,CAACY,GAAG,CAACP,KAAK,CAACG,MAAM,EAAEG,QAAQ,CAAC;SAClD,MAAM;UACHE,QAAQ,CAACC,SAAS,CAACT,KAAK,CAACG,MAAM,CAAC;;OAEvC,MAAM,IAAI,OAAOF,KAAK,KAAK,UAAU,EAAE;QACpCA,KAAK,CAACD,KAAK,CAAC;QACZL,mBAAmB,CAACe,MAAM,CAACV,KAAK,CAACG,MAAM,CAAC;;IAEhD,CAAC,CAAC;EACN,CAAC;EAED,MAAMK,QAAQ,GAAG,IAAIG,oBAAoB,CAACd,oBAAoB,EAAE;IAC5DR,IAAI;IACJE,UAAU;IACVqB,SAAS,EAAE,OAAOpB,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGT,UAAU,CAACS,MAAM;EACrE,EAAC;EAEFC,QAAQ,CAACM,OAAO,CAAEc,OAAO,IAAKL,QAAQ,CAACM,OAAO,CAACD,OAAO,CAAC,CAAC;EAExD,OAAO,MAAML,QAAQ,CAACO,UAAU,EAAE;AACtC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}