{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType } from 'three';\n\n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */\nfunction createDecodeFunction(config) {\n  return params => {\n    const {\n      sdr,\n      gainMap,\n      renderer\n    } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n      console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n      sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n      console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n      gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = config.createMaterial({\n      ...params,\n      sdr,\n      gainMap\n    });\n    const quadRenderer = config.createQuadRenderer({\n      width: sdr.image.width,\n      height: sdr.image.height,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer,\n      renderTargetOptions: params.renderTargetOptions\n    });\n    return quadRenderer;\n  };\n}\nclass GainMapNotFoundError extends Error {}\nclass XMPMetadataNotFoundError extends Error {}\nconst getXMLValue = (xml, tag, defaultValue) => {\n  // Check for attribute format first: tag=\"value\"\n  const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n  if (attributeMatch) return attributeMatch[1];\n  // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n  const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n  if (tagMatch) {\n    // Check if it contains rdf:li elements\n    const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n    if (liValues && liValues.length === 3) {\n      return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n    }\n    return tagMatch[1].trim();\n  }\n  if (defaultValue !== undefined) return defaultValue;\n  throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = input => {\n  let str;\n  // support node test environment\n  if (typeof TextDecoder !== 'undefined') str = new TextDecoder().decode(input);else str = input.toString();\n  let start = str.indexOf('<x:xmpmeta');\n  while (start !== -1) {\n    const end = str.indexOf('x:xmpmeta>', start);\n    const xmpBlock = str.slice(start, end + 10);\n    try {\n      const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n      const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n      const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n      const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n      const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n      // These are always attributes, so we can use a simpler regex\n      const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n      const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n      const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n      if (!hdrCapacityMaxMatch) throw new Error('Incomplete gainmap metadata');\n      const hdrCapacityMax = hdrCapacityMaxMatch[1];\n      return {\n        gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n        gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n        gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n        offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n        offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n        hdrCapacityMin: parseFloat(hdrCapacityMin),\n        hdrCapacityMax: parseFloat(hdrCapacityMax)\n      };\n    } catch (e) {\n      // Continue searching for another xmpmeta block if this one fails\n    }\n    start = str.indexOf('<x:xmpmeta', end);\n  }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n  options;\n  constructor(options) {\n    this.options = {\n      debug: options && options.debug !== undefined ? options.debug : false,\n      extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n      extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n    };\n  }\n  extract(imageArrayBuffer) {\n    return new Promise((resolve, reject) => {\n      const debug = this.options.debug;\n      const dataView = new DataView(imageArrayBuffer.buffer);\n      // If you're executing this line on a big endian machine, it'll be reversed.\n      // bigEnd further down though, refers to the endianness of the image itself.\n      if (dataView.getUint16(0) !== 0xffd8) {\n        reject(new Error('Not a valid jpeg'));\n        return;\n      }\n      const length = dataView.byteLength;\n      let offset = 2;\n      let loops = 0;\n      let marker; // APP# marker\n      while (offset < length) {\n        if (++loops > 250) {\n          reject(new Error(`Found no marker after ${loops} loops üòµ`));\n          return;\n        }\n        if (dataView.getUint8(offset) !== 0xff) {\n          reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n          return;\n        }\n        marker = dataView.getUint8(offset + 1);\n        if (debug) console.log(`Marker: ${marker.toString(16)}`);\n        if (marker === 0xe2) {\n          if (debug) console.log('Found APP2 marker (0xffe2)');\n          // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n          // Great way to visualize image information in html is using Exiftool. E.g.:\n          // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n          const formatPt = offset + 4;\n          /*\n           *  Structure of the MP Format Identifier\n           *\n           *  Offset Addr.  | Code (Hex)  | Description\n           *  +00             ff            Marker Prefix      <-- offset\n           *  +01             e2            APP2\n           *  +02             #n            APP2 Field Length\n           *  +03             #n            APP2 Field Length\n           *  +04             4d            'M'                <-- formatPt\n           *  +05             50            'P'\n           *  +06             46            'F'\n           *  +07             00            NULL\n           *                                                   <-- tiffOffset\n           */\n          if (dataView.getUint32(formatPt) === 0x4d504600) {\n            // Found MPF tag, so we start dig out sub images\n            const tiffOffset = formatPt + 4;\n            let bigEnd; // Endianness from TIFF header\n            // Test for TIFF validity and endianness\n            // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n            if (dataView.getUint16(tiffOffset) === 0x4949) {\n              bigEnd = false;\n            } else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n              bigEnd = true;\n            } else {\n              reject(new Error('No valid endianness marker found in TIFF header'));\n              return;\n            }\n            if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n              reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n              return;\n            }\n            // 32 bit number stating the offset from the start of the 8 Byte MP Header\n            // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n            const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n            if (firstIFDOffset < 0x00000008) {\n              reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n              return;\n            }\n            // Move ahead to MP Index IFD\n            // Assume we're at the first IFD, so firstIFDOffset points to\n            // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n            // we fail silently here due to this assumption)\n            // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n            const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n            const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n            // Extract info from MPEntries (starting after Count)\n            const entriesStart = dirStart + 2;\n            let numberOfImages = 0;\n            for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n              // Each entry is 12 Bytes long\n              // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n              if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                // stored in Last 4 bytes of its 12 Byte entry.\n                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n              }\n            }\n            const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n            const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n            const images = [];\n            for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n              const image = {\n                MPType: dataView.getUint32(i, !bigEnd),\n                size: dataView.getUint32(i + 4, !bigEnd),\n                // This offset is specified relative to the address of the MP Endian\n                // field in the MP Header, unless the image is a First Individual Image,\n                // in which case the value of the offset shall be NULL (0x00000000).\n                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                start: -1,\n                end: -1,\n                isFII: false\n              };\n              if (!image.dataOffset) {\n                // dataOffset is 0x00000000 for First Individual Image\n                image.start = 0;\n                image.isFII = true;\n              } else {\n                image.start = tiffOffset + image.dataOffset;\n                image.isFII = false;\n              }\n              image.end = image.start + image.size;\n              images.push(image);\n            }\n            if (this.options.extractNonFII && images.length) {\n              const bufferBlob = new Blob([dataView]);\n              const imgs = [];\n              for (const image of images) {\n                if (image.isFII && !this.options.extractFII) {\n                  continue; // Skip FII\n                }\n                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                // we don't need this\n                // const imageUrl = URL.createObjectURL(imageBlob)\n                // image.img = document.createElement('img')\n                // image.img.src = imageUrl\n                imgs.push(imageBlob);\n              }\n              resolve(imgs);\n            }\n          }\n        }\n        offset += 2 + dataView.getUint16(offset + 2);\n      }\n    });\n  }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async jpegFile => {\n  const metadata = extractXMP(jpegFile);\n  if (!metadata) throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n  const mpfExtractor = new MPFExtractor({\n    extractFII: true,\n    extractNonFII: true\n  });\n  const images = await mpfExtractor.extract(jpegFile);\n  if (images.length !== 2) throw new GainMapNotFoundError('Gain map recovery image not found');\n  return {\n    sdr: new Uint8Array(await images[0].arrayBuffer()),\n    gainMap: new Uint8Array(await images[1].arrayBuffer()),\n    metadata\n  };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = blob => {\n  return new Promise((resolve, reject) => {\n    const img = document.createElement('img');\n    img.onload = () => {\n      resolve(img);\n    };\n    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n    img.onerror = e => {\n      reject(e);\n    };\n    img.src = URL.createObjectURL(blob);\n  });\n};\n\n/**\n * Shared base class for loaders that extracts common logic\n */\nclass LoaderBaseShared extends Loader {\n  _renderer;\n  _renderTargetOptions;\n  _internalLoadingManager;\n  _config;\n  constructor(config, manager) {\n    super(manager);\n    this._config = config;\n    if (config.renderer) this._renderer = config.renderer;\n    this._internalLoadingManager = new LoadingManager();\n  }\n  setRenderer(renderer) {\n    this._renderer = renderer;\n    return this;\n  }\n  setRenderTargetOptions(options) {\n    this._renderTargetOptions = options;\n    return this;\n  }\n  prepareQuadRenderer() {\n    if (!this._renderer) {\n      console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n    }\n    const material = this._config.createMaterial({\n      gainMapMax: [1, 1, 1],\n      gainMapMin: [0, 0, 0],\n      gamma: [1, 1, 1],\n      offsetHdr: [1, 1, 1],\n      offsetSdr: [1, 1, 1],\n      hdrCapacityMax: 1,\n      hdrCapacityMin: 0,\n      maxDisplayBoost: 1,\n      gainMap: new Texture(),\n      sdr: new Texture()\n    });\n    return this._config.createQuadRenderer({\n      width: 16,\n      height: 16,\n      type: HalfFloatType,\n      colorSpace: LinearSRGBColorSpace,\n      material,\n      renderer: this._renderer,\n      renderTargetOptions: this._renderTargetOptions\n    });\n  }\n  async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n    const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], {\n      type: 'image/jpeg'\n    }) : undefined;\n    const sdrBlob = new Blob([sdrBuffer], {\n      type: 'image/jpeg'\n    });\n    let sdrImage;\n    let gainMapImage;\n    let needsFlip = false;\n    if (typeof createImageBitmap === 'undefined') {\n      const res = await Promise.all([gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined), getHTMLImageFromBlob(sdrBlob)]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n      needsFlip = imageOrientation === 'flipY';\n    } else {\n      const res = await Promise.all([gainMapBlob ? createImageBitmap(gainMapBlob, {\n        imageOrientation: imageOrientation || 'flipY'\n      }) : Promise.resolve(undefined), createImageBitmap(sdrBlob, {\n        imageOrientation: imageOrientation || 'flipY'\n      })]);\n      gainMapImage = res[0];\n      sdrImage = res[1];\n    }\n    return {\n      sdrImage,\n      gainMapImage,\n      needsFlip\n    };\n  }\n  createTextures(sdrImage, gainMapImage, needsFlip) {\n    const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n    gainMap.flipY = needsFlip;\n    gainMap.needsUpdate = true;\n    const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n    sdr.flipY = needsFlip;\n    sdr.needsUpdate = true;\n    return {\n      gainMap,\n      sdr\n    };\n  }\n  updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n    quadRenderer.width = sdrImage.width;\n    quadRenderer.height = sdrImage.height;\n    quadRenderer.material.gainMap = gainMap;\n    quadRenderer.material.sdr = sdr;\n    quadRenderer.material.gainMapMin = metadata.gainMapMin;\n    quadRenderer.material.gainMapMax = metadata.gainMapMax;\n    quadRenderer.material.offsetHdr = metadata.offsetHdr;\n    quadRenderer.material.offsetSdr = metadata.offsetSdr;\n    quadRenderer.material.gamma = metadata.gamma;\n    quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n    quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n    quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n    quadRenderer.material.needsUpdate = true;\n  }\n}\nexport { GainMapNotFoundError as G, LoaderBaseShared as L, MPFExtractor as M, XMPMetadataNotFoundError as X, extractXMP as a, createDecodeFunction as c, extractGainmapFromJPEG as e };","map":{"version":3,"names":["SRGBColorSpace","LinearSRGBColorSpace","HalfFloatType","Loader","LoadingManager","Texture","UVMapping","ClampToEdgeWrapping","LinearFilter","LinearMipMapLinearFilter","RGBAFormat","UnsignedByteType","createDecodeFunction","config","params","sdr","gainMap","renderer","colorSpace","console","warn","needsUpdate","material","createMaterial","quadRenderer","createQuadRenderer","width","image","height","type","renderTargetOptions","GainMapNotFoundError","Error","XMPMetadataNotFoundError","getXMLValue","xml","tag","defaultValue","attributeMatch","RegExp","exec","tagMatch","liValues","match","length","map","v","replace","trim","undefined","extractXMP","input","str","TextDecoder","decode","toString","start","indexOf","end","xmpBlock","slice","gainMapMin","gainMapMax","gamma","offsetSDR","offsetHDR","hdrCapacityMinMatch","hdrCapacityMin","hdrCapacityMaxMatch","hdrCapacityMax","Array","isArray","parseFloat","offsetSdr","offsetHdr","e","MPFExtractor","options","constructor","debug","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","dataView","DataView","buffer","getUint16","byteLength","offset","loops","marker","getUint8","log","formatPt","getUint32","tiffOffset","bigEnd","firstIFDOffset","dirStart","count","entriesStart","numberOfImages","i","nextIFDOffsetLen","MPImageListValPt","images","MPType","size","dataOffset","dependantImages","isFII","push","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","jpegFile","metadata","mpfExtractor","Uint8Array","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","src","URL","createObjectURL","LoaderBaseShared","_renderer","_renderTargetOptions","_internalLoadingManager","_config","manager","setRenderer","setRenderTargetOptions","prepareQuadRenderer","maxDisplayBoost","processImages","sdrBuffer","gainMapBuffer","imageOrientation","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","createTextures","ImageData","flipY","updateQuadRenderer","Math","pow","G","L","M","X","a","c"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/@react-three/drei/node_modules/@monogrid/gainmap-js/dist/Loader-DLI-_JDP.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.4.0\n * With ‚ù§Ô∏è, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType } from 'three';\n\n/**\n * Shared decode implementation factory\n * Creates a decode function that prepares a QuadRenderer with the given parameters\n */\nfunction createDecodeFunction(config) {\n    return (params) => {\n        const { sdr, gainMap, renderer } = params;\n        if (sdr.colorSpace !== SRGBColorSpace) {\n            console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n            sdr.colorSpace = SRGBColorSpace;\n        }\n        sdr.needsUpdate = true;\n        if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n            console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n            gainMap.colorSpace = LinearSRGBColorSpace;\n        }\n        gainMap.needsUpdate = true;\n        const material = config.createMaterial({\n            ...params,\n            sdr,\n            gainMap\n        });\n        const quadRenderer = config.createQuadRenderer({\n            width: sdr.image.width,\n            height: sdr.image.height,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer,\n            renderTargetOptions: params.renderTargetOptions\n        });\n        return quadRenderer;\n    };\n}\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getXMLValue = (xml, tag, defaultValue) => {\n    // Check for attribute format first: tag=\"value\"\n    const attributeMatch = new RegExp(`${tag}=\"([^\"]*)\"`, 'i').exec(xml);\n    if (attributeMatch)\n        return attributeMatch[1];\n    // Check for tag format: <tag>value</tag> or <tag><rdf:li>value</rdf:li>...</tag>\n    const tagMatch = new RegExp(`<${tag}[^>]*>([\\\\s\\\\S]*?)</${tag}>`, 'i').exec(xml);\n    if (tagMatch) {\n        // Check if it contains rdf:li elements\n        const liValues = tagMatch[1].match(/<rdf:li>([^<]*)<\\/rdf:li>/g);\n        if (liValues && liValues.length === 3) {\n            return liValues.map(v => v.replace(/<\\/?rdf:li>/g, ''));\n        }\n        return tagMatch[1].trim();\n    }\n    if (defaultValue !== undefined)\n        return defaultValue;\n    throw new Error(`Can't find ${tag} in gainmap metadata`);\n};\nconst extractXMP = (input) => {\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const gainMapMin = getXMLValue(xmpBlock, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getXMLValue(xmpBlock, 'hdrgm:GainMapMax');\n            const gamma = getXMLValue(xmpBlock, 'hdrgm:Gamma', '1');\n            const offsetSDR = getXMLValue(xmpBlock, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getXMLValue(xmpBlock, 'hdrgm:OffsetHDR', '0.015625');\n            // These are always attributes, so we can use a simpler regex\n            const hdrCapacityMinMatch = /hdrgm:HDRCapacityMin=\"([^\"]*)\"/.exec(xmpBlock);\n            const hdrCapacityMin = hdrCapacityMinMatch ? hdrCapacityMinMatch[1] : '0';\n            const hdrCapacityMaxMatch = /hdrgm:HDRCapacityMax=\"([^\"]*)\"/.exec(xmpBlock);\n            if (!hdrCapacityMaxMatch)\n                throw new Error('Incomplete gainmap metadata');\n            const hdrCapacityMax = hdrCapacityMaxMatch[1];\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n            // Continue searching for another xmpmeta block if this one fails\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    options;\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops üòµ`));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\n/**\n * Shared base class for loaders that extracts common logic\n */\nclass LoaderBaseShared extends Loader {\n    _renderer;\n    _renderTargetOptions;\n    _internalLoadingManager;\n    _config;\n    constructor(config, manager) {\n        super(manager);\n        this._config = config;\n        if (config.renderer)\n            this._renderer = config.renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    prepareQuadRenderer() {\n        if (!this._renderer) {\n            console.warn('WARNING: A Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        }\n        const material = this._config.createMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return this._config.createQuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    async processImages(sdrBuffer, gainMapBuffer, imageOrientation) {\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = imageOrientation === 'flipY';\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: imageOrientation || 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: imageOrientation || 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        return { sdrImage, gainMapImage, needsFlip };\n    }\n    createTextures(sdrImage, gainMapImage, needsFlip) {\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        return { gainMap, sdr };\n    }\n    updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata) {\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n    }\n}\n\nexport { GainMapNotFoundError as G, LoaderBaseShared as L, MPFExtractor as M, XMPMetadataNotFoundError as X, extractXMP as a, createDecodeFunction as c, extractGainmapFromJPEG as e };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}