{"ast":null,"code":"import { pipe, warning } from 'motion-utils';\nimport { isCSSVariableToken } from '../../animation/utils/is-css-variable.mjs';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { mixColor } from './color.mjs';\nimport { mixImmediate } from './immediate.mjs';\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nfunction mixNumber(a, b) {\n  return p => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n  return mixImmediate;\n}\nfunction mixArray(a, b) {\n  const output = [...a];\n  const numValues = output.length;\n  const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n  return p => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n    return output;\n  };\n}\nfunction mixObject(a, b) {\n  const output = {\n    ...a,\n    ...b\n  };\n  const blendValue = {};\n  for (const key in output) {\n    if (a[key] !== undefined && b[key] !== undefined) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n    return output;\n  };\n}\nfunction matchOrder(origin, target) {\n  const orderedOrigin = [];\n  const pointers = {\n    color: 0,\n    var: 0,\n    number: 0\n  };\n  for (let i = 0; i < target.values.length; i++) {\n    const type = target.types[i];\n    const originIndex = origin.indexes[type][pointers[type]];\n    const originValue = origin.values[originIndex] ?? 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n  return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n  const template = complex.createTransformer(target);\n  const originStats = analyseComplexValue(origin);\n  const targetStats = analyseComplexValue(target);\n  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n  if (canInterpolate) {\n    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n      return mixVisibility(origin, target);\n    }\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, \"complex-values-different\");\n    return mixImmediate(origin, target);\n  }\n};\nexport { getMixer, mixArray, mixComplex, mixObject };","map":{"version":3,"names":["mixNumber","a","b","p","mixNumber$1","getMixer","isCSSVariableToken","mixImmediate","color","test","mixColor","mixComplex","Array","isArray","mixArray","mixObject","output","numValues","length","blendValue","map","v","i","key","undefined","matchOrder","origin","target","orderedOrigin","pointers","var","number","values","type","types","originIndex","indexes","originValue","template","complex","createTransformer","originStats","analyseComplexValue","targetStats","canInterpolate","invisibleValues","has","mixVisibility","pipe","warning"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/utils/mix/complex.ts"],"sourcesContent":["import { pipe, warning } from \"motion-utils\"\nimport { AnyResolvedKeyframe } from \"../../animation/types\"\nimport { isCSSVariableToken } from \"../../animation/utils/is-css-variable\"\nimport { color } from \"../../value/types/color\"\nimport {\n    analyseComplexValue,\n    complex,\n    ComplexValueInfo,\n    ComplexValues,\n} from \"../../value/types/complex\"\nimport { HSLA, RGBA } from \"../../value/types/types\"\nimport { mixColor } from \"./color\"\nimport { mixImmediate } from \"./immediate\"\nimport { mixNumber as mixNumberImmediate } from \"./number\"\nimport { invisibleValues, mixVisibility } from \"./visibility\"\n\ntype MixableArray = Array<number | RGBA | HSLA | string>\ninterface MixableObject {\n    [key: string]: AnyResolvedKeyframe | RGBA | HSLA\n}\n\nfunction mixNumber(a: number, b: number) {\n    return (p: number) => mixNumberImmediate(a, b, p)\n}\n\nexport function getMixer<T>(a: T) {\n    if (typeof a === \"number\") {\n        return mixNumber\n    } else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n            ? mixColor\n            : mixComplex\n    } else if (Array.isArray(a)) {\n        return mixArray\n    } else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject\n    }\n\n    return mixImmediate\n}\n\nexport function mixArray(a: MixableArray, b: MixableArray) {\n    const output = [...a]\n    const numValues = output.length\n\n    const blendValue = a.map((v, i) => getMixer(v)(v as any, b[i] as any))\n\n    return (p: number) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p) as any\n        }\n        return output\n    }\n}\n\nexport function mixObject(a: MixableObject, b: MixableObject) {\n    const output = { ...a, ...b }\n    const blendValue: { [key: string]: (v: number) => any } = {}\n\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(\n                a[key] as any,\n                b[key] as any\n            ) as any\n        }\n    }\n\n    return (v: number) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v)\n        }\n        return output\n    }\n}\n\nfunction matchOrder(\n    origin: ComplexValueInfo,\n    target: ComplexValueInfo\n): ComplexValues {\n    const orderedOrigin: ComplexValues = []\n\n    const pointers = { color: 0, var: 0, number: 0 }\n\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i]\n        const originIndex = origin.indexes[type][pointers[type]]\n        const originValue = origin.values[originIndex] ?? 0\n\n        orderedOrigin[i] = originValue\n\n        pointers[type]++\n    }\n\n    return orderedOrigin\n}\n\nexport const mixComplex = (\n    origin: AnyResolvedKeyframe,\n    target: AnyResolvedKeyframe\n) => {\n    const template = complex.createTransformer(target)\n    const originStats = analyseComplexValue(origin)\n    const targetStats = analyseComplexValue(target)\n    const canInterpolate =\n        originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length\n\n    if (canInterpolate) {\n        if (\n            (invisibleValues.has(origin as string) &&\n                !targetStats.values.length) ||\n            (invisibleValues.has(target as string) &&\n                !originStats.values.length)\n        ) {\n            return mixVisibility(origin as string, target as string)\n        }\n\n        return pipe(\n            mixArray(matchOrder(originStats, targetStats), targetStats.values),\n            template\n        )\n    } else {\n        warning(\n            true,\n            `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,\n            \"complex-values-different\"\n        )\n\n        return mixImmediate(origin, target)\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}