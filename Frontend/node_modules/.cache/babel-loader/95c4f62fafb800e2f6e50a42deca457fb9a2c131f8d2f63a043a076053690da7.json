{"ast":null,"code":"const threshold = 50;\nconst maxSpeed = 25;\nconst overflowStyles = new Set([\"auto\", \"scroll\"]);\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap();\nconst activeScrollEdge = new WeakMap();\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement = null;\nfunction resetAutoScrollState() {\n  if (currentGroupElement) {\n    const scrollableAncestor = findScrollableAncestor(currentGroupElement, \"y\");\n    if (scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestor);\n      initialScrollLimits.delete(scrollableAncestor);\n    }\n    // Also try x axis\n    const scrollableAncestorX = findScrollableAncestor(currentGroupElement, \"x\");\n    if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n      activeScrollEdge.delete(scrollableAncestorX);\n      initialScrollLimits.delete(scrollableAncestorX);\n    }\n    currentGroupElement = null;\n  }\n}\nfunction isScrollableElement(element, axis) {\n  const style = getComputedStyle(element);\n  const overflow = axis === \"x\" ? style.overflowX : style.overflowY;\n  const isDocumentScroll = element === document.body || element === document.documentElement;\n  return overflowStyles.has(overflow) || isDocumentScroll;\n}\nfunction findScrollableAncestor(element, axis) {\n  let current = element?.parentElement;\n  while (current) {\n    if (isScrollableElement(current, axis)) {\n      return current;\n    }\n    current = current.parentElement;\n  }\n  return null;\n}\nfunction getScrollAmount(pointerPosition, scrollElement, axis) {\n  const rect = scrollElement.getBoundingClientRect();\n  const start = axis === \"x\" ? Math.max(0, rect.left) : Math.max(0, rect.top);\n  const end = axis === \"x\" ? Math.min(window.innerWidth, rect.right) : Math.min(window.innerHeight, rect.bottom);\n  const distanceFromStart = pointerPosition - start;\n  const distanceFromEnd = end - pointerPosition;\n  if (distanceFromStart < threshold) {\n    const intensity = 1 - distanceFromStart / threshold;\n    return {\n      amount: -maxSpeed * intensity * intensity,\n      edge: \"start\"\n    };\n  } else if (distanceFromEnd < threshold) {\n    const intensity = 1 - distanceFromEnd / threshold;\n    return {\n      amount: maxSpeed * intensity * intensity,\n      edge: \"end\"\n    };\n  }\n  return {\n    amount: 0,\n    edge: null\n  };\n}\nfunction autoScrollIfNeeded(groupElement, pointerPosition, axis, velocity) {\n  if (!groupElement) return;\n  // Track the group element for cleanup\n  currentGroupElement = groupElement;\n  const scrollableAncestor = findScrollableAncestor(groupElement, axis);\n  if (!scrollableAncestor) return;\n  // Convert pointer position from page coordinates to viewport coordinates.\n  // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n  // viewport-relative coordinates, so we need to account for page scroll.\n  const viewportPointerPosition = pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY);\n  const {\n    amount: scrollAmount,\n    edge\n  } = getScrollAmount(viewportPointerPosition, scrollableAncestor, axis);\n  // If not in any threshold zone, clear all state\n  if (edge === null) {\n    activeScrollEdge.delete(scrollableAncestor);\n    initialScrollLimits.delete(scrollableAncestor);\n    return;\n  }\n  const currentActiveEdge = activeScrollEdge.get(scrollableAncestor);\n  const isDocumentScroll = scrollableAncestor === document.body || scrollableAncestor === document.documentElement;\n  // If not currently scrolling this edge, check velocity to see if we should start\n  if (currentActiveEdge !== edge) {\n    // Only start scrolling if velocity is towards the edge\n    const shouldStart = edge === \"start\" && velocity < 0 || edge === \"end\" && velocity > 0;\n    if (!shouldStart) return;\n    // Activate this edge\n    activeScrollEdge.set(scrollableAncestor, edge);\n    // Record initial scroll limit (prevents infinite scroll)\n    const maxScroll = axis === \"x\" ? scrollableAncestor.scrollWidth - (isDocumentScroll ? window.innerWidth : scrollableAncestor.clientWidth) : scrollableAncestor.scrollHeight - (isDocumentScroll ? window.innerHeight : scrollableAncestor.clientHeight);\n    initialScrollLimits.set(scrollableAncestor, maxScroll);\n  }\n  // Cap scrolling at initial limit (prevents infinite scroll)\n  if (scrollAmount > 0) {\n    const initialLimit = initialScrollLimits.get(scrollableAncestor);\n    const currentScroll = axis === \"x\" ? isDocumentScroll ? window.scrollX : scrollableAncestor.scrollLeft : isDocumentScroll ? window.scrollY : scrollableAncestor.scrollTop;\n    if (currentScroll >= initialLimit) return;\n  }\n  // Apply scroll\n  if (axis === \"x\") {\n    if (isDocumentScroll) {\n      window.scrollBy({\n        left: scrollAmount\n      });\n    } else {\n      scrollableAncestor.scrollLeft += scrollAmount;\n    }\n  } else {\n    if (isDocumentScroll) {\n      window.scrollBy({\n        top: scrollAmount\n      });\n    } else {\n      scrollableAncestor.scrollTop += scrollAmount;\n    }\n  }\n}\nexport { autoScrollIfNeeded, resetAutoScrollState };","map":{"version":3,"names":["threshold","maxSpeed","overflowStyles","Set","initialScrollLimits","WeakMap","activeScrollEdge","currentGroupElement","resetAutoScrollState","scrollableAncestor","findScrollableAncestor","delete","scrollableAncestorX","isScrollableElement","element","axis","style","getComputedStyle","overflow","overflowX","overflowY","isDocumentScroll","document","body","documentElement","has","current","parentElement","getScrollAmount","pointerPosition","scrollElement","rect","getBoundingClientRect","start","Math","max","left","top","end","min","window","innerWidth","right","innerHeight","bottom","distanceFromStart","distanceFromEnd","intensity","amount","edge","autoScrollIfNeeded","groupElement","velocity","viewportPointerPosition","scrollX","scrollY","scrollAmount","currentActiveEdge","get","shouldStart","set","maxScroll","scrollWidth","clientWidth","scrollHeight","clientHeight","initialLimit","currentScroll","scrollLeft","scrollTop","scrollBy"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/components/Reorder/utils/auto-scroll.ts"],"sourcesContent":["const threshold = 50\nconst maxSpeed = 25\n\nconst overflowStyles = new Set([\"auto\", \"scroll\"])\n\n// Track initial scroll limits per scrollable element (Bug 1 fix)\nconst initialScrollLimits = new WeakMap<HTMLElement, number>()\n\n// Track auto-scroll active state per edge: \"start\" (top/left) or \"end\" (bottom/right)\ntype ActiveEdge = \"start\" | \"end\" | null\nconst activeScrollEdge = new WeakMap<HTMLElement, ActiveEdge>()\n\n// Track which group element is currently dragging to clear state on end\nlet currentGroupElement: Element | null = null\n\nexport function resetAutoScrollState(): void {\n    if (currentGroupElement) {\n        const scrollableAncestor = findScrollableAncestor(\n            currentGroupElement,\n            \"y\"\n        )\n        if (scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestor)\n            initialScrollLimits.delete(scrollableAncestor)\n        }\n        // Also try x axis\n        const scrollableAncestorX = findScrollableAncestor(\n            currentGroupElement,\n            \"x\"\n        )\n        if (scrollableAncestorX && scrollableAncestorX !== scrollableAncestor) {\n            activeScrollEdge.delete(scrollableAncestorX)\n            initialScrollLimits.delete(scrollableAncestorX)\n        }\n        currentGroupElement = null\n    }\n}\n\nfunction isScrollableElement(element: Element, axis: \"x\" | \"y\"): boolean {\n    const style = getComputedStyle(element)\n    const overflow = axis === \"x\" ? style.overflowX : style.overflowY\n\n    const isDocumentScroll =\n        element === document.body ||\n        element === document.documentElement\n\n    return overflowStyles.has(overflow) || isDocumentScroll\n}\n\nfunction findScrollableAncestor(\n    element: Element | null,\n    axis: \"x\" | \"y\"\n): HTMLElement | null {\n    let current = element?.parentElement\n    while (current) {\n        if (isScrollableElement(current, axis)) {\n            return current\n        }\n        current = current.parentElement\n    }\n    return null\n}\n\nfunction getScrollAmount(\n    pointerPosition: number,\n    scrollElement: HTMLElement,\n    axis: \"x\" | \"y\"\n): { amount: number; edge: ActiveEdge } {\n    const rect = scrollElement.getBoundingClientRect()\n\n    const start = axis === \"x\" ? Math.max(0, rect.left) : Math.max(0, rect.top)\n    const end = axis === \"x\" ? Math.min(window.innerWidth, rect.right) : Math.min(window.innerHeight, rect.bottom)\n\n    const distanceFromStart = pointerPosition - start\n    const distanceFromEnd = end - pointerPosition\n\n    if (distanceFromStart < threshold) {\n        const intensity = 1 - distanceFromStart / threshold\n        return { amount: -maxSpeed * intensity * intensity, edge: \"start\" }\n    } else if (distanceFromEnd < threshold) {\n        const intensity = 1 - distanceFromEnd / threshold\n        return { amount: maxSpeed * intensity * intensity, edge: \"end\" }\n    }\n\n    return { amount: 0, edge: null }\n}\n\nexport function autoScrollIfNeeded(\n    groupElement: Element | null,\n    pointerPosition: number,\n    axis: \"x\" | \"y\",\n    velocity: number\n): void {\n    if (!groupElement) return\n\n    // Track the group element for cleanup\n    currentGroupElement = groupElement\n\n    const scrollableAncestor = findScrollableAncestor(groupElement, axis)\n    if (!scrollableAncestor) return\n\n    // Convert pointer position from page coordinates to viewport coordinates.\n    // The gesture system uses pageX/pageY but getBoundingClientRect() returns\n    // viewport-relative coordinates, so we need to account for page scroll.\n    const viewportPointerPosition =\n        pointerPosition - (axis === \"x\" ? window.scrollX : window.scrollY)\n\n    const { amount: scrollAmount, edge } = getScrollAmount(\n        viewportPointerPosition,\n        scrollableAncestor,\n        axis\n    )\n\n    // If not in any threshold zone, clear all state\n    if (edge === null) {\n        activeScrollEdge.delete(scrollableAncestor)\n        initialScrollLimits.delete(scrollableAncestor)\n        return\n    }\n\n    const currentActiveEdge = activeScrollEdge.get(scrollableAncestor)\n\n    const isDocumentScroll =\n        scrollableAncestor === document.body ||\n        scrollableAncestor === document.documentElement\n\n    // If not currently scrolling this edge, check velocity to see if we should start\n    if (currentActiveEdge !== edge) {\n        // Only start scrolling if velocity is towards the edge\n        const shouldStart =\n            (edge === \"start\" && velocity < 0) ||\n            (edge === \"end\" && velocity > 0)\n        if (!shouldStart) return\n\n        // Activate this edge\n        activeScrollEdge.set(scrollableAncestor, edge)\n\n        // Record initial scroll limit (prevents infinite scroll)\n        const maxScroll =\n            axis === \"x\"\n                ? scrollableAncestor.scrollWidth - (isDocumentScroll ? window.innerWidth : scrollableAncestor.clientWidth)\n                : scrollableAncestor.scrollHeight - (isDocumentScroll ? window.innerHeight : scrollableAncestor.clientHeight)\n\n        initialScrollLimits.set(scrollableAncestor, maxScroll)\n    }\n\n    // Cap scrolling at initial limit (prevents infinite scroll)\n    if (scrollAmount > 0) {\n        const initialLimit = initialScrollLimits.get(scrollableAncestor)!\n        const currentScroll =\n            axis === \"x\"\n                ? (isDocumentScroll ? window.scrollX : scrollableAncestor.scrollLeft)\n                : (isDocumentScroll ? window.scrollY : scrollableAncestor.scrollTop)\n        if (currentScroll >= initialLimit) return\n    }\n\n    // Apply scroll\n    if (axis === \"x\") {\n        if (isDocumentScroll) {\n            window.scrollBy({ left: scrollAmount })\n        } else {\n            scrollableAncestor.scrollLeft += scrollAmount\n        }\n    } else {\n        if (isDocumentScroll) {\n            window.scrollBy({ top: scrollAmount })\n        } else {\n            scrollableAncestor.scrollTop += scrollAmount\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}