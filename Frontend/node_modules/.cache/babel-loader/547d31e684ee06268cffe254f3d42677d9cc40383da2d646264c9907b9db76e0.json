{"ast":null,"code":"import { resolveElements, getValueTransition, getAnimationMap, animationMapKey, getComputedStyle, fillWildcards, applyPxDefaults, NativeAnimation } from 'motion-dom';\nimport { invariant, secondsToMilliseconds } from 'motion-utils';\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n  // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n  if (elementOrSelector == null) {\n    return [];\n  }\n  const elements = resolveElements(elementOrSelector, scope);\n  const numElements = elements.length;\n  invariant(Boolean(numElements), \"No valid elements provided.\", \"no-valid-elements\");\n  /**\n   * WAAPI doesn't support interrupting animations.\n   *\n   * Therefore, starting animations requires a three-step process:\n   * 1. Stop existing animations (write styles to DOM)\n   * 2. Resolve keyframes (read styles from DOM)\n   * 3. Create new animations (write styles to DOM)\n   *\n   * The hybrid `animate()` function uses AsyncAnimation to resolve\n   * keyframes before creating new animations, which removes style\n   * thrashing. Here, we have much stricter filesize constraints.\n   * Therefore we do this in a synchronous way that ensures that\n   * at least within `animate()` calls there is no style thrashing.\n   *\n   * In the motion-native-animate-mini-interrupt benchmark this\n   * was 80% faster than a single loop.\n   */\n  const animationDefinitions = [];\n  /**\n   * Step 1: Build options and stop existing animations (write)\n   */\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n    const elementTransition = {\n      ...options\n    };\n    /**\n     * Resolve stagger function if provided.\n     */\n    if (typeof elementTransition.delay === \"function\") {\n      elementTransition.delay = elementTransition.delay(i, numElements);\n    }\n    for (const valueName in keyframes) {\n      let valueKeyframes = keyframes[valueName];\n      if (!Array.isArray(valueKeyframes)) {\n        valueKeyframes = [valueKeyframes];\n      }\n      const valueOptions = {\n        ...getValueTransition(elementTransition, valueName)\n      };\n      valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));\n      valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));\n      /**\n       * If there's an existing animation playing on this element then stop it\n       * before creating a new one.\n       */\n      const map = getAnimationMap(element);\n      const key = animationMapKey(valueName, valueOptions.pseudoElement || \"\");\n      const currentAnimation = map.get(key);\n      currentAnimation && currentAnimation.stop();\n      animationDefinitions.push({\n        map,\n        key,\n        unresolvedKeyframes: valueKeyframes,\n        options: {\n          ...valueOptions,\n          element,\n          name: valueName,\n          allowFlatten: !elementTransition.type && !elementTransition.ease\n        }\n      });\n    }\n  }\n  /**\n   * Step 2: Resolve keyframes (read)\n   */\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      unresolvedKeyframes,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const {\n      element,\n      name,\n      pseudoElement\n    } = animationOptions;\n    if (!pseudoElement && unresolvedKeyframes[0] === null) {\n      unresolvedKeyframes[0] = getComputedStyle(element, name);\n    }\n    fillWildcards(unresolvedKeyframes);\n    applyPxDefaults(unresolvedKeyframes, name);\n    /**\n     * If we only have one keyframe, explicitly read the initial keyframe\n     * from the computed style. This is to ensure consistency with WAAPI behaviour\n     * for restarting animations, for instance .play() after finish, when it\n     * has one vs two keyframes.\n     */\n    if (!pseudoElement && unresolvedKeyframes.length < 2) {\n      unresolvedKeyframes.unshift(getComputedStyle(element, name));\n    }\n    animationOptions.keyframes = unresolvedKeyframes;\n  }\n  /**\n   * Step 3: Create new animations (write)\n   */\n  const animations = [];\n  for (let i = 0; i < animationDefinitions.length; i++) {\n    const {\n      map,\n      key,\n      options: animationOptions\n    } = animationDefinitions[i];\n    const animation = new NativeAnimation(animationOptions);\n    map.set(key, animation);\n    animation.finished.finally(() => map.delete(key));\n    animations.push(animation);\n  }\n  return animations;\n}\nexport { animateElements };","map":{"version":3,"names":["animateElements","elementOrSelector","keyframes","options","scope","elements","resolveElements","numElements","length","invariant","Boolean","animationDefinitions","i","element","elementTransition","delay","valueName","valueKeyframes","Array","isArray","valueOptions","getValueTransition","duration","secondsToMilliseconds","map","getAnimationMap","key","animationMapKey","pseudoElement","currentAnimation","get","stop","push","unresolvedKeyframes","name","allowFlatten","type","ease","animationOptions","getComputedStyle","fillWildcards","applyPxDefaults","unshift","animations","animation","NativeAnimation","set","finished","finally","delete"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/animation/animators/waapi/animate-elements.ts"],"sourcesContent":["import {\n    animationMapKey,\n    AnimationPlaybackControls,\n    AnimationScope,\n    applyPxDefaults,\n    DOMKeyframesDefinition,\n    AnimationOptions as DynamicAnimationOptions,\n    ElementOrSelector,\n    fillWildcards,\n    getAnimationMap,\n    getComputedStyle,\n    getValueTransition,\n    NativeAnimation,\n    NativeAnimationOptions,\n    resolveElements,\n    UnresolvedValueKeyframe,\n    ValueKeyframe,\n} from \"motion-dom\"\nimport { invariant, secondsToMilliseconds } from \"motion-utils\"\n\ninterface AnimationDefinition {\n    map: Map<string, NativeAnimation<any>>\n    key: string\n    unresolvedKeyframes: UnresolvedValueKeyframe[]\n    options: Omit<NativeAnimationOptions, \"keyframes\"> & {\n        keyframes?: ValueKeyframe[]\n    }\n}\n\nexport function animateElements(\n    elementOrSelector: ElementOrSelector,\n    keyframes: DOMKeyframesDefinition,\n    options?: DynamicAnimationOptions,\n    scope?: AnimationScope\n) {\n    // Gracefully handle null/undefined elements (e.g., from querySelector returning null)\n    if (elementOrSelector == null) {\n        return []\n    }\n\n    const elements = resolveElements(elementOrSelector, scope) as Array<\n        HTMLElement | SVGElement\n    >\n    const numElements = elements.length\n\n    invariant(\n        Boolean(numElements),\n        \"No valid elements provided.\",\n        \"no-valid-elements\"\n    )\n\n    /**\n     * WAAPI doesn't support interrupting animations.\n     *\n     * Therefore, starting animations requires a three-step process:\n     * 1. Stop existing animations (write styles to DOM)\n     * 2. Resolve keyframes (read styles from DOM)\n     * 3. Create new animations (write styles to DOM)\n     *\n     * The hybrid `animate()` function uses AsyncAnimation to resolve\n     * keyframes before creating new animations, which removes style\n     * thrashing. Here, we have much stricter filesize constraints.\n     * Therefore we do this in a synchronous way that ensures that\n     * at least within `animate()` calls there is no style thrashing.\n     *\n     * In the motion-native-animate-mini-interrupt benchmark this\n     * was 80% faster than a single loop.\n     */\n    const animationDefinitions: AnimationDefinition[] = []\n\n    /**\n     * Step 1: Build options and stop existing animations (write)\n     */\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i]\n        const elementTransition: DynamicAnimationOptions = { ...options }\n\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof elementTransition.delay === \"function\") {\n            elementTransition.delay = elementTransition.delay(i, numElements)\n        }\n\n        for (const valueName in keyframes) {\n            let valueKeyframes = keyframes[valueName as keyof typeof keyframes]!\n\n            if (!Array.isArray(valueKeyframes)) {\n                valueKeyframes = [valueKeyframes]\n            }\n\n            const valueOptions = {\n                ...getValueTransition(elementTransition as any, valueName),\n            }\n\n            valueOptions.duration &&= secondsToMilliseconds(\n                valueOptions.duration\n            )\n\n            valueOptions.delay &&= secondsToMilliseconds(valueOptions.delay)\n\n            /**\n             * If there's an existing animation playing on this element then stop it\n             * before creating a new one.\n             */\n            const map = getAnimationMap(element)\n            const key = animationMapKey(\n                valueName,\n                valueOptions.pseudoElement || \"\"\n            )\n            const currentAnimation = map.get(key)\n            currentAnimation && currentAnimation.stop()\n\n            animationDefinitions.push({\n                map,\n                key,\n                unresolvedKeyframes: valueKeyframes,\n                options: {\n                    ...valueOptions,\n                    element,\n                    name: valueName,\n                    allowFlatten:\n                        !elementTransition.type && !elementTransition.ease,\n                },\n            })\n        }\n    }\n\n    /**\n     * Step 2: Resolve keyframes (read)\n     */\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { unresolvedKeyframes, options: animationOptions } =\n            animationDefinitions[i]\n\n        const { element, name, pseudoElement } = animationOptions\n        if (!pseudoElement && unresolvedKeyframes[0] === null) {\n            unresolvedKeyframes[0] = getComputedStyle(element, name)\n        }\n\n        fillWildcards(unresolvedKeyframes)\n        applyPxDefaults(unresolvedKeyframes, name)\n\n        /**\n         * If we only have one keyframe, explicitly read the initial keyframe\n         * from the computed style. This is to ensure consistency with WAAPI behaviour\n         * for restarting animations, for instance .play() after finish, when it\n         * has one vs two keyframes.\n         */\n        if (!pseudoElement && unresolvedKeyframes.length < 2) {\n            unresolvedKeyframes.unshift(getComputedStyle(element, name))\n        }\n\n        animationOptions.keyframes = unresolvedKeyframes as ValueKeyframe[]\n    }\n\n    /**\n     * Step 3: Create new animations (write)\n     */\n    const animations: AnimationPlaybackControls[] = []\n    for (let i = 0; i < animationDefinitions.length; i++) {\n        const { map, key, options: animationOptions } = animationDefinitions[i]\n        const animation = new NativeAnimation(\n            animationOptions as NativeAnimationOptions\n        )\n\n        map.set(key, animation)\n        animation.finished.finally(() => map.delete(key))\n\n        animations.push(animation)\n    }\n\n    return animations\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}