{"ast":null,"code":"import { resolveEdge, namedEdges } from './edge.mjs';\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n  if (typeof offset === \"number\") {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (typeof offset === \"string\") {\n    offset = offset.trim();\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n    }\n  }\n  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\nexport { resolveOffset };","map":{"version":3,"names":["defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","trim","includes","split","namedEdges","resolveEdge"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/render/dom/scroll/offsets/offset.ts"],"sourcesContent":["import { Edge, EdgeString, Intersection, ProgressIntersection } from \"../types\"\nimport { namedEdges, resolveEdge } from \"./edge\"\n\nconst defaultOffset: ProgressIntersection = [0, 0]\n\nexport function resolveOffset(\n    offset: Edge | Intersection | ProgressIntersection,\n    containerLength: number,\n    targetLength: number,\n    targetInset: number\n) {\n    let offsetDefinition: ProgressIntersection | [EdgeString, EdgeString] =\n        Array.isArray(offset) ? offset : defaultOffset\n\n    let targetPoint = 0\n    let containerPoint = 0\n\n    if (typeof offset === \"number\") {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset]\n    } else if (typeof offset === \"string\") {\n        offset = offset.trim() as EdgeString\n\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \") as [EdgeString, EdgeString]\n        } else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset as keyof typeof namedEdges] ? offset : `0`]\n        }\n    }\n\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset)\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength)\n\n    return targetPoint - containerPoint\n}\n"],"mappings":";AAGA,MAAMA,aAAa,GAAyB,CAAC,CAAC,EAAE,CAAC,CAAC;AAE5C,SAAUC,aAAaA,CACzBC,MAAkD,EAClDC,eAAuB,EACvBC,YAAoB,EACpBC,WAAmB;EAEnB,IAAIC,gBAAgB,GAChBC,KAAK,CAACC,OAAO,CAACN,MAAM,CAAC,GAAGA,MAAM,GAAGF,aAAa;EAElD,IAAIS,WAAW,GAAG,CAAC;EACnB,IAAIC,cAAc,GAAG,CAAC;EAEtB,IAAI,OAAOR,MAAM,KAAK,QAAQ,EAAE;IAC5B;;;;AAIG;IACHI,gBAAgB,GAAG,CAACJ,MAAM,EAAEA,MAAM,CAAC;GACtC,MAAM,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACnCA,MAAM,GAAGA,MAAM,CAACS,IAAI,EAAgB;IAEpC,IAAIT,MAAM,CAACU,QAAQ,CAAC,GAAG,CAAC,EAAE;MACtBN,gBAAgB,GAAGJ,MAAM,CAACW,KAAK,CAAC,GAAG,CAA6B;KACnE,MAAM;MACH;;;;AAIG;MACHP,gBAAgB,GAAG,CAACJ,MAAM,EAAEY,UAAU,CAACZ,MAAiC,CAAC,GAAGA,MAAM,GAAG,GAAG,CAAC;;;EAIjGO,WAAW,GAAGM,WAAW,CAACT,gBAAgB,CAAC,CAAC,CAAC,EAAEF,YAAY,EAAEC,WAAW,CAAC;EACzEK,cAAc,GAAGK,WAAW,CAACT,gBAAgB,CAAC,CAAC,CAAC,EAAEH,eAAe,CAAC;EAElE,OAAOM,WAAW,GAAGC,cAAc;AACvC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}