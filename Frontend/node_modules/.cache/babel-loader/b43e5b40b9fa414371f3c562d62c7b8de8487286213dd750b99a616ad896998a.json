{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { isHTMLElement } from 'motion-dom';\nimport * as React from 'react';\nimport { useId, useRef, useContext, useInsertionEffect } from 'react';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { useComposedRefs } from '../../utils/use-composed-ref.mjs';\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component {\n  getSnapshotBeforeUpdate(prevProps) {\n    const element = this.props.childRef.current;\n    if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n      const parent = element.offsetParent;\n      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;\n      const parentHeight = isHTMLElement(parent) ? parent.offsetHeight || 0 : 0;\n      const size = this.props.sizeRef.current;\n      size.height = element.offsetHeight || 0;\n      size.width = element.offsetWidth || 0;\n      size.top = element.offsetTop;\n      size.left = element.offsetLeft;\n      size.right = parentWidth - size.width - size.left;\n      size.bottom = parentHeight - size.height - size.top;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {}\n  render() {\n    return this.props.children;\n  }\n}\nfunction PopChild({\n  children,\n  isPresent,\n  anchorX,\n  anchorY,\n  root,\n  pop\n}) {\n  const id = useId();\n  const ref = useRef(null);\n  const size = useRef({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  });\n  const {\n    nonce\n  } = useContext(MotionConfigContext);\n  /**\n   * In React 19, refs are passed via props.ref instead of element.ref.\n   * We check props.ref first (React 19) and fall back to element.ref (React 18).\n   */\n  const childRef = children.props?.ref ?? children?.ref;\n  const composedRef = useComposedRefs(ref, childRef);\n  /**\n   * We create and inject a style block so we can apply this explicit\n   * sizing in a non-destructive manner by just deleting the style block.\n   *\n   * We can't apply size via render as the measurement happens\n   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n   * styles directly on the DOM node, we might be overwriting\n   * styles set via the style prop.\n   */\n  useInsertionEffect(() => {\n    const {\n      width,\n      height,\n      top,\n      left,\n      right,\n      bottom\n    } = size.current;\n    if (isPresent || pop === false || !ref.current || !width || !height) return;\n    const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`;\n    const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`;\n    ref.current.dataset.motionPopId = id;\n    const style = document.createElement(\"style\");\n    if (nonce) style.nonce = nonce;\n    const parent = root ?? document.head;\n    parent.appendChild(style);\n    if (style.sheet) {\n      style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `);\n    }\n    return () => {\n      if (parent.contains(style)) {\n        parent.removeChild(style);\n      }\n    };\n  }, [isPresent]);\n  return jsx(PopChildMeasure, {\n    isPresent: isPresent,\n    childRef: ref,\n    sizeRef: size,\n    pop: pop,\n    children: pop === false ? children : React.cloneElement(children, {\n      ref: composedRef\n    })\n  });\n}\nexport { PopChild };","map":{"version":3,"names":["PopChildMeasure","React","Component","getSnapshotBeforeUpdate","prevProps","parent","element","offsetParent","parentWidth","isHTMLElement","offsetWidth","parentHeight","offsetHeight","size","top","offsetTop","left","offsetLeft","right","width","bottom","height","componentDidUpdate","props","children","PopChild","isPresent","anchorX","anchorY","root","pop","id","useId","ref","useRef","childRef","current","x","y","nonce","style","document","head","appendChild","sheet","insertRule","contains","removeChild","cloneElement","composedRef"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/components/AnimatePresence/PopChild.tsx"],"sourcesContent":["\"use client\"\n\nimport { isHTMLElement } from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useId, useInsertionEffect, useRef } from \"react\"\n\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { useComposedRefs } from \"../../utils/use-composed-ref\"\n\ninterface Size {\n    width: number\n    height: number\n    top: number\n    left: number\n    right: number\n    bottom: number\n}\n\ninterface Props {\n    children: React.ReactElement\n    isPresent: boolean\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n    pop?: boolean\n}\n\ninterface MeasureProps extends Props {\n    childRef: React.RefObject<HTMLElement | null>\n    sizeRef: React.RefObject<Size>\n}\n\n/**\n * Measurement functionality has to be within a separate component\n * to leverage snapshot lifecycle.\n */\nclass PopChildMeasure extends React.Component<MeasureProps> {\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const element = this.props.childRef.current\n        if (element && prevProps.isPresent && !this.props.isPresent && this.props.pop !== false) {\n            const parent = element.offsetParent\n            const parentWidth = isHTMLElement(parent)\n                ? parent.offsetWidth || 0\n                : 0\n            const parentHeight = isHTMLElement(parent)\n                ? parent.offsetHeight || 0\n                : 0\n\n            const size = this.props.sizeRef.current!\n            size.height = element.offsetHeight || 0\n            size.width = element.offsetWidth || 0\n            size.top = element.offsetTop\n            size.left = element.offsetLeft\n            size.right = parentWidth - size.width - size.left\n            size.bottom = parentHeight - size.height - size.top\n        }\n\n        return null\n    }\n\n    /**\n     * Required with getSnapshotBeforeUpdate to stop React complaining.\n     */\n    componentDidUpdate() {}\n\n    render() {\n        return this.props.children\n    }\n}\n\nexport function PopChild({ children, isPresent, anchorX, anchorY, root, pop }: Props) {\n    const id = useId()\n    const ref = useRef<HTMLElement>(null)\n    const size = useRef<Size>({\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n    })\n    const { nonce } = useContext(MotionConfigContext)\n    /**\n     * In React 19, refs are passed via props.ref instead of element.ref.\n     * We check props.ref first (React 19) and fall back to element.ref (React 18).\n     */\n    const childRef =\n        (children.props as { ref?: React.Ref<HTMLElement> })?.ref ??\n        (children as unknown as { ref?: React.Ref<HTMLElement> })?.ref\n    const composedRef = useComposedRefs(ref, childRef)\n\n    /**\n     * We create and inject a style block so we can apply this explicit\n     * sizing in a non-destructive manner by just deleting the style block.\n     *\n     * We can't apply size via render as the measurement happens\n     * in getSnapshotBeforeUpdate (post-render), likewise if we apply the\n     * styles directly on the DOM node, we might be overwriting\n     * styles set via the style prop.\n     */\n    useInsertionEffect(() => {\n        const { width, height, top, left, right, bottom } = size.current\n        if (isPresent || pop === false || !ref.current || !width || !height) return\n\n        const x = anchorX === \"left\" ? `left: ${left}` : `right: ${right}`\n        const y = anchorY === \"bottom\" ? `bottom: ${bottom}` : `top: ${top}`\n\n        ref.current.dataset.motionPopId = id\n\n        const style = document.createElement(\"style\")\n        if (nonce) style.nonce = nonce\n\n        const parent = root ?? document.head\n        parent.appendChild(style)\n\n        if (style.sheet) {\n            style.sheet.insertRule(`\n          [data-motion-pop-id=\"${id}\"] {\n            position: absolute !important;\n            width: ${width}px !important;\n            height: ${height}px !important;\n            ${x}px !important;\n            ${y}px !important;\n          }\n        `)\n        }\n\n        return () => {\n            if (parent.contains(style)) {\n                parent.removeChild(style)\n            }\n        }\n    }, [isPresent])\n\n    return (\n        <PopChildMeasure isPresent={isPresent} childRef={ref} sizeRef={size} pop={pop}>\n            {pop === false\n                ? children\n                : React.cloneElement(children as any, { ref: composedRef })}\n        </PopChildMeasure>\n    )\n}\n"],"mappings":";;;;;;;;;AAgCA;;;AAGG;AACH,MAAAA,eAAA,SAAAC,KAAA,CAAAC,SAAA;EACIC,wBAAAC,SAAA;;;MAGQ,MAAAC,MAAA,GAAAC,OAAA,CAAAC,YAAA;MACA,MAAAC,WAAA,GAAAC,aAAA,CAAAJ,MAAA,IACIA,MAAA,CAAAK,WAAA,Q;MAEJ,MAAAC,YAAA,GAAAF,aAAA,CAAAJ,MAAA,IACIA,MAAA,CAAAO,YAAA,Q;;;;MAMJC,IAAA,CAAAC,GAAA,GAAAR,OAAA,CAAAS,SAAA;MACAF,IAAA,CAAAG,IAAA,GAAAV,OAAA,CAAAW,UAAA;MACAJ,IAAA,CAAAK,KAAA,GAAAV,WAAA,GAAAK,IAAA,CAAAM,KAAA,GAAAN,IAAA,CAAAG,IAAA;MACAH,IAAA,CAAAO,MAAA,GAAAT,YAAA,GAAAE,IAAA,CAAAQ,MAAA,GAAAR,IAAA,CAAAC,GAAA;;IAGJ;;EAGJ;;AAEG;EACHQ,mBAAA;;IAGI,YAAAC,KAAA,CAAAC,QAAA;;AAEP;AAEe,SAAAC,SAAA;EAAAD,QAAA;EAAAE,SAAA;EAAAC,OAAA;EAAAC,OAAA;EAAAC,IAAA;EAAAC;AAAA;EACZ,MAAAC,EAAA,GAAAC,KAAA;EACA,MAAAC,GAAA,GAAAC,MAAA;;IAEIf,KAAA;IACAE,MAAA;IACAP,GAAA;IACAE,IAAA;IACAE,KAAA;IACAE,MAAA;EACH;;;;EAED;;;AAGG;EACH,MAAAe,QAAA,GAAAX,QAAA,CAAAD,KAAA,EAAAU,GAAA,I;;EAKA;;;;;;;;AAQG;;IAEC;MAAAd,KAAA;MAAAE,MAAA;MAAAP,GAAA;MAAAE,IAAA;MAAAE,KAAA;MAAAE;IAAA,IAAAP,IAAA,CAAAuB,OAAA;IACA,IAAAV,SAAA,IAAAI,GAAA,eAAAG,GAAA,CAAAG,OAAA,KAAAjB,KAAA,KAAAE,MAAA,E;IAEA,MAAAgB,CAAA,GAAAV,OAAA,uBAAAX,IAAA,eAAAE,KAAA;IACA,MAAAoB,CAAA,GAAAV,OAAA,2BAAAR,MAAA,aAAAN,GAAA;;;IAKA,IAAAyB,KAAA,EAAWC,KAAA,CAAAD,KAAA,GAAAA,KAAA;IAEX,MAAAlC,MAAA,GAAAwB,IAAA,IAAAY,QAAA,CAAAC,IAAA;IACArC,MAAA,CAAAsC,WAAA,CAAAH,KAAA;IAEA,IAAAA,KAAA,CAAAI,KAAA;MACIJ,KAAA,CAAAI,KAAA,CAAAC,UAAA;;;;;;;;AAQH;;IAGD;MACI,IAAAxC,MAAA,CAAAyC,QAAA,CAAAN,KAAA;QACInC,MAAA,CAAA0C,WAAA,CAAAP,KAAA;;IAER;EACJ,IAAAd,SAAA;;;;;;8BAKYF,QAAA,GACAvB,KAAA,CAAA+C,YAAA,CAAAxB,QAAA;MAAAS,GAAA,EAAAgB;IAAA;EAAA;AAGhB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}