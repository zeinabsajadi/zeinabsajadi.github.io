{"ast":null,"code":"import { Feature, addDomEvent } from 'motion-dom';\nimport { pipe } from 'motion-utils';\nclass FocusGesture extends Feature {\n  constructor() {\n    super(...arguments);\n    this.isActive = false;\n  }\n  onFocus() {\n    let isFocusVisible = false;\n    /**\n     * If this element doesn't match focus-visible then don't\n     * apply whileHover. But, if matches throws that focus-visible\n     * is not a valid selector then in that browser outline styles will be applied\n     * to the element by default and we want to match that behaviour with whileFocus.\n     */\n    try {\n      isFocusVisible = this.node.current.matches(\":focus-visible\");\n    } catch (e) {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", true);\n    this.isActive = true;\n  }\n  onBlur() {\n    if (!this.isActive || !this.node.animationState) return;\n    this.node.animationState.setActive(\"whileFocus\", false);\n    this.isActive = false;\n  }\n  mount() {\n    this.unmount = pipe(addDomEvent(this.node.current, \"focus\", () => this.onFocus()), addDomEvent(this.node.current, \"blur\", () => this.onBlur()));\n  }\n  unmount() {}\n}\nexport { FocusGesture };","map":{"version":3,"names":["FocusGesture","Feature","constructor","isActive","onFocus","isFocusVisible","node","current","matches","e","animationState","setActive","onBlur","mount","unmount","pipe","addDomEvent"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/gestures/focus.ts"],"sourcesContent":["import { Feature, addDomEvent } from \"motion-dom\"\nimport { pipe } from \"motion-utils\"\n\nexport class FocusGesture extends Feature<Element> {\n    private isActive = false\n\n    onFocus() {\n        let isFocusVisible = false\n\n        /**\n         * If this element doesn't match focus-visible then don't\n         * apply whileHover. But, if matches throws that focus-visible\n         * is not a valid selector then in that browser outline styles will be applied\n         * to the element by default and we want to match that behaviour with whileFocus.\n         */\n        try {\n            isFocusVisible = this.node.current!.matches(\":focus-visible\")\n        } catch (e) {\n            isFocusVisible = true\n        }\n\n        if (!isFocusVisible || !this.node.animationState) return\n\n        this.node.animationState.setActive(\"whileFocus\", true)\n        this.isActive = true\n    }\n\n    onBlur() {\n        if (!this.isActive || !this.node.animationState) return\n        this.node.animationState.setActive(\"whileFocus\", false)\n        this.isActive = false\n    }\n\n    mount() {\n        this.unmount = pipe(\n            addDomEvent(this.node.current!, \"focus\", () => this.onFocus()),\n            addDomEvent(this.node.current!, \"blur\", () => this.onBlur())\n        ) as VoidFunction\n    }\n\n    unmount() {}\n}\n"],"mappings":";;AAGM,MAAOA,YAAa,SAAQC,OAAgB;EAAlDC,YAAA;;IACY,IAAQ,CAAAC,QAAA,GAAG,KAAK;;EAExBC,OAAOA,CAAA;IACH,IAAIC,cAAc,GAAG,KAAK;IAE1B;;;;;AAKG;IACH,IAAI;MACAA,cAAc,GAAG,IAAI,CAACC,IAAI,CAACC,OAAQ,CAACC,OAAO,CAAC,gBAAgB,CAAC;KAChE,CAAC,OAAOC,CAAC,EAAE;MACRJ,cAAc,GAAG,IAAI;;IAGzB,IAAI,CAACA,cAAc,IAAI,CAAC,IAAI,CAACC,IAAI,CAACI,cAAc,EAAE;IAElD,IAAI,CAACJ,IAAI,CAACI,cAAc,CAACC,SAAS,CAAC,YAAY,EAAE,IAAI,CAAC;IACtD,IAAI,CAACR,QAAQ,GAAG,IAAI;;EAGxBS,MAAMA,CAAA;IACF,IAAI,CAAC,IAAI,CAACT,QAAQ,IAAI,CAAC,IAAI,CAACG,IAAI,CAACI,cAAc,EAAE;IACjD,IAAI,CAACJ,IAAI,CAACI,cAAc,CAACC,SAAS,CAAC,YAAY,EAAE,KAAK,CAAC;IACvD,IAAI,CAACR,QAAQ,GAAG,KAAK;;EAGzBU,KAAKA,CAAA;IACD,IAAI,CAACC,OAAO,GAAGC,IAAI,CACfC,WAAW,CAAC,IAAI,CAACV,IAAI,CAACC,OAAQ,EAAE,OAAO,EAAE,MAAM,IAAI,CAACH,OAAO,EAAE,CAAC,EAC9DY,WAAW,CAAC,IAAI,CAACV,IAAI,CAACC,OAAQ,EAAE,MAAM,EAAE,MAAM,IAAI,CAACK,MAAM,EAAE,CAAC,CAC/C;;EAGrBE,OAAOA,CAAA;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}