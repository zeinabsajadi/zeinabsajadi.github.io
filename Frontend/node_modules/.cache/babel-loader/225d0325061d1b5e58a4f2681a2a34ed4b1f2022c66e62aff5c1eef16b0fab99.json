{"ast":null,"code":"import { interpolate, defaultOffset } from 'motion-dom';\nimport { clamp } from 'motion-utils';\nimport { calcInset } from './inset.mjs';\nimport { resolveOffset } from './offset.mjs';\nimport { ScrollOffset } from './presets.mjs';\nconst point = {\n  x: 0,\n  y: 0\n};\nfunction getTargetSize(target) {\n  return \"getBBox\" in target && target.tagName !== \"svg\" ? target.getBBox() : {\n    width: target.clientWidth,\n    height: target.clientHeight\n  };\n}\nfunction resolveOffsets(container, info, options) {\n  const {\n    offset: offsetDefinition = ScrollOffset.All\n  } = options;\n  const {\n    target = container,\n    axis = \"y\"\n  } = options;\n  const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n  const inset = target !== container ? calcInset(target, container) : point;\n  /**\n   * Measure the target and container. If they're the same thing then we\n   * use the container's scrollWidth/Height as the target, from there\n   * all other calculations can remain the same.\n   */\n  const targetSize = target === container ? {\n    width: container.scrollWidth,\n    height: container.scrollHeight\n  } : getTargetSize(target);\n  const containerSize = {\n    width: container.clientWidth,\n    height: container.clientHeight\n  };\n  /**\n   * Reset the length of the resolved offset array rather than creating a new one.\n   * TODO: More reusable data structures for targetSize/containerSize would also be good.\n   */\n  info[axis].offset.length = 0;\n  /**\n   * Populate the offset array by resolving the user's offset definition into\n   * a list of pixel scroll offets.\n   */\n  let hasChanged = !info[axis].interpolate;\n  const numOffsets = offsetDefinition.length;\n  for (let i = 0; i < numOffsets; i++) {\n    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n      hasChanged = true;\n    }\n    info[axis].offset[i] = offset;\n  }\n  /**\n   * If the pixel scroll offsets have changed, create a new interpolator function\n   * to map scroll value into a progress.\n   */\n  if (hasChanged) {\n    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset(offsetDefinition), {\n      clamp: false\n    });\n    info[axis].interpolatorOffsets = [...info[axis].offset];\n  }\n  info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));\n}\nexport { resolveOffsets };","map":{"version":3,"names":["point","x","y","getTargetSize","target","tagName","getBBox","width","clientWidth","height","clientHeight","resolveOffsets","container","info","options","offset","offsetDefinition","ScrollOffset","All","axis","lengthLabel","inset","calcInset","targetSize","scrollWidth","scrollHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","resolveOffset","interpolatorOffsets","defaultOffset","clamp","progress","current"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/render/dom/scroll/offsets/index.ts"],"sourcesContent":["import { defaultOffset, interpolate } from \"motion-dom\"\nimport { clamp } from \"motion-utils\"\nimport { ScrollInfo, ScrollInfoOptions } from \"../types\"\nimport { calcInset } from \"./inset\"\nimport { resolveOffset } from \"./offset\"\nimport { ScrollOffset } from \"./presets\"\n\nconst point = { x: 0, y: 0 }\n\nfunction getTargetSize(target: Element) {\n    return \"getBBox\" in target && target.tagName !== \"svg\"\n        ? (target as SVGGraphicsElement).getBBox()\n        : { width: target.clientWidth, height: target.clientHeight }\n}\n\nexport function resolveOffsets(\n    container: Element,\n    info: ScrollInfo,\n    options: ScrollInfoOptions\n) {\n    const { offset: offsetDefinition = ScrollOffset.All } = options\n    const { target = container, axis = \"y\" } = options\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\"\n\n    const inset = target !== container ? calcInset(target, container) : point\n\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize =\n        target === container\n            ? { width: container.scrollWidth, height: container.scrollHeight }\n            : getTargetSize(target)\n\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    }\n\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0\n\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate\n\n    const numOffsets = offsetDefinition.length\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(\n            offsetDefinition[i],\n            containerSize[lengthLabel],\n            targetSize[lengthLabel],\n            inset[axis]\n        )\n\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets![i]) {\n            hasChanged = true\n        }\n\n        info[axis].offset[i] = offset\n    }\n\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate(\n            info[axis].offset,\n            defaultOffset(offsetDefinition),\n            { clamp: false }\n        )\n\n        info[axis].interpolatorOffsets = [...info[axis].offset]\n    }\n\n    info[axis].progress = clamp(\n        0,\n        1,\n        info[axis].interpolate!(info[axis].current)\n    )\n}\n"],"mappings":";;;;;AAOA,MAAMA,KAAK,GAAG;EAAEC,CAAC,EAAE,CAAC;EAAEC,CAAC,EAAE;AAAC,CAAE;AAE5B,SAASC,aAAaA,CAACC,MAAe;EAClC,OAAO,SAAS,IAAIA,MAAM,IAAIA,MAAM,CAACC,OAAO,KAAK,KAAK,GAC/CD,MAA6B,CAACE,OAAO,EAAE,GACxC;IAAEC,KAAK,EAAEH,MAAM,CAACI,WAAW;IAAEC,MAAM,EAAEL,MAAM,CAACM;EAAY,CAAE;AACpE;SAEgBC,cAAcA,CAC1BC,SAAkB,EAClBC,IAAgB,EAChBC,OAA0B;EAE1B,MAAM;IAAEC,MAAM,EAAEC,gBAAgB,GAAGC,YAAY,CAACC;EAAG,CAAE,GAAGJ,OAAO;EAC/D,MAAM;IAAEV,MAAM,GAAGQ,SAAS;IAAEO,IAAI,GAAG;EAAG,CAAE,GAAGL,OAAO;EAClD,MAAMM,WAAW,GAAGD,IAAI,KAAK,GAAG,GAAG,QAAQ,GAAG,OAAO;EAErD,MAAME,KAAK,GAAGjB,MAAM,KAAKQ,SAAS,GAAGU,SAAS,CAAClB,MAAM,EAAEQ,SAAS,CAAC,GAAGZ,KAAK;EAEzE;;;;AAIG;EACH,MAAMuB,UAAU,GACZnB,MAAM,KAAKQ,SAAS,GACd;IAAEL,KAAK,EAAEK,SAAS,CAACY,WAAW;IAAEf,MAAM,EAAEG,SAAS,CAACa;EAAY,CAAE,GAChEtB,aAAa,CAACC,MAAM,CAAC;EAE/B,MAAMsB,aAAa,GAAG;IAClBnB,KAAK,EAAEK,SAAS,CAACJ,WAAW;IAC5BC,MAAM,EAAEG,SAAS,CAACF;GACrB;EAED;;;AAGG;EACHG,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACY,MAAM,GAAG,CAAC;EAE5B;;;AAGG;EACH,IAAIC,UAAU,GAAG,CAACf,IAAI,CAACM,IAAI,CAAC,CAACU,WAAW;EAExC,MAAMC,UAAU,GAAGd,gBAAgB,CAACW,MAAM;EAC1C,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,UAAU,EAAEC,CAAC,EAAE,EAAE;IACjC,MAAMhB,MAAM,GAAGiB,aAAa,CACxBhB,gBAAgB,CAACe,CAAC,CAAC,EACnBL,aAAa,CAACN,WAAW,CAAC,EAC1BG,UAAU,CAACH,WAAW,CAAC,EACvBC,KAAK,CAACF,IAAI,CAAC,CACd;IAED,IAAI,CAACS,UAAU,IAAIb,MAAM,KAAKF,IAAI,CAACM,IAAI,CAAC,CAACc,mBAAoB,CAACF,CAAC,CAAC,EAAE;MAC9DH,UAAU,GAAG,IAAI;;IAGrBf,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAACgB,CAAC,CAAC,GAAGhB,MAAM;;EAGjC;;;AAGG;EACH,IAAIa,UAAU,EAAE;IACZf,IAAI,CAACM,IAAI,CAAC,CAACU,WAAW,GAAGA,WAAW,CAChChB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,EACjBmB,aAAa,CAAClB,gBAAgB,CAAC,EAC/B;MAAEmB,KAAK,EAAE;IAAK,CAAE,CACnB;IAEDtB,IAAI,CAACM,IAAI,CAAC,CAACc,mBAAmB,GAAG,CAAC,GAAGpB,IAAI,CAACM,IAAI,CAAC,CAACJ,MAAM,CAAC;;EAG3DF,IAAI,CAACM,IAAI,CAAC,CAACiB,QAAQ,GAAGD,KAAK,CACvB,CAAC,EACD,CAAC,EACDtB,IAAI,CAACM,IAAI,CAAC,CAACU,WAAY,CAAChB,IAAI,CAACM,IAAI,CAAC,CAACkB,OAAO,CAAC,CAC9C;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}