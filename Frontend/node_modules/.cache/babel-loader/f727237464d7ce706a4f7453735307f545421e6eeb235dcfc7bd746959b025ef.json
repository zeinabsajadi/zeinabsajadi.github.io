{"ast":null,"code":"import { statsBuffer } from '../stats/buffer.mjs';\nfunction createRenderStep(runNextFrame, stepName) {\n  /**\n   * We create and reuse two queues, one to queue jobs for the current frame\n   * and one for the next. We reuse to avoid triggering GC after x frames.\n   */\n  let thisFrame = new Set();\n  let nextFrame = new Set();\n  /**\n   * Track whether we're currently processing jobs in this step. This way\n   * we can decide whether to schedule new jobs for this frame or next.\n   */\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\n   * A set of processes which were marked keepAlive when scheduled.\n   */\n  const toKeepAlive = new WeakSet();\n  let latestFrameData = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  let numCalls = 0;\n  function triggerCallback(callback) {\n    if (toKeepAlive.has(callback)) {\n      step.schedule(callback);\n      runNextFrame();\n    }\n    numCalls++;\n    callback(latestFrameData);\n  }\n  const step = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (!queue.has(callback)) queue.add(callback);\n      return callback;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: callback => {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: frameData => {\n      latestFrameData = frameData;\n      /**\n       * If we're already processing we've probably been triggered by a flushSync\n       * inside an existing process. Instead of executing, mark flushNextFrame\n       * as true and ensure we flush the following frame at the end of this one.\n       */\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame];\n      // Execute this frame\n      thisFrame.forEach(triggerCallback);\n      /**\n       * If we're recording stats then\n       */\n      if (stepName && statsBuffer.value) {\n        statsBuffer.value.frameloop[stepName].push(numCalls);\n      }\n      numCalls = 0;\n      // Clear the frame so no callbacks remain. This is to avoid\n      // memory leaks should this render step not run for a while.\n      thisFrame.clear();\n      isProcessing = false;\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\nexport { createRenderStep };","map":{"version":3,"names":["createRenderStep","runNextFrame","stepName","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","numCalls","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","statsBuffer","value","frameloop","push","clear"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/frameloop/render-step.ts"],"sourcesContent":["import { statsBuffer } from \"../stats/buffer\"\nimport { StepNames } from \"./order\"\nimport { FrameData, Process, Step } from \"./types\"\n\nexport function createRenderStep(\n    runNextFrame: () => void,\n    stepName?: StepNames\n): Step {\n    /**\n     * We create and reuse two queues, one to queue jobs for the current frame\n     * and one for the next. We reuse to avoid triggering GC after x frames.\n     */\n    let thisFrame = new Set<Process>()\n    let nextFrame = new Set<Process>()\n\n    /**\n     * Track whether we're currently processing jobs in this step. This way\n     * we can decide whether to schedule new jobs for this frame or next.\n     */\n    let isProcessing = false\n\n    let flushNextFrame = false\n\n    /**\n     * A set of processes which were marked keepAlive when scheduled.\n     */\n    const toKeepAlive = new WeakSet<Process>()\n\n    let latestFrameData: FrameData = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    }\n\n    let numCalls = 0\n\n    function triggerCallback(callback: Process) {\n        if (toKeepAlive.has(callback)) {\n            step.schedule(callback)\n            runNextFrame()\n        }\n\n        numCalls++\n        callback(latestFrameData)\n    }\n\n    const step: Step = {\n        /**\n         * Schedule a process to run on the next frame.\n         */\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing\n            const queue = addToCurrentFrame ? thisFrame : nextFrame\n\n            if (keepAlive) toKeepAlive.add(callback)\n\n            if (!queue.has(callback)) queue.add(callback)\n\n            return callback\n        },\n\n        /**\n         * Cancel the provided callback from running on the next frame.\n         */\n        cancel: (callback) => {\n            nextFrame.delete(callback)\n            toKeepAlive.delete(callback)\n        },\n\n        /**\n         * Execute all schedule callbacks.\n         */\n        process: (frameData) => {\n            latestFrameData = frameData\n\n            /**\n             * If we're already processing we've probably been triggered by a flushSync\n             * inside an existing process. Instead of executing, mark flushNextFrame\n             * as true and ensure we flush the following frame at the end of this one.\n             */\n            if (isProcessing) {\n                flushNextFrame = true\n                return\n            }\n\n            isProcessing = true\n\n            // Swap this frame and the next to avoid GC\n            ;[thisFrame, nextFrame] = [nextFrame, thisFrame]\n\n            // Execute this frame\n            thisFrame.forEach(triggerCallback)\n\n            /**\n             * If we're recording stats then\n             */\n            if (stepName && statsBuffer.value) {\n                statsBuffer.value.frameloop[stepName].push(numCalls)\n            }\n            numCalls = 0\n\n            // Clear the frame so no callbacks remain. This is to avoid\n            // memory leaks should this render step not run for a while.\n            thisFrame.clear()\n\n            isProcessing = false\n\n            if (flushNextFrame) {\n                flushNextFrame = false\n                step.process(frameData)\n            }\n        },\n    }\n\n    return step\n}\n"],"mappings":";AAIgB,SAAAA,gBAAgBA,CAC5BC,YAAwB,EACxBC,QAAoB;EAEpB;;;AAGG;EACH,IAAIC,SAAS,GAAG,IAAIC,GAAG,EAAW;EAClC,IAAIC,SAAS,GAAG,IAAID,GAAG,EAAW;EAElC;;;AAGG;EACH,IAAIE,YAAY,GAAG,KAAK;EAExB,IAAIC,cAAc,GAAG,KAAK;EAE1B;;AAEG;EACH,MAAMC,WAAW,GAAG,IAAIC,OAAO,EAAW;EAE1C,IAAIC,eAAe,GAAc;IAC7BC,KAAK,EAAE,GAAG;IACVC,SAAS,EAAE,GAAG;IACdN,YAAY,EAAE;GACjB;EAED,IAAIO,QAAQ,GAAG,CAAC;EAEhB,SAASC,eAAeA,CAACC,QAAiB;IACtC,IAAIP,WAAW,CAACQ,GAAG,CAACD,QAAQ,CAAC,EAAE;MAC3BE,IAAI,CAACC,QAAQ,CAACH,QAAQ,CAAC;MACvBd,YAAY,EAAE;;IAGlBY,QAAQ,EAAE;IACVE,QAAQ,CAACL,eAAe,CAAC;;EAG7B,MAAMO,IAAI,GAAS;IACf;;AAEG;IACHC,QAAQ,EAAEA,CAACH,QAAQ,EAAEI,SAAS,GAAG,KAAK,EAAEC,SAAS,GAAG,KAAK,KAAI;MACzD,MAAMC,iBAAiB,GAAGD,SAAS,IAAId,YAAY;MACnD,MAAMgB,KAAK,GAAGD,iBAAiB,GAAGlB,SAAS,GAAGE,SAAS;MAEvD,IAAIc,SAAS,EAAEX,WAAW,CAACe,GAAG,CAACR,QAAQ,CAAC;MAExC,IAAI,CAACO,KAAK,CAACN,GAAG,CAACD,QAAQ,CAAC,EAAEO,KAAK,CAACC,GAAG,CAACR,QAAQ,CAAC;MAE7C,OAAOA,QAAQ;KAClB;IAED;;AAEG;IACHS,MAAM,EAAGT,QAAQ,IAAI;MACjBV,SAAS,CAACoB,MAAM,CAACV,QAAQ,CAAC;MAC1BP,WAAW,CAACiB,MAAM,CAACV,QAAQ,CAAC;KAC/B;IAED;;AAEG;IACHW,OAAO,EAAGC,SAAS,IAAI;MACnBjB,eAAe,GAAGiB,SAAS;MAE3B;;;;AAIG;MACH,IAAIrB,YAAY,EAAE;QACdC,cAAc,GAAG,IAAI;QACrB;;MAGJD,YAAY,GAAG,IAAI;MAGlB,CAACH,SAAS,EAAEE,SAAS,CAAC,GAAG,CAACA,SAAS,EAAEF,SAAS,CAAC;;MAGhDA,SAAS,CAACyB,OAAO,CAACd,eAAe,CAAC;MAElC;;AAEG;MACH,IAAIZ,QAAQ,IAAI2B,WAAW,CAACC,KAAK,EAAE;QAC/BD,WAAW,CAACC,KAAK,CAACC,SAAS,CAAC7B,QAAQ,CAAC,CAAC8B,IAAI,CAACnB,QAAQ,CAAC;;MAExDA,QAAQ,GAAG,CAAC;;;MAIZV,SAAS,CAAC8B,KAAK,EAAE;MAEjB3B,YAAY,GAAG,KAAK;MAEpB,IAAIC,cAAc,EAAE;QAChBA,cAAc,GAAG,KAAK;QACtBU,IAAI,CAACS,OAAO,CAACC,SAAS,CAAC;;;GAGlC;EAED,OAAOV,IAAI;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}