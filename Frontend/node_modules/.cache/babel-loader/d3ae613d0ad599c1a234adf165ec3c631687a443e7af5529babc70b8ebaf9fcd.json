{"ast":null,"code":"import { isDragActive } from './drag/state/is-active.mjs';\nimport { setupGesture } from './utils/setup.mjs';\nfunction isValidHover(event) {\n  return !(event.pointerType === \"touch\" || isDragActive());\n}\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nfunction hover(elementOrSelector, onHoverStart, options = {}) {\n  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);\n  elements.forEach(element => {\n    let isPressed = false;\n    let deferredHoverEnd = false;\n    let hoverEndCallback;\n    const removePointerLeave = () => {\n      element.removeEventListener(\"pointerleave\", onPointerLeave);\n    };\n    const endHover = event => {\n      if (hoverEndCallback) {\n        hoverEndCallback(event);\n        hoverEndCallback = undefined;\n      }\n      removePointerLeave();\n    };\n    const onPointerUp = event => {\n      isPressed = false;\n      window.removeEventListener(\"pointerup\", onPointerUp);\n      window.removeEventListener(\"pointercancel\", onPointerUp);\n      if (deferredHoverEnd) {\n        deferredHoverEnd = false;\n        endHover(event);\n      }\n    };\n    const onPointerDown = () => {\n      isPressed = true;\n      window.addEventListener(\"pointerup\", onPointerUp, eventOptions);\n      window.addEventListener(\"pointercancel\", onPointerUp, eventOptions);\n    };\n    const onPointerLeave = leaveEvent => {\n      if (leaveEvent.pointerType === \"touch\") return;\n      if (isPressed) {\n        deferredHoverEnd = true;\n        return;\n      }\n      endHover(leaveEvent);\n    };\n    const onPointerEnter = enterEvent => {\n      if (!isValidHover(enterEvent)) return;\n      deferredHoverEnd = false;\n      const onHoverEnd = onHoverStart(element, enterEvent);\n      if (typeof onHoverEnd !== \"function\") return;\n      hoverEndCallback = onHoverEnd;\n      element.addEventListener(\"pointerleave\", onPointerLeave, eventOptions);\n    };\n    element.addEventListener(\"pointerenter\", onPointerEnter, eventOptions);\n    element.addEventListener(\"pointerdown\", onPointerDown, eventOptions);\n  });\n  return cancel;\n}\nexport { hover };","map":{"version":3,"names":["isValidHover","event","pointerType","isDragActive","hover","elementOrSelector","onHoverStart","options","elements","eventOptions","cancel","setupGesture","forEach","element","isPressed","deferredHoverEnd","hoverEndCallback","removePointerLeave","removeEventListener","onPointerLeave","endHover","undefined","onPointerUp","window","onPointerDown","addEventListener","leaveEvent","onPointerEnter","enterEvent","onHoverEnd"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/gestures/hover.ts"],"sourcesContent":["import { ElementOrSelector } from \"../utils/resolve-elements\"\nimport { isDragActive } from \"./drag/state/is-active\"\nimport { EventOptions } from \"./types\"\nimport { setupGesture } from \"./utils/setup\"\n\n/**\n * A function to be called when a hover gesture starts.\n *\n * This function can optionally return a function that will be called\n * when the hover gesture ends.\n *\n * @public\n */\nexport type OnHoverStartEvent = (\n    element: Element,\n    event: PointerEvent\n) => void | OnHoverEndEvent\n\n/**\n * A function to be called when a hover gesture ends.\n *\n * @public\n */\nexport type OnHoverEndEvent = (event: PointerEvent) => void\n\nfunction isValidHover(event: PointerEvent) {\n    return !(event.pointerType === \"touch\" || isDragActive())\n}\n\n/**\n * Create a hover gesture. hover() is different to .addEventListener(\"pointerenter\")\n * in that it has an easier syntax, filters out polyfilled touch events, interoperates\n * with drag gestures, and automatically removes the \"pointerennd\" event listener when the hover ends.\n *\n * @public\n */\nexport function hover(\n    elementOrSelector: ElementOrSelector,\n    onHoverStart: OnHoverStartEvent,\n    options: EventOptions = {}\n): VoidFunction {\n    const [elements, eventOptions, cancel] = setupGesture(\n        elementOrSelector,\n        options\n    )\n\n    elements.forEach((element) => {\n        let isPressed = false\n        let deferredHoverEnd = false\n        let hoverEndCallback: OnHoverEndEvent | undefined\n\n        const removePointerLeave = () => {\n            element.removeEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener\n            )\n        }\n\n        const endHover = (event: PointerEvent) => {\n            if (hoverEndCallback) {\n                hoverEndCallback(event)\n                hoverEndCallback = undefined\n            }\n            removePointerLeave()\n        }\n\n        const onPointerUp = (event: Event) => {\n            isPressed = false\n            window.removeEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener\n            )\n            window.removeEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener\n            )\n\n            if (deferredHoverEnd) {\n                deferredHoverEnd = false\n                endHover(event as PointerEvent)\n            }\n        }\n\n        const onPointerDown = () => {\n            isPressed = true\n            window.addEventListener(\n                \"pointerup\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n            window.addEventListener(\n                \"pointercancel\",\n                onPointerUp as EventListener,\n                eventOptions\n            )\n        }\n\n        const onPointerLeave = (leaveEvent: PointerEvent) => {\n            if (leaveEvent.pointerType === \"touch\") return\n\n            if (isPressed) {\n                deferredHoverEnd = true\n                return\n            }\n\n            endHover(leaveEvent)\n        }\n\n        const onPointerEnter = (enterEvent: PointerEvent) => {\n            if (!isValidHover(enterEvent)) return\n\n            deferredHoverEnd = false\n\n            const onHoverEnd = onHoverStart(\n                element as Element,\n                enterEvent\n            )\n\n            if (typeof onHoverEnd !== \"function\") return\n\n            hoverEndCallback = onHoverEnd\n\n            element.addEventListener(\n                \"pointerleave\",\n                onPointerLeave as EventListener,\n                eventOptions\n            )\n        }\n\n        element.addEventListener(\n            \"pointerenter\",\n            onPointerEnter as EventListener,\n            eventOptions\n        )\n        element.addEventListener(\n            \"pointerdown\",\n            onPointerDown as EventListener,\n            eventOptions\n        )\n    })\n\n    return cancel\n}\n"],"mappings":";;AAyBA,SAASA,YAAYA,CAACC,KAAmB;EACrC,OAAO,EAAEA,KAAK,CAACC,WAAW,KAAK,OAAO,IAAIC,YAAY,EAAE,CAAC;AAC7D;AAEA;;;;;;AAMG;AACG,SAAUC,KAAKA,CACjBC,iBAAoC,EACpCC,YAA+B,EAC/BC,OAAA,GAAwB,EAAE;EAE1B,MAAM,CAACC,QAAQ,EAAEC,YAAY,EAAEC,MAAM,CAAC,GAAGC,YAAY,CACjDN,iBAAiB,EACjBE,OAAO,CACV;EAEDC,QAAQ,CAACI,OAAO,CAAEC,OAAO,IAAI;IACzB,IAAIC,SAAS,GAAG,KAAK;IACrB,IAAIC,gBAAgB,GAAG,KAAK;IAC5B,IAAIC,gBAA6C;IAEjD,MAAMC,kBAAkB,GAAGA,CAAA,KAAK;MAC5BJ,OAAO,CAACK,mBAAmB,CACvB,cAAc,EACdC,cAA+B,CAClC;IACL,CAAC;IAED,MAAMC,QAAQ,GAAInB,KAAmB,IAAI;MACrC,IAAIe,gBAAgB,EAAE;QAClBA,gBAAgB,CAACf,KAAK,CAAC;QACvBe,gBAAgB,GAAGK,SAAS;;MAEhCJ,kBAAkB,EAAE;IACxB,CAAC;IAED,MAAMK,WAAW,GAAIrB,KAAY,IAAI;MACjCa,SAAS,GAAG,KAAK;MACjBS,MAAM,CAACL,mBAAmB,CACtB,WAAW,EACXI,WAA4B,CAC/B;MACDC,MAAM,CAACL,mBAAmB,CACtB,eAAe,EACfI,WAA4B,CAC/B;MAED,IAAIP,gBAAgB,EAAE;QAClBA,gBAAgB,GAAG,KAAK;QACxBK,QAAQ,CAACnB,KAAqB,CAAC;;IAEvC,CAAC;IAED,MAAMuB,aAAa,GAAGA,CAAA,KAAK;MACvBV,SAAS,GAAG,IAAI;MAChBS,MAAM,CAACE,gBAAgB,CACnB,WAAW,EACXH,WAA4B,EAC5Bb,YAAY,CACf;MACDc,MAAM,CAACE,gBAAgB,CACnB,eAAe,EACfH,WAA4B,EAC5Bb,YAAY,CACf;IACL,CAAC;IAED,MAAMU,cAAc,GAAIO,UAAwB,IAAI;MAChD,IAAIA,UAAU,CAACxB,WAAW,KAAK,OAAO,EAAE;MAExC,IAAIY,SAAS,EAAE;QACXC,gBAAgB,GAAG,IAAI;QACvB;;MAGJK,QAAQ,CAACM,UAAU,CAAC;IACxB,CAAC;IAED,MAAMC,cAAc,GAAIC,UAAwB,IAAI;MAChD,IAAI,CAAC5B,YAAY,CAAC4B,UAAU,CAAC,EAAE;MAE/Bb,gBAAgB,GAAG,KAAK;MAExB,MAAMc,UAAU,GAAGvB,YAAY,CAC3BO,OAAkB,EAClBe,UAAU,CACb;MAED,IAAI,OAAOC,UAAU,KAAK,UAAU,EAAE;MAEtCb,gBAAgB,GAAGa,UAAU;MAE7BhB,OAAO,CAACY,gBAAgB,CACpB,cAAc,EACdN,cAA+B,EAC/BV,YAAY,CACf;IACL,CAAC;IAEDI,OAAO,CAACY,gBAAgB,CACpB,cAAc,EACdE,cAA+B,EAC/BlB,YAAY,CACf;IACDI,OAAO,CAACY,gBAAgB,CACpB,aAAa,EACbD,aAA8B,EAC9Bf,YAAY,CACf;EACL,CAAC,CAAC;EAEF,OAAOC,MAAM;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}