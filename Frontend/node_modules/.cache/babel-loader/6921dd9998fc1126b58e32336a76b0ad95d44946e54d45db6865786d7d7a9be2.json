{"ast":null,"code":"\"use client\";\n\nimport { optimizedAppearDataAttribute } from 'motion-dom';\nimport { useContext, useRef, useInsertionEffect, useEffect } from 'react';\nimport { LazyContext } from '../../context/LazyContext.mjs';\nimport { MotionConfigContext } from '../../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../context/SwitchLayoutGroupContext.mjs';\nimport { isRefObject } from '../../utils/is-ref-object.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nfunction useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor, isSVG) {\n  const {\n    visualElement: parent\n  } = useContext(MotionContext);\n  const lazyContext = useContext(LazyContext);\n  const presenceContext = useContext(PresenceContext);\n  const motionConfig = useContext(MotionConfigContext);\n  const reducedMotionConfig = motionConfig.reducedMotion;\n  const skipAnimations = motionConfig.skipAnimations;\n  const visualElementRef = useRef(null);\n  /**\n   * Track whether the component has been through React's commit phase.\n   * Used to detect when LazyMotion features load after the component has mounted.\n   */\n  const hasMountedOnce = useRef(false);\n  /**\n   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n   */\n  createVisualElement = createVisualElement || lazyContext.renderer;\n  if (!visualElementRef.current && createVisualElement) {\n    visualElementRef.current = createVisualElement(Component, {\n      visualState,\n      parent,\n      props,\n      presenceContext,\n      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,\n      reducedMotionConfig,\n      skipAnimations,\n      isSVG\n    });\n    /**\n     * If the component has already mounted before features loaded (e.g. via\n     * LazyMotion with async feature loading), we need to force the initial\n     * animation to run. Otherwise state changes that occurred before features\n     * loaded will be lost and the element will snap to its final state.\n     */\n    if (hasMountedOnce.current && visualElementRef.current) {\n      visualElementRef.current.manuallyAnimateOnMount = true;\n    }\n  }\n  const visualElement = visualElementRef.current;\n  /**\n   * Load Motion gesture and animation features. These are rendered as renderless\n   * components so each feature can optionally make use of React lifecycle methods.\n   */\n  const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === \"html\" || visualElement.type === \"svg\")) {\n    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);\n  }\n  const isMounted = useRef(false);\n  useInsertionEffect(() => {\n    /**\n     * Check the component has already mounted before calling\n     * `update` unnecessarily. This ensures we skip the initial update.\n     */\n    if (visualElement && isMounted.current) {\n      visualElement.update(props, presenceContext);\n    }\n  });\n  /**\n   * Cache this value as we want to know whether HandoffAppearAnimations\n   * was present on initial render - it will be deleted after this.\n   */\n  const optimisedAppearId = props[optimizedAppearDataAttribute];\n  const wantsHandoff = useRef(Boolean(optimisedAppearId) && !window.MotionHandoffIsComplete?.(optimisedAppearId) && window.MotionHasOptimisedAnimation?.(optimisedAppearId));\n  useIsomorphicLayoutEffect(() => {\n    /**\n     * Track that this component has mounted. This is used to detect when\n     * LazyMotion features load after the component has already committed.\n     */\n    hasMountedOnce.current = true;\n    if (!visualElement) return;\n    isMounted.current = true;\n    window.MotionIsMounted = true;\n    visualElement.updateFeatures();\n    visualElement.scheduleRenderMicrotask();\n    /**\n     * Ideally this function would always run in a useEffect.\n     *\n     * However, if we have optimised appear animations to handoff from,\n     * it needs to happen synchronously to ensure there's no flash of\n     * incorrect styles in the event of a hydration error.\n     *\n     * So if we detect a situtation where optimised appear animations\n     * are running, we use useLayoutEffect to trigger animations.\n     */\n    if (wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n  });\n  useEffect(() => {\n    if (!visualElement) return;\n    if (!wantsHandoff.current && visualElement.animationState) {\n      visualElement.animationState.animateChanges();\n    }\n    if (wantsHandoff.current) {\n      // This ensures all future calls to animateChanges() in this component will run in useEffect\n      queueMicrotask(() => {\n        window.MotionHandoffMarkAsComplete?.(optimisedAppearId);\n      });\n      wantsHandoff.current = false;\n    }\n    /**\n     * Now we've finished triggering animations for this element we\n     * can wipe the enteringChildren set for the next render.\n     */\n    visualElement.enteringChildren = undefined;\n  });\n  return visualElement;\n}\nfunction createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {\n  const {\n    layoutId,\n    layout,\n    drag,\n    dragConstraints,\n    layoutScroll,\n    layoutRoot,\n    layoutCrossfade\n  } = props;\n  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props[\"data-framer-portal-id\"] ? undefined : getClosestProjectingNode(visualElement.parent));\n  visualElement.projection.setOptions({\n    layoutId,\n    layout,\n    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),\n    visualElement,\n    /**\n     * TODO: Update options in an effect. This could be tricky as it'll be too late\n     * to update by the time layout animations run.\n     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n     * ensuring it gets called if there's no potential layout animations.\n     *\n     */\n    animationType: typeof layout === \"string\" ? layout : \"both\",\n    initialPromotionConfig,\n    crossfade: layoutCrossfade,\n    layoutScroll,\n    layoutRoot\n  });\n}\nfunction getClosestProjectingNode(visualElement) {\n  if (!visualElement) return undefined;\n  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);\n}\nexport { useVisualElement };","map":{"version":3,"names":["useVisualElement","Component","visualState","props","createVisualElement","ProjectionNodeConstructor","isSVG","lazyContext","useContext","LazyContext","presenceContext","PresenceContext","motionConfig","MotionConfigContext","reducedMotionConfig","reducedMotion","skipAnimations","visualElementRef","useRef","hasMountedOnce","current","blockInitialAnimation","initial","manuallyAnimateOnMount","visualElement","initialLayoutGroupConfig","SwitchLayoutGroupContext","type","isMounted","update","optimisedAppearId","optimizedAppearDataAttribute","wantsHandoff","Boolean","window","MotionHandoffIsComplete","MotionHasOptimisedAnimation","MotionIsMounted","animationState","animateChanges","MotionHandoffMarkAsComplete","enteringChildren","undefined","createProjectionNode","initialPromotionConfig","layoutId","layout","drag","dragConstraints","layoutScroll","layoutRoot","layoutCrossfade","projection","latestValues","setOptions","alwaysMeasureLayout","isRefObject","animationType","crossfade","getClosestProjectingNode","options","allowProjection","parent"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/motion/utils/use-visual-element.ts"],"sourcesContent":["\"use client\"\n\nimport {\n    optimizedAppearDataAttribute,\n    type HTMLRenderState,\n    type SVGRenderState,\n    type VisualElement,\n} from \"motion-dom\"\nimport * as React from \"react\"\nimport { useContext, useEffect, useInsertionEffect, useRef } from \"react\"\nimport { LazyContext } from \"../../context/LazyContext\"\nimport { MotionConfigContext } from \"../../context/MotionConfigContext\"\nimport { MotionContext } from \"../../context/MotionContext\"\nimport { PresenceContext } from \"../../context/PresenceContext\"\nimport {\n    InitialPromotionConfig,\n    SwitchLayoutGroupContext,\n} from \"../../context/SwitchLayoutGroupContext\"\nimport { MotionProps } from \"../../motion/types\"\nimport type { IProjectionNode } from \"motion-dom\"\nimport { DOMMotionComponents } from \"../../render/dom/types\"\nimport { CreateVisualElement } from \"../../render/types\"\nimport { isRefObject } from \"../../utils/is-ref-object\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { VisualState } from \"./use-visual-state\"\n\nexport function useVisualElement<\n    Props,\n    TagName extends keyof DOMMotionComponents | string\n>(\n    Component: TagName | string | React.ComponentType<Props>,\n    visualState:\n        | VisualState<SVGElement, SVGRenderState>\n        | VisualState<HTMLElement, HTMLRenderState>,\n    props: MotionProps & Partial<MotionConfigContext>,\n    createVisualElement?: CreateVisualElement<Props, TagName>,\n    ProjectionNodeConstructor?: any,\n    isSVG?: boolean\n): VisualElement<HTMLElement | SVGElement> | undefined {\n    const { visualElement: parent } = useContext(MotionContext)\n    const lazyContext = useContext(LazyContext)\n    const presenceContext = useContext(PresenceContext)\n    const motionConfig = useContext(MotionConfigContext)\n    const reducedMotionConfig = motionConfig.reducedMotion\n    const skipAnimations = motionConfig.skipAnimations\n\n    const visualElementRef = useRef<VisualElement<\n        HTMLElement | SVGElement\n    > | null>(null)\n\n    /**\n     * Track whether the component has been through React's commit phase.\n     * Used to detect when LazyMotion features load after the component has mounted.\n     */\n    const hasMountedOnce = useRef(false)\n\n    /**\n     * If we haven't preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    createVisualElement =\n        createVisualElement ||\n        (lazyContext.renderer as CreateVisualElement<Props, TagName>)\n\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState,\n            parent,\n            props,\n            presenceContext,\n            blockInitialAnimation: presenceContext\n                ? presenceContext.initial === false\n                : false,\n            reducedMotionConfig,\n            skipAnimations,\n            isSVG,\n        })\n\n        /**\n         * If the component has already mounted before features loaded (e.g. via\n         * LazyMotion with async feature loading), we need to force the initial\n         * animation to run. Otherwise state changes that occurred before features\n         * loaded will be lost and the element will snap to its final state.\n         */\n        if (hasMountedOnce.current && visualElementRef.current) {\n            visualElementRef.current.manuallyAnimateOnMount = true\n        }\n    }\n\n    const visualElement = visualElementRef.current\n\n    /**\n     * Load Motion gesture and animation features. These are rendered as renderless\n     * components so each feature can optionally make use of React lifecycle methods.\n     */\n    const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext)\n\n    if (\n        visualElement &&\n        !visualElement.projection &&\n        ProjectionNodeConstructor &&\n        (visualElement.type === \"html\" || visualElement.type === \"svg\")\n    ) {\n        createProjectionNode(\n            visualElementRef.current!,\n            props,\n            ProjectionNodeConstructor,\n            initialLayoutGroupConfig\n        )\n    }\n\n    const isMounted = useRef(false)\n    useInsertionEffect(() => {\n        /**\n         * Check the component has already mounted before calling\n         * `update` unnecessarily. This ensures we skip the initial update.\n         */\n        if (visualElement && isMounted.current) {\n            visualElement.update(props, presenceContext)\n        }\n    })\n\n    /**\n     * Cache this value as we want to know whether HandoffAppearAnimations\n     * was present on initial render - it will be deleted after this.\n     */\n    const optimisedAppearId =\n        props[optimizedAppearDataAttribute as keyof typeof props]\n    const wantsHandoff = useRef(\n        Boolean(optimisedAppearId) &&\n            !window.MotionHandoffIsComplete?.(optimisedAppearId) &&\n            window.MotionHasOptimisedAnimation?.(optimisedAppearId)\n    )\n\n    useIsomorphicLayoutEffect(() => {\n        /**\n         * Track that this component has mounted. This is used to detect when\n         * LazyMotion features load after the component has already committed.\n         */\n        hasMountedOnce.current = true\n\n        if (!visualElement) return\n\n        isMounted.current = true\n        window.MotionIsMounted = true\n\n        visualElement.updateFeatures()\n        visualElement.scheduleRenderMicrotask()\n\n        /**\n         * Ideally this function would always run in a useEffect.\n         *\n         * However, if we have optimised appear animations to handoff from,\n         * it needs to happen synchronously to ensure there's no flash of\n         * incorrect styles in the event of a hydration error.\n         *\n         * So if we detect a situtation where optimised appear animations\n         * are running, we use useLayoutEffect to trigger animations.\n         */\n        if (wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges()\n        }\n    })\n\n    useEffect(() => {\n        if (!visualElement) return\n\n        if (!wantsHandoff.current && visualElement.animationState) {\n            visualElement.animationState.animateChanges()\n        }\n\n        if (wantsHandoff.current) {\n            // This ensures all future calls to animateChanges() in this component will run in useEffect\n            queueMicrotask(() => {\n                window.MotionHandoffMarkAsComplete?.(optimisedAppearId)\n            })\n\n            wantsHandoff.current = false\n        }\n\n        /**\n         * Now we've finished triggering animations for this element we\n         * can wipe the enteringChildren set for the next render.\n         */\n        visualElement.enteringChildren = undefined\n    })\n\n    return visualElement!\n}\n\nfunction createProjectionNode(\n    visualElement: VisualElement<any>,\n    props: MotionProps,\n    ProjectionNodeConstructor: any,\n    initialPromotionConfig?: InitialPromotionConfig\n) {\n    const {\n        layoutId,\n        layout,\n        drag,\n        dragConstraints,\n        layoutScroll,\n        layoutRoot,\n        layoutCrossfade,\n    } = props\n\n    visualElement.projection = new ProjectionNodeConstructor(\n        visualElement.latestValues,\n        props[\"data-framer-portal-id\"]\n            ? undefined\n            : getClosestProjectingNode(visualElement.parent)\n    ) as IProjectionNode\n\n    visualElement.projection.setOptions({\n        layoutId,\n        layout,\n        alwaysMeasureLayout:\n            Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement,\n        /**\n         * TODO: Update options in an effect. This could be tricky as it'll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there's no potential layout animations.\n         *\n         */\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        initialPromotionConfig,\n        crossfade: layoutCrossfade,\n        layoutScroll,\n        layoutRoot,\n    })\n}\n\nfunction getClosestProjectingNode(\n    visualElement?: VisualElement<\n        unknown,\n        unknown,\n        { allowProjection?: boolean }\n    >\n): IProjectionNode | undefined {\n    if (!visualElement) return undefined\n\n    return visualElement.options.allowProjection !== false\n        ? visualElement.projection\n        : getClosestProjectingNode(visualElement.parent)\n}\n"],"mappings":";;;;;;;;;;;AA0BgB,SAAAA,iBAAAC,SAAA,EAAAC,WAAA,EAAAC,KAAA,EAAAC,mBAAA,EAAAC,yBAAA,EAAAC,KAAA;;;;EAcZ,MAAAC,WAAA,GAAAC,UAAA,CAAAC,WAAA;EACA,MAAAC,eAAA,GAAAF,UAAA,CAAAG,eAAA;EACA,MAAAC,YAAA,GAAAJ,UAAA,CAAAK,mBAAA;EACA,MAAAC,mBAAA,GAAAF,YAAA,CAAAG,aAAA;EACA,MAAAC,cAAA,GAAAJ,YAAA,CAAAI,cAAA;EAEA,MAAAC,gBAAA,GAAAC,MAAA;EAIA;;;AAGG;EACH,MAAAC,cAAA,GAAAD,MAAA;EAEA;;AAEG;;EAKH,KAAAD,gBAAA,CAAAG,OAAA,IAAAhB,mBAAA;IACIa,gBAAA,CAAAG,OAAA,GAAAhB,mBAAA,CAAAH,SAAA;;;;;MAKIoB,qBAAA,EAAAX,eAAA,GACIA,eAAA,CAAAY,OAAA,aACA;;;;IAIP;IAED;;;;;AAKG;;MAECL,gBAAA,CAAAG,OAAA,CAAAG,sBAAA;;;EAIR,MAAAC,aAAA,GAAAP,gBAAA,CAAAG,OAAA;EAEA;;;AAGG;EACH,MAAAK,wBAAA,GAAAjB,UAAA,CAAAkB,wBAAA;EAEA,IAAAF,aAAA,I,2DAIIA,aAAA,CAAAG,IAAA,eAAAH,aAAA,CAAAG,IAAA;;;EAUJ,MAAAC,SAAA,GAAAV,MAAA;;IAEI;;;AAGG;IACH,IAAAM,aAAA,IAAAI,SAAA,CAAAR,OAAA;MACII,aAAA,CAAAK,MAAA,CAAA1B,KAAA,EAAAO,eAAA;;EAER;EAEA;;;AAGG;EACH,MAAAoB,iBAAA,GAAA3B,KAAA,CAAA4B,4BAAA;EAEA,MAAAC,YAAA,GAAAd,MAAA,CAAAe,OAAA,CAAAH,iBAAA,KAEQ,CAAAI,MAAA,CAAAC,uBAAA,GAAAL,iBAAA,KACAI,MAAA,CAAAE,2BAAA,GAAAN,iBAAA;;IAIJ;;;AAGG;IACHX,cAAA,CAAAC,OAAA;IAEA,KAAAI,aAAA,E;IAEAI,SAAA,CAAAR,OAAA;IACAc,MAAA,CAAAG,eAAA;;;IAKA;;;;;;;;;AASG;;MAECb,aAAA,CAAAc,cAAA,CAAAC,cAAA;;EAER;;IAGI,KAAAf,aAAA,E;;MAGIA,aAAA,CAAAc,cAAA,CAAAC,cAAA;;IAGJ,IAAAP,YAAA,CAAAZ,OAAA;;;QAGQc,MAAA,CAAAM,2BAAA,GAAAV,iBAAA;MACJ;MAEAE,YAAA,CAAAZ,OAAA;;IAGJ;;;AAGG;IACHI,aAAA,CAAAiB,gBAAA,GAAAC,SAAA;EACJ;EAEA,OAAAlB,aAAA;AACJ;AAEA,SAAAmB,qBAAAnB,aAAA,EAAArB,KAAA,EAAAE,yBAAA,EAAAuC,sBAAA;EAMI;IAAAC,QAAA;IAAAC,MAAA;IAAAC,IAAA;IAAAC,eAAA;IAAAC,YAAA;IAAAC,UAAA;IAAAC;EAAA,IAAAhD,KAAA;EAUAqB,aAAA,CAAA4B,UAAA,OAAA/C,yBAAA,CAAAmB,aAAA,CAAA6B,YAAA,EAAAlD,KAAA,4BAGQuC,SAAA,G;EAIRlB,aAAA,CAAA4B,UAAA,CAAAE,UAAA;;;IAGIC,mBAAA,EAAAtB,OAAA,CAAAc,IAAA,KAAAC,eAAA,IAAAQ,WAAA,CAAAR,eAAA;;IAGA;;;;;;AAMG;IACHS,aAAA,SAAAX,MAAA,gBAAAA,MAAA;;IAEAY,SAAA,EAAAP,eAAA;;;EAGH;AACL;AAEA,SAAAQ,yBAAAnC,aAAA;EAOI,KAAAA,aAAA,EAAoB,OAAAkB,SAAA;EAEpB,OAAAlB,aAAA,CAAAoC,OAAA,CAAAC,eAAA,a,2BAEIF,wBAAA,CAAAnC,aAAA,CAAAsC,MAAA;AACR","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}