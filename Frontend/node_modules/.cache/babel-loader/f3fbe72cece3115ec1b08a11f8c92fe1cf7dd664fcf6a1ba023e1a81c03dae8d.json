{"ast":null,"code":"\"use client\";\n\nimport { frame } from 'motion-dom';\nimport { MotionGlobalConfig } from 'motion-utils';\nimport { useRef, useEffect } from 'react';\nimport { useInstantLayoutTransition } from '../projection/use-instant-layout-transition.mjs';\nimport { useForceUpdate } from './use-force-update.mjs';\nfunction useInstantTransition() {\n  const [forceUpdate, forcedRenderCount] = useForceUpdate();\n  const startInstantLayoutTransition = useInstantLayoutTransition();\n  const unlockOnFrameRef = useRef(-1);\n  useEffect(() => {\n    /**\n     * Unblock after two animation frames, otherwise this will unblock too soon.\n     */\n    frame.postRender(() => frame.postRender(() => {\n      /**\n       * If the callback has been called again after the effect\n       * triggered this 2 frame delay, don't unblock animations. This\n       * prevents the previous effect from unblocking the current\n       * instant transition too soon. This becomes more likely when\n       * used in conjunction with React.startTransition().\n       */\n      if (forcedRenderCount !== unlockOnFrameRef.current) return;\n      MotionGlobalConfig.instantAnimations = false;\n    }));\n  }, [forcedRenderCount]);\n  return callback => {\n    startInstantLayoutTransition(() => {\n      MotionGlobalConfig.instantAnimations = true;\n      forceUpdate();\n      callback();\n      unlockOnFrameRef.current = forcedRenderCount + 1;\n    });\n  };\n}\nfunction disableInstantTransitions() {\n  MotionGlobalConfig.instantAnimations = false;\n}\nexport { disableInstantTransitions, useInstantTransition };","map":{"version":3,"names":["startInstantLayoutTransition","useInstantLayoutTransition","unlockOnFrameRef","useRef","forcedRenderCount","current","MotionGlobalConfig","instantAnimations","forceUpdate","callback"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/utils/use-instant-transition.ts"],"sourcesContent":["\"use client\"\n\nimport { frame } from \"motion-dom\"\nimport { MotionGlobalConfig } from \"motion-utils\"\nimport { useEffect, useRef } from \"react\"\nimport { useInstantLayoutTransition } from \"../projection/use-instant-layout-transition\"\nimport { useForceUpdate } from \"./use-force-update\"\n\nexport function useInstantTransition() {\n    const [forceUpdate, forcedRenderCount] = useForceUpdate()\n    const startInstantLayoutTransition = useInstantLayoutTransition()\n    const unlockOnFrameRef = useRef<number>(-1)\n\n    useEffect(() => {\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */\n        frame.postRender(() =>\n            frame.postRender(() => {\n                /**\n                 * If the callback has been called again after the effect\n                 * triggered this 2 frame delay, don't unblock animations. This\n                 * prevents the previous effect from unblocking the current\n                 * instant transition too soon. This becomes more likely when\n                 * used in conjunction with React.startTransition().\n                 */\n                if (forcedRenderCount !== unlockOnFrameRef.current) return\n                MotionGlobalConfig.instantAnimations = false\n            })\n        )\n    }, [forcedRenderCount])\n\n    return (callback: () => void) => {\n        startInstantLayoutTransition(() => {\n            MotionGlobalConfig.instantAnimations = true\n            forceUpdate()\n            callback()\n            unlockOnFrameRef.current = forcedRenderCount + 1\n        })\n    }\n}\n\nexport function disableInstantTransitions() {\n    MotionGlobalConfig.instantAnimations = false\n}\n"],"mappings":";;;;;;;;;EAUI,MAAAA,4BAAA,GAAAC,0BAAA;EACA,MAAAC,gBAAA,GAAAC,MAAA;;IAGI;;AAEG;;MAGK;;;;;;AAMG;MACH,IAAAC,iBAAA,KAAAF,gBAAA,CAAAG,OAAA,E;MACAC,kBAAA,CAAAC,iBAAA;;EAGZ,IAAAH,iBAAA;;;MAIQE,kBAAA,CAAAC,iBAAA;MACAC,WAAA;MACAC,QAAA;MACAP,gBAAA,CAAAG,OAAA,GAAAD,iBAAA;IACJ;EACJ;AACJ;;EAGIE,kBAAA,CAAAC,iBAAA;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}