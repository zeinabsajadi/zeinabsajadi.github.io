{"ast":null,"code":"\"use client\";\n\nimport { jsx, Fragment } from 'react/jsx-runtime';\nimport { useMemo, useRef, useState, useContext } from 'react';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { usePresence } from './use-presence.mjs';\nimport { onlyElements, getChildKey } from './utils.mjs';\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nconst AnimatePresence = ({\n  children,\n  custom,\n  initial = true,\n  onExitComplete,\n  presenceAffectsLayout = true,\n  mode = \"sync\",\n  propagate = false,\n  anchorX = \"left\",\n  anchorY = \"top\",\n  root\n}) => {\n  const [isParentPresent, safeToRemove] = usePresence(propagate);\n  /**\n   * Filter any children that aren't ReactElements. We can only track components\n   * between renders with a props.key.\n   */\n  const presentChildren = useMemo(() => onlyElements(children), [children]);\n  /**\n   * Track the keys of the currently rendered children. This is used to\n   * determine which children are exiting.\n   */\n  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);\n  /**\n   * If `initial={false}` we only want to pass this to components in the first render.\n   */\n  const isInitialRender = useRef(true);\n  /**\n   * A ref containing the currently present children. When all exit animations\n   * are complete, we use this to re-render the component with the latest children\n   * *committed* rather than the latest children *rendered*.\n   */\n  const pendingPresentChildren = useRef(presentChildren);\n  /**\n   * Track which exiting children have finished animating out.\n   */\n  const exitComplete = useConstant(() => new Map());\n  /**\n   * Track which components are currently processing exit to prevent duplicate processing.\n   */\n  const exitingComponents = useRef(new Set());\n  /**\n   * Save children to render as React state. To ensure this component is concurrent-safe,\n   * we check for exiting children via an effect.\n   */\n  const [diffedChildren, setDiffedChildren] = useState(presentChildren);\n  const [renderedChildren, setRenderedChildren] = useState(presentChildren);\n  useIsomorphicLayoutEffect(() => {\n    isInitialRender.current = false;\n    pendingPresentChildren.current = presentChildren;\n    /**\n     * Update complete status of exiting children.\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const key = getChildKey(renderedChildren[i]);\n      if (!presentKeys.includes(key)) {\n        if (exitComplete.get(key) !== true) {\n          exitComplete.set(key, false);\n        }\n      } else {\n        exitComplete.delete(key);\n        exitingComponents.current.delete(key);\n      }\n    }\n  }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")]);\n  const exitingChildren = [];\n  if (presentChildren !== diffedChildren) {\n    let nextChildren = [...presentChildren];\n    /**\n     * Loop through all the currently rendered components and decide which\n     * are exiting.\n     */\n    for (let i = 0; i < renderedChildren.length; i++) {\n      const child = renderedChildren[i];\n      const key = getChildKey(child);\n      if (!presentKeys.includes(key)) {\n        nextChildren.splice(i, 0, child);\n        exitingChildren.push(child);\n      }\n    }\n    /**\n     * If we're in \"wait\" mode, and we have exiting children, we want to\n     * only render these until they've all exited.\n     */\n    if (mode === \"wait\" && exitingChildren.length) {\n      nextChildren = exitingChildren;\n    }\n    setRenderedChildren(onlyElements(nextChildren));\n    setDiffedChildren(presentChildren);\n    /**\n     * Early return to ensure once we've set state with the latest diffed\n     * children, we can immediately re-render.\n     */\n    return null;\n  }\n  if (process.env.NODE_ENV !== \"production\" && mode === \"wait\" && renderedChildren.length > 1) {\n    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`);\n  }\n  /**\n   * If we've been provided a forceRender function by the LayoutGroupContext,\n   * we can use it to force a re-render amongst all surrounding components once\n   * all components have finished animating out.\n   */\n  const {\n    forceRender\n  } = useContext(LayoutGroupContext);\n  return jsx(Fragment, {\n    children: renderedChildren.map(child => {\n      const key = getChildKey(child);\n      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);\n      const onExit = () => {\n        if (exitingComponents.current.has(key)) {\n          return;\n        }\n        exitingComponents.current.add(key);\n        if (exitComplete.has(key)) {\n          exitComplete.set(key, true);\n        } else {\n          return;\n        }\n        let isEveryExitComplete = true;\n        exitComplete.forEach(isExitComplete => {\n          if (!isExitComplete) isEveryExitComplete = false;\n        });\n        if (isEveryExitComplete) {\n          forceRender?.();\n          setRenderedChildren(pendingPresentChildren.current);\n          propagate && safeToRemove?.();\n          onExitComplete && onExitComplete();\n        }\n      };\n      return jsx(PresenceChild, {\n        isPresent: isPresent,\n        initial: !isInitialRender.current || initial ? undefined : false,\n        custom: custom,\n        presenceAffectsLayout: presenceAffectsLayout,\n        mode: mode,\n        root: root,\n        onExitComplete: isPresent ? undefined : onExit,\n        anchorX: anchorX,\n        anchorY: anchorY,\n        children: child\n      }, key);\n    })\n  });\n};\nexport { AnimatePresence };","map":{"version":3,"names":["AnimatePresence","children","custom","initial","onExitComplete","presenceAffectsLayout","mode","propagate","anchorX","anchorY","root","presentChildren","useMemo","onlyElements","presentKeys","isParentPresent","map","getChildKey","isInitialRender","useRef","pendingPresentChildren","current","i","renderedChildren","length","exitComplete","set","key","delete","exitingComponents","join","diffedChildren","nextChildren","child","exitingChildren","push","setRenderedChildren","process","env","NODE_ENV","console","warn","isPresent","includes","add","has","forEach","isExitComplete","safeToRemove","jsx","PresenceChild","undefined"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/components/AnimatePresence/index.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useContext, useMemo, useRef, useState } from \"react\"\nimport { LayoutGroupContext } from \"../../context/LayoutGroupContext\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../../utils/use-isomorphic-effect\"\nimport { PresenceChild } from \"./PresenceChild\"\nimport { AnimatePresenceProps } from \"./types\"\nimport { usePresence } from \"./use-presence\"\nimport { ComponentKey, getChildKey, onlyElements } from \"./utils\"\n\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nexport const AnimatePresence = ({\n    children,\n    custom,\n    initial = true,\n    onExitComplete,\n    presenceAffectsLayout = true,\n    mode = \"sync\",\n    propagate = false,\n    anchorX = \"left\",\n    anchorY = \"top\",\n    root\n}: React.PropsWithChildren<AnimatePresenceProps>) => {\n    const [isParentPresent, safeToRemove] = usePresence(propagate)\n\n    /**\n     * Filter any children that aren't ReactElements. We can only track components\n     * between renders with a props.key.\n     */\n    const presentChildren = useMemo(() => onlyElements(children), [children])\n\n    /**\n     * Track the keys of the currently rendered children. This is used to\n     * determine which children are exiting.\n     */\n    const presentKeys =\n        propagate && !isParentPresent ? [] : presentChildren.map(getChildKey)\n\n    /**\n     * If `initial={false}` we only want to pass this to components in the first render.\n     */\n    const isInitialRender = useRef(true)\n\n    /**\n     * A ref containing the currently present children. When all exit animations\n     * are complete, we use this to re-render the component with the latest children\n     * *committed* rather than the latest children *rendered*.\n     */\n    const pendingPresentChildren = useRef(presentChildren)\n\n    /**\n     * Track which exiting children have finished animating out.\n     */\n    const exitComplete = useConstant(() => new Map<ComponentKey, boolean>())\n\n    /**\n     * Track which components are currently processing exit to prevent duplicate processing.\n     */\n    const exitingComponents = useRef(new Set<ComponentKey>())\n\n    /**\n     * Save children to render as React state. To ensure this component is concurrent-safe,\n     * we check for exiting children via an effect.\n     */\n    const [diffedChildren, setDiffedChildren] = useState(presentChildren)\n    const [renderedChildren, setRenderedChildren] = useState(presentChildren)\n\n    useIsomorphicLayoutEffect(() => {\n        isInitialRender.current = false\n        pendingPresentChildren.current = presentChildren\n\n        /**\n         * Update complete status of exiting children.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const key = getChildKey(renderedChildren[i])\n\n            if (!presentKeys.includes(key)) {\n                if (exitComplete.get(key) !== true) {\n                    exitComplete.set(key, false)\n                }\n            } else {\n                exitComplete.delete(key)\n                exitingComponents.current.delete(key)\n            }\n        }\n    }, [renderedChildren, presentKeys.length, presentKeys.join(\"-\")])\n\n    const exitingChildren: any[] = []\n\n    if (presentChildren !== diffedChildren) {\n        let nextChildren = [...presentChildren]\n\n        /**\n         * Loop through all the currently rendered components and decide which\n         * are exiting.\n         */\n        for (let i = 0; i < renderedChildren.length; i++) {\n            const child = renderedChildren[i]\n            const key = getChildKey(child)\n\n            if (!presentKeys.includes(key)) {\n                nextChildren.splice(i, 0, child)\n                exitingChildren.push(child)\n            }\n        }\n\n        /**\n         * If we're in \"wait\" mode, and we have exiting children, we want to\n         * only render these until they've all exited.\n         */\n        if (mode === \"wait\" && exitingChildren.length) {\n            nextChildren = exitingChildren\n        }\n\n        setRenderedChildren(onlyElements(nextChildren))\n        setDiffedChildren(presentChildren)\n\n        /**\n         * Early return to ensure once we've set state with the latest diffed\n         * children, we can immediately re-render.\n         */\n        return null\n    }\n\n    if (\n        process.env.NODE_ENV !== \"production\" &&\n        mode === \"wait\" &&\n        renderedChildren.length > 1\n    ) {\n        console.warn(\n            `You're attempting to animate multiple children within AnimatePresence, but its mode is set to \"wait\". This will lead to odd visual behaviour.`\n        )\n    }\n\n    /**\n     * If we've been provided a forceRender function by the LayoutGroupContext,\n     * we can use it to force a re-render amongst all surrounding components once\n     * all components have finished animating out.\n     */\n    const { forceRender } = useContext(LayoutGroupContext)\n\n    return (\n        <>\n            {renderedChildren.map((child) => {\n                const key = getChildKey(child)\n\n                const isPresent =\n                    propagate && !isParentPresent\n                        ? false\n                        : presentChildren === renderedChildren ||\n                          presentKeys.includes(key)\n\n                const onExit = () => {\n                    if (exitingComponents.current.has(key)) {\n                        return\n                    }\n                    exitingComponents.current.add(key)\n\n                    if (exitComplete.has(key)) {\n                        exitComplete.set(key, true)\n                    } else {\n                        return\n                    }\n\n                    let isEveryExitComplete = true\n                    exitComplete.forEach((isExitComplete) => {\n                        if (!isExitComplete) isEveryExitComplete = false\n                    })\n\n                    if (isEveryExitComplete) {\n                        forceRender?.()\n                        setRenderedChildren(pendingPresentChildren.current)\n\n                        propagate && safeToRemove?.()\n\n                        onExitComplete && onExitComplete()\n                    }\n                }\n\n                return (\n                    <PresenceChild\n                        key={key}\n                        isPresent={isPresent}\n                        initial={\n                            !isInitialRender.current || initial\n                                ? undefined\n                                : false\n                        }\n                        custom={custom}\n                        presenceAffectsLayout={presenceAffectsLayout}\n                        mode={mode}\n                        root={root}\n                        onExitComplete={isPresent ? undefined : onExit}\n                        anchorX={anchorX}\n                        anchorY={anchorY}\n                    >\n                        {child}\n                    </PresenceChild>\n                )\n            })}\n        </>\n    )\n}\n"],"mappings":";;;;;;;;;;;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCG;AACU,MAAAA,eAAA,GAAAA,CAAA;EAAAC,QAAA;EAAAC,MAAA;EAAAC,OAAA;EAAAC,cAAA;EAAAC,qBAAA;EAAAC,IAAA;EAAAC,SAAA;EAAAC,OAAA;EAAAC,OAAA;EAAAC;AAAA;;EAcT;;;AAGG;EACH,MAAAC,eAAA,GAAAC,OAAA,OAAAC,YAAA,CAAAZ,QAAA,IAAAA,QAAA;EAEA;;;AAGG;EACH,MAAAa,WAAA,GAAAP,SAAA,KAAAQ,eAAA,QAAAJ,eAAA,CAAAK,GAAA,CAAAC,WAAA;EAGA;;AAEG;EACH,MAAAC,eAAA,GAAAC,MAAA;EAEA;;;;AAIG;EACH,MAAAC,sBAAA,GAAAD,MAAA,CAAAR,eAAA;EAEA;;AAEG;;EAGH;;AAEG;;EAGH;;;AAGG;;;;IAKCO,eAAA,CAAAG,OAAA;IACAD,sBAAA,CAAAC,OAAA,GAAAV,eAAA;IAEA;;AAEG;IACH,SAAAW,CAAA,MAAAA,CAAA,GAAAC,gBAAA,CAAAC,MAAA,EAAAF,CAAA;;;;UAKYG,YAAA,CAAAC,GAAA,CAAAC,GAAA;;;QAGJF,YAAA,CAAAG,MAAA,CAAAD,GAAA;QACAE,iBAAA,CAAAR,OAAA,CAAAO,MAAA,CAAAD,GAAA;;;EAGZ,IAAAJ,gBAAA,EAAAT,WAAA,CAAAU,MAAA,EAAAV,WAAA,CAAAgB,IAAA;;EAIA,IAAAnB,eAAA,KAAAoB,cAAA;IACI,IAAAC,YAAA,OAAArB,eAAA;IAEA;;;AAGG;IACH,SAAAW,CAAA,MAAAA,CAAA,GAAAC,gBAAA,CAAAC,MAAA,EAAAF,CAAA;MACI,MAAAW,KAAA,GAAAV,gBAAA,CAAAD,CAAA;MACA,MAAAK,GAAA,GAAAV,WAAA,CAAAgB,KAAA;;;QAIIC,eAAA,CAAAC,IAAA,CAAAF,KAAA;;;IAIR;;;AAGG;;;;IAKHG,mBAAA,CAAAvB,YAAA,CAAAmB,YAAA;;IAGA;;;AAGG;IACH;;EAGJ,IAAAK,OAAA,CAAAC,GAAA,CAAAC,QAAA,qBAEIjC,IAAA,eACAiB,gBAAA,CAAAC,MAAA;IAEAgB,OAAA,CAAAC,IAAA;;EAKJ;;;;AAIG;;;;;;MAMS,MAAAd,GAAA,GAAAV,WAAA,CAAAgB,KAAA;MAEA,MAAAS,SAAA,GAAAnC,SAAA,KAAAQ,eAAA,GAEQ,Q,wCAEED,WAAA,CAAA6B,QAAA,CAAAhB,GAAA;;;;;QAMNE,iBAAA,CAAAR,OAAA,CAAAuB,GAAA,CAAAjB,GAAA;QAEA,IAAAF,YAAA,CAAAoB,GAAA,CAAAlB,GAAA;UACIF,YAAA,CAAAC,GAAA,CAAAC,GAAA;;;;;QAMJF,YAAA,CAAAqB,OAAA,CAAAC,cAAA;UACI,KAAAA,cAAA,E;QACJ;;;UAIIX,mBAAA,CAAAhB,sBAAA,CAAAC,OAAA;UAEAd,SAAA,IAAAyC,YAAA;;;MAIR;MAEA,OAAAC,GAAA,CAAAC,aAAA;QAAAR,SAAA,EAAAA,SAAA;QAAAvC,OAAA,GAAAe,eAAA,CAAAG,OAAA,IAAAlB,OAAA,GAMgBgD,SAAA,G;;;;;;;;;;;;AAiBhC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}