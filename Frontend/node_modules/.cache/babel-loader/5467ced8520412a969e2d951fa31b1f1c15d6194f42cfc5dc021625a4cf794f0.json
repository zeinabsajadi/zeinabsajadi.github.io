{"ast":null,"code":"import { invariant, millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { setStyle } from '../render/dom/style-set.mjs';\nimport { supportsScrollTimeline } from '../utils/supports/scroll-timeline.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { startWaapiAnimation } from './waapi/start-waapi-animation.mjs';\nimport { applyGeneratorOptions } from './waapi/utils/apply-generator.mjs';\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nclass NativeAnimation extends WithPromise {\n  constructor(options) {\n    super();\n    this.finishedTime = null;\n    this.isStopped = false;\n    /**\n     * Tracks a manually-set start time that takes precedence over WAAPI's\n     * dynamic startTime. This is cleared when play() or time setter is called,\n     * allowing WAAPI to take over timing.\n     */\n    this.manualStartTime = null;\n    if (!options) return;\n    const {\n      element,\n      name,\n      keyframes,\n      pseudoElement,\n      allowFlatten = false,\n      finalKeyframe,\n      onComplete\n    } = options;\n    this.isPseudoElement = Boolean(pseudoElement);\n    this.allowFlatten = allowFlatten;\n    this.options = options;\n    invariant(typeof options.type !== \"string\", `Mini animate() doesn't support \"type\" as a string.`, \"mini-spring\");\n    const transition = applyGeneratorOptions(options);\n    this.animation = startWaapiAnimation(element, name, keyframes, transition, pseudoElement);\n    if (transition.autoplay === false) {\n      this.animation.pause();\n    }\n    this.animation.onfinish = () => {\n      this.finishedTime = this.time;\n      if (!pseudoElement) {\n        const keyframe = getFinalKeyframe(keyframes, this.options, finalKeyframe, this.speed);\n        if (this.updateMotionValue) {\n          this.updateMotionValue(keyframe);\n        } else {\n          /**\n           * If we can, we want to commit the final style as set by the user,\n           * rather than the computed keyframe value supplied by the animation.\n           */\n          setStyle(element, name, keyframe);\n        }\n        this.animation.cancel();\n      }\n      onComplete?.();\n      this.notifyFinished();\n    };\n  }\n  play() {\n    if (this.isStopped) return;\n    this.manualStartTime = null;\n    this.animation.play();\n    if (this.state === \"finished\") {\n      this.updateFinished();\n    }\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish?.();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch (e) {}\n  }\n  stop() {\n    if (this.isStopped) return;\n    this.isStopped = true;\n    const {\n      state\n    } = this;\n    if (state === \"idle\" || state === \"finished\") {\n      return;\n    }\n    if (this.updateMotionValue) {\n      this.updateMotionValue();\n    } else {\n      this.commitStyles();\n    }\n    if (!this.isPseudoElement) this.cancel();\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n  commitStyles() {\n    const element = this.options?.element;\n    if (!this.isPseudoElement && element?.isConnected) {\n      this.animation.commitStyles?.();\n    }\n  }\n  get duration() {\n    const duration = this.animation.effect?.getComputedTiming?.().duration || 0;\n    return millisecondsToSeconds(Number(duration));\n  }\n  get iterationDuration() {\n    const {\n      delay = 0\n    } = this.options || {};\n    return this.duration + millisecondsToSeconds(delay);\n  }\n  get time() {\n    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);\n  }\n  set time(newTime) {\n    this.manualStartTime = null;\n    this.finishedTime = null;\n    this.animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    // Allow backwards playback after finishing\n    if (newSpeed < 0) this.finishedTime = null;\n    this.animation.playbackRate = newSpeed;\n  }\n  get state() {\n    return this.finishedTime !== null ? \"finished\" : this.animation.playState;\n  }\n  get startTime() {\n    return this.manualStartTime ?? Number(this.animation.startTime);\n  }\n  set startTime(newStartTime) {\n    this.manualStartTime = this.animation.startTime = newStartTime;\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n  attachTimeline({\n    timeline,\n    observe\n  }) {\n    if (this.allowFlatten) {\n      this.animation.effect?.updateTiming({\n        easing: \"linear\"\n      });\n    }\n    this.animation.onfinish = null;\n    if (timeline && supportsScrollTimeline()) {\n      this.animation.timeline = timeline;\n      return noop;\n    } else {\n      return observe(this);\n    }\n  }\n}\nexport { NativeAnimation };","map":{"version":3,"names":["NativeAnimation","WithPromise","constructor","options","finishedTime","isStopped","manualStartTime","element","name","keyframes","pseudoElement","allowFlatten","finalKeyframe","onComplete","isPseudoElement","Boolean","invariant","type","transition","applyGeneratorOptions","animation","startWaapiAnimation","autoplay","pause","onfinish","time","keyframe","getFinalKeyframe","speed","updateMotionValue","setStyle","cancel","notifyFinished","play","state","updateFinished","complete","finish","e","stop","commitStyles","isConnected","duration","effect","getComputedTiming","millisecondsToSeconds","Number","iterationDuration","delay","currentTime","newTime","secondsToMilliseconds","playbackRate","newSpeed","playState","startTime","newStartTime","attachTimeline","timeline","observe","updateTiming","easing","supportsScrollTimeline","noop"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/animation/NativeAnimation.ts"],"sourcesContent":["import {\n    invariant,\n    millisecondsToSeconds,\n    noop,\n    secondsToMilliseconds,\n} from \"motion-utils\"\nimport { setStyle } from \"../render/dom/style-set\"\nimport { supportsScrollTimeline } from \"../utils/supports/scroll-timeline\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnyResolvedKeyframe,\n    DOMValueAnimationOptions,\n    TimelineWithFallback,\n} from \"./types\"\nimport { WithPromise } from \"./utils/WithPromise\"\nimport { startWaapiAnimation } from \"./waapi/start-waapi-animation\"\nimport { applyGeneratorOptions } from \"./waapi/utils/apply-generator\"\n\nexport interface NativeAnimationOptions<V extends AnyResolvedKeyframe = number>\n    extends DOMValueAnimationOptions<V> {\n    pseudoElement?: string\n    startTime?: number\n}\n\n/**\n * NativeAnimation implements AnimationPlaybackControls for the browser's Web Animations API.\n */\nexport class NativeAnimation<T extends AnyResolvedKeyframe>\n    extends WithPromise\n    implements AnimationPlaybackControlsWithThen\n{\n    /**\n     * The interfaced Web Animation API animation\n     */\n    protected animation: Animation\n\n    protected finishedTime: number | null = null\n\n    protected options: NativeAnimationOptions\n\n    private allowFlatten: boolean\n\n    private isStopped = false\n\n    private isPseudoElement: boolean\n\n    /**\n     * Tracks a manually-set start time that takes precedence over WAAPI's\n     * dynamic startTime. This is cleared when play() or time setter is called,\n     * allowing WAAPI to take over timing.\n     */\n    protected manualStartTime: number | null = null\n\n    constructor(options?: NativeAnimationOptions) {\n        super()\n\n        if (!options) return\n\n        const {\n            element,\n            name,\n            keyframes,\n            pseudoElement,\n            allowFlatten = false,\n            finalKeyframe,\n            onComplete,\n        } = options as any\n\n        this.isPseudoElement = Boolean(pseudoElement)\n\n        this.allowFlatten = allowFlatten\n        this.options = options\n\n        invariant(\n            typeof options.type !== \"string\",\n            `Mini animate() doesn't support \"type\" as a string.`,\n            \"mini-spring\"\n        )\n\n        const transition = applyGeneratorOptions(options)\n\n        this.animation = startWaapiAnimation(\n            element,\n            name,\n            keyframes,\n            transition,\n            pseudoElement\n        )\n\n        if (transition.autoplay === false) {\n            this.animation.pause()\n        }\n\n        this.animation.onfinish = () => {\n            this.finishedTime = this.time\n\n            if (!pseudoElement) {\n                const keyframe = getFinalKeyframe(\n                    keyframes as any,\n                    this.options as any,\n                    finalKeyframe,\n                    this.speed\n                )\n                if (this.updateMotionValue) {\n                    this.updateMotionValue(keyframe)\n                } else {\n                    /**\n                     * If we can, we want to commit the final style as set by the user,\n                     * rather than the computed keyframe value supplied by the animation.\n                     */\n                    setStyle(element, name, keyframe)\n                }\n\n                this.animation.cancel()\n            }\n\n            onComplete?.()\n            this.notifyFinished()\n        }\n    }\n\n    updateMotionValue?(value?: T): void\n\n    play() {\n        if (this.isStopped) return\n\n        this.manualStartTime = null\n        this.animation.play()\n\n        if (this.state === \"finished\") {\n            this.updateFinished()\n        }\n    }\n\n    pause() {\n        this.animation.pause()\n    }\n\n    complete() {\n        this.animation.finish?.()\n    }\n\n    cancel() {\n        try {\n            this.animation.cancel()\n        } catch (e) {}\n    }\n\n    stop() {\n        if (this.isStopped) return\n        this.isStopped = true\n        const { state } = this\n\n        if (state === \"idle\" || state === \"finished\") {\n            return\n        }\n\n        if (this.updateMotionValue) {\n            this.updateMotionValue()\n        } else {\n            this.commitStyles()\n        }\n\n        if (!this.isPseudoElement) this.cancel()\n    }\n\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * In this method, we commit styles back to the DOM before cancelling\n     * the animation.\n     *\n     * This is designed to be overridden by NativeAnimationExtended, which\n     * will create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to also correctly calculate velocity for any subsequent animation\n     * while deferring the commit until the next animation frame.\n     */\n    protected commitStyles() {\n        const element = this.options?.element\n        if (!this.isPseudoElement && element?.isConnected) {\n            this.animation.commitStyles?.()\n        }\n    }\n\n    get duration() {\n        const duration =\n            this.animation.effect?.getComputedTiming?.().duration || 0\n\n        return millisecondsToSeconds(Number(duration))\n    }\n\n    get iterationDuration() {\n        const { delay = 0 } = this.options || {}\n        return this.duration + millisecondsToSeconds(delay)\n    }\n\n    get time() {\n        return millisecondsToSeconds(Number(this.animation.currentTime) || 0)\n    }\n\n    set time(newTime: number) {\n        this.manualStartTime = null\n        this.finishedTime = null\n        this.animation.currentTime = secondsToMilliseconds(newTime)\n    }\n\n    /**\n     * The playback speed of the animation.\n     * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n     */\n    get speed() {\n        return this.animation.playbackRate\n    }\n\n    set speed(newSpeed: number) {\n        // Allow backwards playback after finishing\n        if (newSpeed < 0) this.finishedTime = null\n\n        this.animation.playbackRate = newSpeed\n    }\n\n    get state() {\n        return this.finishedTime !== null\n            ? \"finished\"\n            : this.animation.playState\n    }\n\n    get startTime() {\n        return this.manualStartTime ?? Number(this.animation.startTime)\n    }\n\n    set startTime(newStartTime: number) {\n        this.manualStartTime = this.animation.startTime = newStartTime\n    }\n\n    /**\n     * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n     */\n    attachTimeline({ timeline, observe }: TimelineWithFallback): VoidFunction {\n        if (this.allowFlatten) {\n            this.animation.effect?.updateTiming({ easing: \"linear\" })\n        }\n\n        this.animation.onfinish = null\n\n        if (timeline && supportsScrollTimeline()) {\n            this.animation.timeline = timeline as any\n\n            return noop<void>\n        } else {\n            return observe(this)\n        }\n    }\n}\n"],"mappings":";;;;;;;;AAyBA;;AAEG;AACG,MAAOA,eACT,SAAQC,WAAW;EAyBnBC,YAAYC,OAAgC;IACxC,KAAK,EAAE;IAlBD,IAAY,CAAAC,YAAA,GAAkB,IAAI;IAMpC,IAAS,CAAAC,SAAA,GAAG,KAAK;IAIzB;;;;AAIG;IACO,IAAe,CAAAC,eAAA,GAAkB,IAAI;IAK3C,IAAI,CAACH,OAAO,EAAE;IAEd,MAAM;MACFI,OAAO;MACPC,IAAI;MACJC,SAAS;MACTC,aAAa;MACbC,YAAY,GAAG,KAAK;MACpBC,aAAa;MACbC;IAAU,CACb,GAAGV,OAAc;IAElB,IAAI,CAACW,eAAe,GAAGC,OAAO,CAACL,aAAa,CAAC;IAE7C,IAAI,CAACC,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACR,OAAO,GAAGA,OAAO;IAEtBa,SAAS,CACL,OAAOb,OAAO,CAACc,IAAI,KAAK,QAAQ,EAChC,oDAAoD,EACpD,aAAa,CAChB;IAED,MAAMC,UAAU,GAAGC,qBAAqB,CAAChB,OAAO,CAAC;IAEjD,IAAI,CAACiB,SAAS,GAAGC,mBAAmB,CAChCd,OAAO,EACPC,IAAI,EACJC,SAAS,EACTS,UAAU,EACVR,aAAa,CAChB;IAED,IAAIQ,UAAU,CAACI,QAAQ,KAAK,KAAK,EAAE;MAC/B,IAAI,CAACF,SAAS,CAACG,KAAK,EAAE;;IAG1B,IAAI,CAACH,SAAS,CAACI,QAAQ,GAAG,MAAK;MAC3B,IAAI,CAACpB,YAAY,GAAG,IAAI,CAACqB,IAAI;MAE7B,IAAI,CAACf,aAAa,EAAE;QAChB,MAAMgB,QAAQ,GAAGC,gBAAgB,CAC7BlB,SAAgB,EAChB,IAAI,CAACN,OAAc,EACnBS,aAAa,EACb,IAAI,CAACgB,KAAK,CACb;QACD,IAAI,IAAI,CAACC,iBAAiB,EAAE;UACxB,IAAI,CAACA,iBAAiB,CAACH,QAAQ,CAAC;SACnC,MAAM;UACH;;;AAGG;UACHI,QAAQ,CAACvB,OAAO,EAAEC,IAAI,EAAEkB,QAAQ,CAAC;;QAGrC,IAAI,CAACN,SAAS,CAACW,MAAM,EAAE;;MAG3BlB,UAAU,IAAI;MACd,IAAI,CAACmB,cAAc,EAAE;IACzB,CAAC;;EAKLC,IAAIA,CAAA;IACA,IAAI,IAAI,CAAC5B,SAAS,EAAE;IAEpB,IAAI,CAACC,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACc,SAAS,CAACa,IAAI,EAAE;IAErB,IAAI,IAAI,CAACC,KAAK,KAAK,UAAU,EAAE;MAC3B,IAAI,CAACC,cAAc,EAAE;;;EAI7BZ,KAAKA,CAAA;IACD,IAAI,CAACH,SAAS,CAACG,KAAK,EAAE;;EAG1Ba,QAAQA,CAAA;IACJ,IAAI,CAAChB,SAAS,CAACiB,MAAM,IAAI;;EAG7BN,MAAMA,CAAA;IACF,IAAI;MACA,IAAI,CAACX,SAAS,CAACW,MAAM,EAAE;KAC1B,CAAC,OAAOO,CAAC,EAAE;;EAGhBC,IAAIA,CAAA;IACA,IAAI,IAAI,CAAClC,SAAS,EAAE;IACpB,IAAI,CAACA,SAAS,GAAG,IAAI;IACrB,MAAM;MAAE6B;IAAK,CAAE,GAAG,IAAI;IAEtB,IAAIA,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,UAAU,EAAE;MAC1C;;IAGJ,IAAI,IAAI,CAACL,iBAAiB,EAAE;MACxB,IAAI,CAACA,iBAAiB,EAAE;KAC3B,MAAM;MACH,IAAI,CAACW,YAAY,EAAE;;IAGvB,IAAI,CAAC,IAAI,CAAC1B,eAAe,EAAE,IAAI,CAACiB,MAAM,EAAE;;EAG5C;;;;;;;;;;;AAWG;EACOS,YAAYA,CAAA;IAClB,MAAMjC,OAAO,GAAG,IAAI,CAACJ,OAAO,EAAEI,OAAO;IACrC,IAAI,CAAC,IAAI,CAACO,eAAe,IAAIP,OAAO,EAAEkC,WAAW,EAAE;MAC/C,IAAI,CAACrB,SAAS,CAACoB,YAAY,IAAI;;;EAIvC,IAAIE,QAAQA,CAAA;IACR,MAAMA,QAAQ,GACV,IAAI,CAACtB,SAAS,CAACuB,MAAM,EAAEC,iBAAiB,IAAI,CAACF,QAAQ,IAAI,CAAC;IAE9D,OAAOG,qBAAqB,CAACC,MAAM,CAACJ,QAAQ,CAAC,CAAC;;EAGlD,IAAIK,iBAAiBA,CAAA;IACjB,MAAM;MAAEC,KAAK,GAAG;IAAC,CAAE,GAAG,IAAI,CAAC7C,OAAO,IAAI,EAAE;IACxC,OAAO,IAAI,CAACuC,QAAQ,GAAGG,qBAAqB,CAACG,KAAK,CAAC;;EAGvD,IAAIvB,IAAIA,CAAA;IACJ,OAAOoB,qBAAqB,CAACC,MAAM,CAAC,IAAI,CAAC1B,SAAS,CAAC6B,WAAW,CAAC,IAAI,CAAC,CAAC;;EAGzE,IAAIxB,IAAIA,CAACyB,OAAe;IACpB,IAAI,CAAC5C,eAAe,GAAG,IAAI;IAC3B,IAAI,CAACF,YAAY,GAAG,IAAI;IACxB,IAAI,CAACgB,SAAS,CAAC6B,WAAW,GAAGE,qBAAqB,CAACD,OAAO,CAAC;;EAG/D;;;AAGG;EACH,IAAItB,KAAKA,CAAA;IACL,OAAO,IAAI,CAACR,SAAS,CAACgC,YAAY;;EAGtC,IAAIxB,KAAKA,CAACyB,QAAgB;;IAEtB,IAAIA,QAAQ,GAAG,CAAC,EAAE,IAAI,CAACjD,YAAY,GAAG,IAAI;IAE1C,IAAI,CAACgB,SAAS,CAACgC,YAAY,GAAGC,QAAQ;;EAG1C,IAAInB,KAAKA,CAAA;IACL,OAAO,IAAI,CAAC9B,YAAY,KAAK,IAAI,GAC3B,UAAU,GACV,IAAI,CAACgB,SAAS,CAACkC,SAAS;;EAGlC,IAAIC,SAASA,CAAA;IACT,OAAO,IAAI,CAACjD,eAAe,IAAIwC,MAAM,CAAC,IAAI,CAAC1B,SAAS,CAACmC,SAAS,CAAC;;EAGnE,IAAIA,SAASA,CAACC,YAAoB;IAC9B,IAAI,CAAClD,eAAe,GAAG,IAAI,CAACc,SAAS,CAACmC,SAAS,GAAGC,YAAY;;EAGlE;;AAEG;EACHC,cAAcA,CAAC;IAAEC,QAAQ;IAAEC;EAAO,CAAwB;IACtD,IAAI,IAAI,CAAChD,YAAY,EAAE;MACnB,IAAI,CAACS,SAAS,CAACuB,MAAM,EAAEiB,YAAY,CAAC;QAAEC,MAAM,EAAE;MAAQ,CAAE,CAAC;;IAG7D,IAAI,CAACzC,SAAS,CAACI,QAAQ,GAAG,IAAI;IAE9B,IAAIkC,QAAQ,IAAII,sBAAsB,EAAE,EAAE;MACtC,IAAI,CAAC1C,SAAS,CAACsC,QAAQ,GAAGA,QAAe;MAEzC,OAAOK,IAAU;KACpB,MAAM;MACH,OAAOJ,OAAO,CAAC,IAAI,CAAC;;;AAG/B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}