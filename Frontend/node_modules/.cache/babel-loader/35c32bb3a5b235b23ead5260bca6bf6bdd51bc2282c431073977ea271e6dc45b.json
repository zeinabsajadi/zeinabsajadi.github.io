{"ast":null,"code":"import { MotionGlobalConfig, noop } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { JSAnimation } from './JSAnimation.mjs';\nimport { getFinalKeyframe } from './keyframes/get-final.mjs';\nimport { KeyframeResolver, flushKeyframeResolvers } from './keyframes/KeyframesResolver.mjs';\nimport { NativeAnimationExtended } from './NativeAnimationExtended.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { makeAnimationInstant } from './utils/make-animation-instant.mjs';\nimport { WithPromise } from './utils/WithPromise.mjs';\nimport { supportsBrowserAnimation } from './waapi/supports/waapi.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass AsyncMotionValueAnimation extends WithPromise {\n  constructor({\n    autoplay = true,\n    delay = 0,\n    type = \"keyframes\",\n    repeat = 0,\n    repeatDelay = 0,\n    repeatType = \"loop\",\n    keyframes,\n    name,\n    motionValue,\n    element,\n    ...options\n  }) {\n    super();\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    this.stop = () => {\n      if (this._animation) {\n        this._animation.stop();\n        this.stopTimeline?.();\n      }\n      this.keyframeResolver?.cancel();\n    };\n    this.createdAt = time.now();\n    const optionsWithDefaults = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      name,\n      motionValue,\n      element,\n      ...options\n    };\n    const KeyframeResolver$1 = element?.KeyframeResolver || KeyframeResolver;\n    this.keyframeResolver = new KeyframeResolver$1(keyframes, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue, element);\n    this.keyframeResolver?.scheduleResolve();\n  }\n  onKeyframesResolved(keyframes, finalKeyframe, options, sync) {\n    this.keyframeResolver = undefined;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      isHandoff,\n      onUpdate\n    } = options;\n    this.resolvedAt = time.now();\n    /**\n     * If we can't animate this value with the resolved keyframes\n     * then we should complete it immediately.\n     */\n    if (!canAnimate(keyframes, name, type, velocity)) {\n      if (MotionGlobalConfig.instantAnimations || !delay) {\n        onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe));\n      }\n      keyframes[0] = keyframes[keyframes.length - 1];\n      makeAnimationInstant(options);\n      options.repeat = 0;\n    }\n    /**\n     * Resolve startTime for the animation.\n     *\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first committed frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    const startTime = sync ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : undefined;\n    const resolvedOptions = {\n      startTime,\n      finalKeyframe,\n      ...options,\n      keyframes\n    };\n    /**\n     * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n     * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n     * optimised animation.\n     */\n    const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions);\n    const element = resolvedOptions.motionValue?.owner?.current;\n    const animation = useWaapi ? new NativeAnimationExtended({\n      ...resolvedOptions,\n      element\n    }) : new JSAnimation(resolvedOptions);\n    animation.finished.then(() => {\n      this.notifyFinished();\n    }).catch(noop);\n    if (this.pendingTimeline) {\n      this.stopTimeline = animation.attachTimeline(this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    }\n    this._animation = animation;\n  }\n  get finished() {\n    if (!this._animation) {\n      return this._finished;\n    } else {\n      return this.animation.finished;\n    }\n  }\n  then(onResolve, _onReject) {\n    return this.finished.finally(onResolve).then(() => {});\n  }\n  get animation() {\n    if (!this._animation) {\n      this.keyframeResolver?.resume();\n      flushKeyframeResolvers();\n    }\n    return this._animation;\n  }\n  get duration() {\n    return this.animation.duration;\n  }\n  get iterationDuration() {\n    return this.animation.iterationDuration;\n  }\n  get time() {\n    return this.animation.time;\n  }\n  set time(newTime) {\n    this.animation.time = newTime;\n  }\n  get speed() {\n    return this.animation.speed;\n  }\n  get state() {\n    return this.animation.state;\n  }\n  set speed(newSpeed) {\n    this.animation.speed = newSpeed;\n  }\n  get startTime() {\n    return this.animation.startTime;\n  }\n  attachTimeline(timeline) {\n    if (this._animation) {\n      this.stopTimeline = this.animation.attachTimeline(timeline);\n    } else {\n      this.pendingTimeline = timeline;\n    }\n    return () => this.stop();\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.complete();\n  }\n  cancel() {\n    if (this._animation) {\n      this.animation.cancel();\n    }\n    this.keyframeResolver?.cancel();\n  }\n}\nexport { AsyncMotionValueAnimation };","map":{"version":3,"names":["MAX_RESOLVE_DELAY","AsyncMotionValueAnimation","WithPromise","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","keyframes","name","motionValue","element","options","stop","_animation","stopTimeline","keyframeResolver","cancel","createdAt","time","now","optionsWithDefaults","KeyframeResolver$1","KeyframeResolver","resolvedKeyframes","finalKeyframe","forced","onKeyframesResolved","scheduleResolve","sync","undefined","velocity","isHandoff","onUpdate","resolvedAt","canAnimate","MotionGlobalConfig","instantAnimations","getFinalKeyframe","length","makeAnimationInstant","startTime","resolvedOptions","useWaapi","supportsBrowserAnimation","owner","current","animation","NativeAnimationExtended","JSAnimation","finished","then","notifyFinished","catch","noop","pendingTimeline","attachTimeline","_finished","onResolve","_onReject","finally","resume","flushKeyframeResolvers","duration","iterationDuration","newTime","speed","state","newSpeed","timeline","play","pause","complete"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/animation/AsyncMotionValueAnimation.ts"],"sourcesContent":["import { MotionGlobalConfig, noop } from \"motion-utils\"\nimport { time } from \"../frameloop/sync-time\"\nimport { JSAnimation } from \"./JSAnimation\"\nimport { getFinalKeyframe } from \"./keyframes/get-final\"\nimport {\n    KeyframeResolver as DefaultKeyframeResolver,\n    flushKeyframeResolvers,\n    ResolvedKeyframes,\n} from \"./keyframes/KeyframesResolver\"\nimport { NativeAnimationExtended } from \"./NativeAnimationExtended\"\nimport {\n    AnimationPlaybackControls,\n    AnyResolvedKeyframe,\n    TimelineWithFallback,\n    ValueAnimationOptions,\n} from \"./types\"\nimport { canAnimate } from \"./utils/can-animate\"\nimport { makeAnimationInstant } from \"./utils/make-animation-instant\"\nimport { WithPromise } from \"./utils/WithPromise\"\nimport { supportsBrowserAnimation } from \"./waapi/supports/waapi\"\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40\n\ntype OptionsWithoutKeyframes<T extends AnyResolvedKeyframe> = Omit<\n    ValueAnimationOptions<T>,\n    \"keyframes\"\n>\n\nexport class AsyncMotionValueAnimation<T extends AnyResolvedKeyframe>\n    extends WithPromise\n    implements AnimationPlaybackControls\n{\n    private createdAt: number\n\n    private resolvedAt: number | undefined\n\n    private _animation: AnimationPlaybackControls | undefined\n\n    private pendingTimeline: TimelineWithFallback | undefined\n\n    private keyframeResolver: DefaultKeyframeResolver | undefined\n\n    private stopTimeline: VoidFunction | undefined\n\n    constructor({\n        autoplay = true,\n        delay = 0,\n        type = \"keyframes\",\n        repeat = 0,\n        repeatDelay = 0,\n        repeatType = \"loop\",\n        keyframes,\n        name,\n        motionValue,\n        element,\n        ...options\n    }: ValueAnimationOptions<T>) {\n        super()\n\n        this.createdAt = time.now()\n\n        const optionsWithDefaults: OptionsWithoutKeyframes<T> = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            name,\n            motionValue,\n            element,\n            ...options,\n        }\n\n        const KeyframeResolver =\n            element?.KeyframeResolver || DefaultKeyframeResolver\n\n        this.keyframeResolver = new KeyframeResolver(\n            keyframes,\n            (\n                resolvedKeyframes: ResolvedKeyframes<T>,\n                finalKeyframe: T,\n                forced: boolean\n            ) =>\n                this.onKeyframesResolved(\n                    resolvedKeyframes,\n                    finalKeyframe,\n                    optionsWithDefaults,\n                    !forced\n                ),\n            name,\n            motionValue,\n            element\n        )\n        this.keyframeResolver?.scheduleResolve()\n    }\n\n    onKeyframesResolved(\n        keyframes: ResolvedKeyframes<T>,\n        finalKeyframe: T,\n        options: OptionsWithoutKeyframes<T>,\n        sync: boolean\n    ) {\n        this.keyframeResolver = undefined\n\n        const { name, type, velocity, delay, isHandoff, onUpdate } = options\n        this.resolvedAt = time.now()\n\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!canAnimate(keyframes, name, type, velocity)) {\n            if (MotionGlobalConfig.instantAnimations || !delay) {\n                onUpdate?.(getFinalKeyframe(keyframes, options, finalKeyframe))\n            }\n\n            keyframes[0] = keyframes[keyframes.length - 1]\n\n            makeAnimationInstant(options)\n            options.repeat = 0\n        }\n\n        /**\n         * Resolve startTime for the animation.\n         *\n         * This method uses the createdAt and resolvedAt to calculate the\n         * animation startTime. *Ideally*, we would use the createdAt time as t=0\n         * as the following frame would then be the first frame of the animation in\n         * progress, which would feel snappier.\n         *\n         * However, if there's a delay (main thread work) between the creation of\n         * the animation and the first committed frame, we prefer to use resolvedAt\n         * to avoid a sudden jump into the animation.\n         */\n        const startTime = sync\n            ? !this.resolvedAt\n                ? this.createdAt\n                : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n                ? this.resolvedAt\n                : this.createdAt\n            : undefined\n\n        const resolvedOptions = {\n            startTime,\n            finalKeyframe,\n            ...options,\n            keyframes,\n        }\n\n        /**\n         * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via\n         * WAAPI. Therefore, this animation must be JS to ensure it runs \"under\" the\n         * optimised animation.\n         */\n        const useWaapi = !isHandoff && supportsBrowserAnimation(resolvedOptions)\n        const element = resolvedOptions.motionValue?.owner?.current\n\n        const animation = useWaapi\n                ? new NativeAnimationExtended({\n                      ...resolvedOptions,\n                      element,\n                  } as any)\n                : new JSAnimation(resolvedOptions)\n\n        animation.finished.then(() => {\n            this.notifyFinished()\n        }).catch(noop)\n\n        if (this.pendingTimeline) {\n            this.stopTimeline = animation.attachTimeline(this.pendingTimeline)\n            this.pendingTimeline = undefined\n        }\n\n        this._animation = animation\n    }\n\n    get finished() {\n        if (!this._animation) {\n            return this._finished\n        } else {\n            return this.animation.finished\n        }\n    }\n\n    then(onResolve: VoidFunction, _onReject?: VoidFunction) {\n        return this.finished.finally(onResolve).then(() => {})\n    }\n\n    get animation(): AnimationPlaybackControls {\n        if (!this._animation) {\n            this.keyframeResolver?.resume()\n            flushKeyframeResolvers()\n        }\n\n        return this._animation!\n    }\n\n    get duration() {\n        return this.animation.duration\n    }\n\n    get iterationDuration() {\n        return this.animation.iterationDuration\n    }\n\n    get time() {\n        return this.animation.time\n    }\n\n    set time(newTime: number) {\n        this.animation.time = newTime\n    }\n\n    get speed() {\n        return this.animation.speed\n    }\n\n    get state() {\n        return this.animation.state\n    }\n\n    set speed(newSpeed: number) {\n        this.animation.speed = newSpeed\n    }\n\n    get startTime() {\n        return this.animation.startTime\n    }\n\n    attachTimeline(timeline: TimelineWithFallback) {\n        if (this._animation) {\n            this.stopTimeline = this.animation.attachTimeline(timeline)\n        } else {\n            this.pendingTimeline = timeline\n        }\n\n        return () => this.stop()\n    }\n\n    play() {\n        this.animation.play()\n    }\n\n    pause() {\n        this.animation.pause()\n    }\n\n    complete() {\n        this.animation.complete()\n    }\n\n    cancel() {\n        if (this._animation) {\n            this.animation.cancel()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n\n    /**\n     * Bound to support return animation.stop pattern\n     */\n    stop = () => {\n        if (this._animation) {\n            this._animation.stop()\n            this.stopTimeline?.()\n        }\n\n        this.keyframeResolver?.cancel()\n    }\n}\n"],"mappings":";;;;;;;;;;;AAqBA;;;;;;;AAOG;AACH,MAAMA,iBAAiB,GAAG,EAAE;AAOtB,MAAOC,yBACT,SAAQC,WAAW;EAenBC,YAAY;IACRC,QAAQ,GAAG,IAAI;IACfC,KAAK,GAAG,CAAC;IACTC,IAAI,GAAG,WAAW;IAClBC,MAAM,GAAG,CAAC;IACVC,WAAW,GAAG,CAAC;IACfC,UAAU,GAAG,MAAM;IACnBC,SAAS;IACTC,IAAI;IACJC,WAAW;IACXC,OAAO;IACP,GAAGC;EAAO,CACa;IACvB,KAAK,EAAE;IA2MX;;AAEG;IACH,IAAI,CAAAC,IAAA,GAAG,MAAK;MACR,IAAI,IAAI,CAACC,UAAU,EAAE;QACjB,IAAI,CAACA,UAAU,CAACD,IAAI,EAAE;QACtB,IAAI,CAACE,YAAY,IAAI;;MAGzB,IAAI,CAACC,gBAAgB,EAAEC,MAAM,EAAE;IACnC,CAAC;IAnNG,IAAI,CAACC,SAAS,GAAGC,IAAI,CAACC,GAAG,EAAE;IAE3B,MAAMC,mBAAmB,GAA+B;MACpDnB,QAAQ;MACRC,KAAK;MACLC,IAAI;MACJC,MAAM;MACNC,WAAW;MACXC,UAAU;MACVE,IAAI;MACJC,WAAW;MACXC,OAAO;MACP,GAAGC;KACN;IAED,MAAMU,kBAAgB,GAClBX,OAAO,EAAEY,gBAAgB,IAAIA,gBAAuB;IAExD,IAAI,CAACP,gBAAgB,GAAG,IAAIM,kBAAgB,CACxCd,SAAS,EACT,CACIgB,iBAAuC,EACvCC,aAAgB,EAChBC,MAAe,KAEf,IAAI,CAACC,mBAAmB,CACpBH,iBAAiB,EACjBC,aAAa,EACbJ,mBAAmB,EACnB,CAACK,MAAM,CACV,EACLjB,IAAI,EACJC,WAAW,EACXC,OAAO,CACV;IACD,IAAI,CAACK,gBAAgB,EAAEY,eAAe,EAAE;;EAG5CD,mBAAmBA,CACfnB,SAA+B,EAC/BiB,aAAgB,EAChBb,OAAmC,EACnCiB,IAAa;IAEb,IAAI,CAACb,gBAAgB,GAAGc,SAAS;IAEjC,MAAM;MAAErB,IAAI;MAAEL,IAAI;MAAE2B,QAAQ;MAAE5B,KAAK;MAAE6B,SAAS;MAAEC;IAAQ,CAAE,GAAGrB,OAAO;IACpE,IAAI,CAACsB,UAAU,GAAGf,IAAI,CAACC,GAAG,EAAE;IAE5B;;;AAGG;IACH,IAAI,CAACe,UAAU,CAAC3B,SAAS,EAAEC,IAAI,EAAEL,IAAI,EAAE2B,QAAQ,CAAC,EAAE;MAC9C,IAAIK,kBAAkB,CAACC,iBAAiB,IAAI,CAAClC,KAAK,EAAE;QAChD8B,QAAQ,GAAGK,gBAAgB,CAAC9B,SAAS,EAAEI,OAAO,EAAEa,aAAa,CAAC,CAAC;;MAGnEjB,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAACA,SAAS,CAAC+B,MAAM,GAAG,CAAC,CAAC;MAE9CC,oBAAoB,CAAC5B,OAAO,CAAC;MAC7BA,OAAO,CAACP,MAAM,GAAG,CAAC;;IAGtB;;;;;;;;;;;AAWG;IACH,MAAMoC,SAAS,GAAGZ,IAAI,GAChB,CAAC,IAAI,CAACK,UAAU,GACZ,IAAI,CAAChB,SAAS,GACd,IAAI,CAACgB,UAAU,GAAG,IAAI,CAAChB,SAAS,GAAGpB,iBAAiB,GACpD,IAAI,CAACoC,UAAU,GACf,IAAI,CAAChB,SAAS,GAClBY,SAAS;IAEf,MAAMY,eAAe,GAAG;MACpBD,SAAS;MACThB,aAAa;MACb,GAAGb,OAAO;MACVJ;KACH;IAED;;;;AAIG;IACH,MAAMmC,QAAQ,GAAG,CAACX,SAAS,IAAIY,wBAAwB,CAACF,eAAe,CAAC;IACxE,MAAM/B,OAAO,GAAG+B,eAAe,CAAChC,WAAW,EAAEmC,KAAK,EAAEC,OAAO;IAE3D,MAAMC,SAAS,GAAGJ,QAAQ,GAChB,IAAIK,uBAAuB,CAAC;MACxB,GAAGN,eAAe;MAClB/B;KACI,CAAC,GACT,IAAIsC,WAAW,CAACP,eAAe,CAAC;IAE1CK,SAAS,CAACG,QAAQ,CAACC,IAAI,CAAC,MAAK;MACzB,IAAI,CAACC,cAAc,EAAE;IACzB,CAAC,CAAC,CAACC,KAAK,CAACC,IAAI,CAAC;IAEd,IAAI,IAAI,CAACC,eAAe,EAAE;MACtB,IAAI,CAACxC,YAAY,GAAGgC,SAAS,CAACS,cAAc,CAAC,IAAI,CAACD,eAAe,CAAC;MAClE,IAAI,CAACA,eAAe,GAAGzB,SAAS;;IAGpC,IAAI,CAAChB,UAAU,GAAGiC,SAAS;;EAG/B,IAAIG,QAAQA,CAAA;IACR,IAAI,CAAC,IAAI,CAACpC,UAAU,EAAE;MAClB,OAAO,IAAI,CAAC2C,SAAS;KACxB,MAAM;MACH,OAAO,IAAI,CAACV,SAAS,CAACG,QAAQ;;;EAItCC,IAAIA,CAACO,SAAuB,EAAEC,SAAwB;IAClD,OAAO,IAAI,CAACT,QAAQ,CAACU,OAAO,CAACF,SAAS,CAAC,CAACP,IAAI,CAAC,MAAO,EAAC,CAAC;;EAG1D,IAAIJ,SAASA,CAAA;IACT,IAAI,CAAC,IAAI,CAACjC,UAAU,EAAE;MAClB,IAAI,CAACE,gBAAgB,EAAE6C,MAAM,EAAE;MAC/BC,sBAAsB,EAAE;;IAG5B,OAAO,IAAI,CAAChD,UAAW;;EAG3B,IAAIiD,QAAQA,CAAA;IACR,OAAO,IAAI,CAAChB,SAAS,CAACgB,QAAQ;;EAGlC,IAAIC,iBAAiBA,CAAA;IACjB,OAAO,IAAI,CAACjB,SAAS,CAACiB,iBAAiB;;EAG3C,IAAI7C,IAAIA,CAAA;IACJ,OAAO,IAAI,CAAC4B,SAAS,CAAC5B,IAAI;;EAG9B,IAAIA,IAAIA,CAAC8C,OAAe;IACpB,IAAI,CAAClB,SAAS,CAAC5B,IAAI,GAAG8C,OAAO;;EAGjC,IAAIC,KAAKA,CAAA;IACL,OAAO,IAAI,CAACnB,SAAS,CAACmB,KAAK;;EAG/B,IAAIC,KAAKA,CAAA;IACL,OAAO,IAAI,CAACpB,SAAS,CAACoB,KAAK;;EAG/B,IAAID,KAAKA,CAACE,QAAgB;IACtB,IAAI,CAACrB,SAAS,CAACmB,KAAK,GAAGE,QAAQ;;EAGnC,IAAI3B,SAASA,CAAA;IACT,OAAO,IAAI,CAACM,SAAS,CAACN,SAAS;;EAGnCe,cAAcA,CAACa,QAA8B;IACzC,IAAI,IAAI,CAACvD,UAAU,EAAE;MACjB,IAAI,CAACC,YAAY,GAAG,IAAI,CAACgC,SAAS,CAACS,cAAc,CAACa,QAAQ,CAAC;KAC9D,MAAM;MACH,IAAI,CAACd,eAAe,GAAGc,QAAQ;;IAGnC,OAAO,MAAM,IAAI,CAACxD,IAAI,EAAE;;EAG5ByD,IAAIA,CAAA;IACA,IAAI,CAACvB,SAAS,CAACuB,IAAI,EAAE;;EAGzBC,KAAKA,CAAA;IACD,IAAI,CAACxB,SAAS,CAACwB,KAAK,EAAE;;EAG1BC,QAAQA,CAAA;IACJ,IAAI,CAACzB,SAAS,CAACyB,QAAQ,EAAE;;EAG7BvD,MAAMA,CAAA;IACF,IAAI,IAAI,CAACH,UAAU,EAAE;MACjB,IAAI,CAACiC,SAAS,CAAC9B,MAAM,EAAE;;IAG3B,IAAI,CAACD,gBAAgB,EAAEC,MAAM,EAAE;;AActC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}