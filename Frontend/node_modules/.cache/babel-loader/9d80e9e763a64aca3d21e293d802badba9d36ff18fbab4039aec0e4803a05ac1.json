{"ast":null,"code":"/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap();\nconst fireObserverCallback = entry => {\n  const callback = observerCallbacks.get(entry.target);\n  callback && callback(entry);\n};\nconst fireAllObserverCallbacks = entries => {\n  entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver({\n  root,\n  ...options\n}) {\n  const lookupRoot = root || document;\n  /**\n   * If we don't have an observer lookup map for this root, create one.\n   */\n  if (!observers.has(lookupRoot)) {\n    observers.set(lookupRoot, {});\n  }\n  const rootObservers = observers.get(lookupRoot);\n  const key = JSON.stringify(options);\n  /**\n   * If we don't have an observer for this combination of root and settings,\n   * create one.\n   */\n  if (!rootObservers[key]) {\n    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, {\n      root,\n      ...options\n    });\n  }\n  return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n  const rootInteresectionObserver = initIntersectionObserver(options);\n  observerCallbacks.set(element, callback);\n  rootInteresectionObserver.observe(element);\n  return () => {\n    observerCallbacks.delete(element);\n    rootInteresectionObserver.unobserve(element);\n  };\n}\nexport { observeIntersection };","map":{"version":3,"names":["observerCallbacks","WeakMap","observers","fireObserverCallback","entry","callback","get","target","fireAllObserverCallbacks","entries","forEach","initIntersectionObserver","root","options","lookupRoot","document","has","set","rootObservers","key","JSON","stringify","IntersectionObserver","observeIntersection","element","rootInteresectionObserver","observe","delete","unobserve"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/motion/features/viewport/observers.ts"],"sourcesContent":["type IntersectionHandler = (entry: IntersectionObserverEntry) => void\n\ninterface ElementIntersectionObservers {\n    [key: string]: IntersectionObserver\n}\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nconst observerCallbacks = new WeakMap<Element, IntersectionHandler>()\n\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nconst observers = new WeakMap<\n    Element | Document,\n    ElementIntersectionObservers\n>()\n\nconst fireObserverCallback = (entry: IntersectionObserverEntry) => {\n    const callback = observerCallbacks.get(entry.target)\n    callback && callback(entry)\n}\n\nconst fireAllObserverCallbacks: IntersectionObserverCallback = (entries) => {\n    entries.forEach(fireObserverCallback)\n}\n\nfunction initIntersectionObserver({\n    root,\n    ...options\n}: IntersectionObserverInit): IntersectionObserver {\n    const lookupRoot = root || document\n\n    /**\n     * If we don't have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {})\n    }\n    const rootObservers = observers.get(lookupRoot)!\n\n    const key = JSON.stringify(options)\n\n    /**\n     * If we don't have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(\n            fireAllObserverCallbacks,\n            { root, ...options }\n        )\n    }\n\n    return rootObservers[key]\n}\n\nexport function observeIntersection(\n    element: Element,\n    options: IntersectionObserverInit,\n    callback: IntersectionHandler\n) {\n    const rootInteresectionObserver = initIntersectionObserver(options)\n\n    observerCallbacks.set(element, callback)\n    rootInteresectionObserver.observe(element)\n\n    return () => {\n        observerCallbacks.delete(element)\n        rootInteresectionObserver.unobserve(element)\n    }\n}\n"],"mappings":"AAMA;;;;AAIG;AACH,MAAMA,iBAAiB,GAAG,IAAIC,OAAO,EAAgC;AAErE;;;;AAIG;AACH,MAAMC,SAAS,GAAG,IAAID,OAAO,EAG1B;AAEH,MAAME,oBAAoB,GAAIC,KAAgC,IAAI;EAC9D,MAAMC,QAAQ,GAAGL,iBAAiB,CAACM,GAAG,CAACF,KAAK,CAACG,MAAM,CAAC;EACpDF,QAAQ,IAAIA,QAAQ,CAACD,KAAK,CAAC;AAC/B,CAAC;AAED,MAAMI,wBAAwB,GAAkCC,OAAO,IAAI;EACvEA,OAAO,CAACC,OAAO,CAACP,oBAAoB,CAAC;AACzC,CAAC;AAED,SAASQ,wBAAwBA,CAAC;EAC9BC,IAAI;EACJ,GAAGC;AAAO,CACa;EACvB,MAAMC,UAAU,GAAGF,IAAI,IAAIG,QAAQ;EAEnC;;AAEG;EACH,IAAI,CAACb,SAAS,CAACc,GAAG,CAACF,UAAU,CAAC,EAAE;IAC5BZ,SAAS,CAACe,GAAG,CAACH,UAAU,EAAE,EAAE,CAAC;;EAEjC,MAAMI,aAAa,GAAGhB,SAAS,CAACI,GAAG,CAACQ,UAAU,CAAE;EAEhD,MAAMK,GAAG,GAAGC,IAAI,CAACC,SAAS,CAACR,OAAO,CAAC;EAEnC;;;AAGG;EACH,IAAI,CAACK,aAAa,CAACC,GAAG,CAAC,EAAE;IACrBD,aAAa,CAACC,GAAG,CAAC,GAAG,IAAIG,oBAAoB,CACzCd,wBAAwB,EACxB;MAAEI,IAAI;MAAE,GAAGC;IAAO,CAAE,CACvB;;EAGL,OAAOK,aAAa,CAACC,GAAG,CAAC;AAC7B;SAEgBI,mBAAmBA,CAC/BC,OAAgB,EAChBX,OAAiC,EACjCR,QAA6B;EAE7B,MAAMoB,yBAAyB,GAAGd,wBAAwB,CAACE,OAAO,CAAC;EAEnEb,iBAAiB,CAACiB,GAAG,CAACO,OAAO,EAAEnB,QAAQ,CAAC;EACxCoB,yBAAyB,CAACC,OAAO,CAACF,OAAO,CAAC;EAE1C,OAAO,MAAK;IACRxB,iBAAiB,CAAC2B,MAAM,CAACH,OAAO,CAAC;IACjCC,yBAAyB,CAACG,SAAS,CAACJ,OAAO,CAAC;EAChD,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}