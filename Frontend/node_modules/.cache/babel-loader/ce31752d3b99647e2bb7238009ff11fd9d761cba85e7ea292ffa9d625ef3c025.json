{"ast":null,"code":"/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { ClampToEdgeWrapping, LinearFilter, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, RGBAFormat, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, MeshBasicMaterial, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType } from 'three';\nconst getBufferForType = (type, width, height) => {\n  let out;\n  switch (type) {\n    case UnsignedByteType:\n      out = new Uint8ClampedArray(width * height * 4);\n      break;\n    case HalfFloatType:\n      out = new Uint16Array(width * height * 4);\n      break;\n    case UnsignedIntType:\n      out = new Uint32Array(width * height * 4);\n      break;\n    case ByteType:\n      out = new Int8Array(width * height * 4);\n      break;\n    case ShortType:\n      out = new Int16Array(width * height * 4);\n      break;\n    case IntType:\n      out = new Int32Array(width * height * 4);\n      break;\n    case FloatType:\n      out = new Float32Array(width * height * 4);\n      break;\n    default:\n      throw new Error('Unsupported data type');\n  }\n  return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n  if (_canReadPixelsResult !== undefined) return _canReadPixelsResult;\n  const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n  renderer.setRenderTarget(testRT);\n  const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({\n    color: 0xffffff\n  }));\n  renderer.render(mesh, camera);\n  renderer.setRenderTarget(null);\n  const out = getBufferForType(type, testRT.width, testRT.height);\n  renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n  testRT.dispose();\n  mesh.geometry.dispose();\n  mesh.material.dispose();\n  _canReadPixelsResult = out[0] !== 0;\n  return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n  _renderer;\n  _rendererIsDisposable = false;\n  _material;\n  _scene;\n  _camera;\n  _quad;\n  _renderTarget;\n  _width;\n  _height;\n  _type;\n  _colorSpace;\n  _supportsReadPixels = true;\n  /**\n   * Constructs a new QuadRenderer\n   *\n   * @param options Parameters for this QuadRenderer\n   */\n  constructor(options) {\n    this._width = options.width;\n    this._height = options.height;\n    this._type = options.type;\n    this._colorSpace = options.colorSpace;\n    const rtOptions = {\n      // fixed options\n      format: RGBAFormat,\n      depthBuffer: false,\n      stencilBuffer: false,\n      // user options\n      type: this._type,\n      // set in class property\n      colorSpace: this._colorSpace,\n      // set in class property\n      anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n      generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n      magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : LinearFilter,\n      minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : LinearFilter,\n      samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n      wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : ClampToEdgeWrapping,\n      wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : ClampToEdgeWrapping\n    };\n    this._material = options.material;\n    if (options.renderer) {\n      this._renderer = options.renderer;\n    } else {\n      this._renderer = QuadRenderer.instantiateRenderer();\n      this._rendererIsDisposable = true;\n    }\n    this._scene = new Scene();\n    this._camera = new OrthographicCamera();\n    this._camera.position.set(0, 0, 10);\n    this._camera.left = -0.5;\n    this._camera.right = 0.5;\n    this._camera.top = 0.5;\n    this._camera.bottom = -0.5;\n    this._camera.updateProjectionMatrix();\n    if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n      let alternativeType;\n      switch (this._type) {\n        case HalfFloatType:\n          alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n          break;\n      }\n      if (alternativeType !== undefined) {\n        console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n        this._type = alternativeType;\n      } else {\n        this._supportsReadPixels = false;\n        console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n      }\n    }\n    this._quad = new Mesh(new PlaneGeometry(), this._material);\n    this._quad.geometry.computeBoundingBox();\n    this._scene.add(this._quad);\n    this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n    this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : UVMapping;\n  }\n  /**\n   * Instantiates a temporary renderer\n   *\n   * @returns\n   */\n  static instantiateRenderer() {\n    const renderer = new WebGLRenderer();\n    renderer.setSize(128, 128);\n    // renderer.outputColorSpace = SRGBColorSpace\n    // renderer.toneMapping = LinearToneMapping\n    // renderer.debug.checkShaderErrors = false\n    // this._rendererIsDisposable = true\n    return renderer;\n  }\n  /**\n   * Renders the input texture using the specified material\n   */\n  render = () => {\n    this._renderer.setRenderTarget(this._renderTarget);\n    try {\n      this._renderer.render(this._scene, this._camera);\n    } catch (e) {\n      this._renderer.setRenderTarget(null);\n      throw e;\n    }\n    this._renderer.setRenderTarget(null);\n  };\n  /**\n   * Obtains a Buffer containing the rendered texture.\n   *\n   * @throws Error if the browser cannot read pixels from this RenderTarget type.\n   * @returns a TypedArray containing RGBA values from this renderer\n   */\n  toArray() {\n    if (!this._supportsReadPixels) throw new Error('Can\\'t read pixels in this browser');\n    const out = getBufferForType(this._type, this._width, this._height);\n    this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n    return out;\n  }\n  /**\n   * Performs a readPixel operation in the renderTarget\n   * and returns a DataTexture containing the read data\n   *\n   * @param options options\n   * @returns\n   */\n  toDataTexture(options) {\n    const returnValue = new DataTexture(\n    // fixed values\n    this.toArray(), this.width, this.height, RGBAFormat, this._type,\n    // user values\n    options?.mapping || UVMapping, options?.wrapS || ClampToEdgeWrapping, options?.wrapT || ClampToEdgeWrapping, options?.magFilter || LinearFilter, options?.minFilter || LinearFilter, options?.anisotropy || 1,\n    // fixed value\n    LinearSRGBColorSpace);\n    // set this afterwards, we can't set it in constructor\n    returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n    return returnValue;\n  }\n  /**\n   * If using a disposable renderer, it will dispose it.\n   */\n  disposeOnDemandRenderer() {\n    this._renderer.setRenderTarget(null);\n    if (this._rendererIsDisposable) {\n      this._renderer.dispose();\n      this._renderer.forceContextLoss();\n    }\n  }\n  /**\n   * Will dispose of **all** assets used by this renderer.\n   *\n   *\n   * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n   * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n   * or are otherwise done with it.\n   *\n   * @example\n   * ```js\n   * const loader = new HDRJPGLoader(renderer)\n   * const result = await loader.loadAsync('gainmap.jpeg')\n   * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n   * // DO NOT dispose the renderTarget here,\n   * // it is used directly in the material\n   * result.dispose()\n   * ```\n   *\n   * @example\n   * ```js\n   * const loader = new HDRJPGLoader(renderer)\n   * const pmremGenerator = new PMREMGenerator( renderer );\n   * const result = await loader.loadAsync('gainmap.jpeg')\n   * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n   * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n   * // renderTarget can be disposed here\n   * // because it was used to generate a PMREM texture\n   * result.dispose(true)\n   * ```\n   */\n  dispose(disposeRenderTarget) {\n    this.disposeOnDemandRenderer();\n    if (disposeRenderTarget) {\n      this.renderTarget.dispose();\n    }\n    // dispose shader material texture uniforms\n    if (this.material instanceof ShaderMaterial) {\n      Object.values(this.material.uniforms).forEach(v => {\n        if (v.value instanceof Texture) v.value.dispose();\n      });\n    }\n    // dispose other material properties\n    Object.values(this.material).forEach(value => {\n      if (value instanceof Texture) value.dispose();\n    });\n    this.material.dispose();\n    this._quad.geometry.dispose();\n  }\n  /**\n   * Width of the texture\n   */\n  get width() {\n    return this._width;\n  }\n  set width(value) {\n    this._width = value;\n    this._renderTarget.setSize(this._width, this._height);\n  }\n  /**\n   * Height of the texture\n   */\n  get height() {\n    return this._height;\n  }\n  set height(value) {\n    this._height = value;\n    this._renderTarget.setSize(this._width, this._height);\n  }\n  /**\n   * The renderer used\n   */\n  get renderer() {\n    return this._renderer;\n  }\n  /**\n   * The `WebGLRenderTarget` used.\n   */\n  get renderTarget() {\n    return this._renderTarget;\n  }\n  set renderTarget(value) {\n    this._renderTarget = value;\n    this._width = value.width;\n    this._height = value.height;\n    // this._type = value.texture.type\n  }\n  /**\n   * The `Material` used.\n   */\n  get material() {\n    return this._material;\n  }\n  /**\n   *\n   */\n  get type() {\n    return this._type;\n  }\n  get colorSpace() {\n    return this._colorSpace;\n  }\n}\nexport { QuadRenderer as Q };","map":{"version":3,"names":["ClampToEdgeWrapping","LinearFilter","Scene","OrthographicCamera","HalfFloatType","FloatType","Mesh","PlaneGeometry","WebGLRenderTarget","RGBAFormat","UVMapping","WebGLRenderer","DataTexture","LinearSRGBColorSpace","ShaderMaterial","Texture","MeshBasicMaterial","IntType","ShortType","ByteType","UnsignedIntType","UnsignedByteType","getBufferForType","type","width","height","out","Uint8ClampedArray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float32Array","Error","_canReadPixelsResult","canReadPixels","renderer","camera","renderTargetOptions","undefined","testRT","setRenderTarget","mesh","color","render","readRenderTargetPixels","dispose","geometry","material","QuadRenderer","_renderer","_rendererIsDisposable","_material","_scene","_camera","_quad","_renderTarget","_width","_height","_type","_colorSpace","_supportsReadPixels","constructor","options","colorSpace","rtOptions","format","depthBuffer","stencilBuffer","anisotropy","generateMipmaps","magFilter","minFilter","samples","wrapS","wrapT","instantiateRenderer","position","set","left","right","top","bottom","updateProjectionMatrix","alternativeType","extensions","has","console","warn","computeBoundingBox","add","texture","mapping","setSize","e","toArray","toDataTexture","returnValue","disposeOnDemandRenderer","forceContextLoss","disposeRenderTarget","renderTarget","Object","values","uniforms","forEach","v","value","Q"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/@react-three/drei/node_modules/@monogrid/gainmap-js/dist/QuadRenderer-Bj1xl_EK.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { ClampToEdgeWrapping, LinearFilter, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, RGBAFormat, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, MeshBasicMaterial, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    _renderer;\n    _rendererIsDisposable = false;\n    _material;\n    _scene;\n    _camera;\n    _quad;\n    _renderTarget;\n    _width;\n    _height;\n    _type;\n    _colorSpace;\n    _supportsReadPixels = true;\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: options.renderTargetOptions?.anisotropy !== undefined ? options.renderTargetOptions?.anisotropy : 1,\n            generateMipmaps: options.renderTargetOptions?.generateMipmaps !== undefined ? options.renderTargetOptions?.generateMipmaps : false,\n            magFilter: options.renderTargetOptions?.magFilter !== undefined ? options.renderTargetOptions?.magFilter : LinearFilter,\n            minFilter: options.renderTargetOptions?.minFilter !== undefined ? options.renderTargetOptions?.minFilter : LinearFilter,\n            samples: options.renderTargetOptions?.samples !== undefined ? options.renderTargetOptions?.samples : undefined,\n            wrapS: options.renderTargetOptions?.wrapS !== undefined ? options.renderTargetOptions?.wrapS : ClampToEdgeWrapping,\n            wrapT: options.renderTargetOptions?.wrapT !== undefined ? options.renderTargetOptions?.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = options.renderTargetOptions?.mapping !== undefined ? options.renderTargetOptions?.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Renders the input texture using the specified material\n     */\n    render = () => {\n        this._renderer.setRenderTarget(this._renderTarget);\n        try {\n            this._renderer.render(this._scene, this._camera);\n        }\n        catch (e) {\n            this._renderer.setRenderTarget(null);\n            throw e;\n        }\n        this._renderer.setRenderTarget(null);\n    };\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @param options options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        options?.mapping || UVMapping, options?.wrapS || ClampToEdgeWrapping, options?.wrapT || ClampToEdgeWrapping, options?.magFilter || LinearFilter, options?.minFilter || LinearFilter, options?.anisotropy || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = options?.generateMipmaps !== undefined ? options?.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}