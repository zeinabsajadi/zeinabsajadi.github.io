{"ast":null,"code":"import { Feature } from 'motion-dom';\nimport { observeIntersection } from './observers.mjs';\nconst thresholdNames = {\n  some: 0,\n  all: 1\n};\nclass InViewFeature extends Feature {\n  constructor() {\n    super(...arguments);\n    this.hasEnteredView = false;\n    this.isInView = false;\n  }\n  startObserver() {\n    this.unmount();\n    const {\n      viewport = {}\n    } = this.node.getProps();\n    const {\n      root,\n      margin: rootMargin,\n      amount = \"some\",\n      once\n    } = viewport;\n    const options = {\n      root: root ? root.current : undefined,\n      rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    const onIntersectionUpdate = entry => {\n      const {\n        isIntersecting\n      } = entry;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (this.isInView === isIntersecting) return;\n      this.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && this.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        this.hasEnteredView = true;\n      }\n      if (this.node.animationState) {\n        this.node.animationState.setActive(\"whileInView\", isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      const {\n        onViewportEnter,\n        onViewportLeave\n      } = this.node.getProps();\n      const callback = isIntersecting ? onViewportEnter : onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(this.node.current, options, onIntersectionUpdate);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver === \"undefined\") return;\n    const {\n      props,\n      prevProps\n    } = this.node;\n    const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(hasViewportOptionChanged(props, prevProps));\n    if (hasOptionsChanged) {\n      this.startObserver();\n    }\n  }\n  unmount() {}\n}\nfunction hasViewportOptionChanged({\n  viewport = {}\n}, {\n  viewport: prevViewport = {}\n} = {}) {\n  return name => viewport[name] !== prevViewport[name];\n}\nexport { InViewFeature };","map":{"version":3,"names":["thresholdNames","some","all","InViewFeature","Feature","constructor","hasEnteredView","isInView","startObserver","unmount","viewport","node","getProps","root","margin","rootMargin","amount","once","options","current","undefined","threshold","onIntersectionUpdate","entry","isIntersecting","animationState","setActive","onViewportEnter","onViewportLeave","callback","observeIntersection","mount","update","IntersectionObserver","props","prevProps","hasOptionsChanged","hasViewportOptionChanged","prevViewport","name"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/motion/features/viewport/index.ts"],"sourcesContent":["import { Feature } from \"motion-dom\"\nimport { MotionProps } from \"../../types\"\nimport { observeIntersection } from \"./observers\"\n\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n}\n\nexport class InViewFeature extends Feature<Element> {\n    private hasEnteredView = false\n\n    private isInView = false\n\n    private startObserver() {\n        this.unmount()\n\n        const { viewport = {} } = this.node.getProps()\n        const { root, margin: rootMargin, amount = \"some\", once } = viewport\n\n        const options = {\n            root: root ? root.current : undefined,\n            rootMargin,\n            threshold:\n                typeof amount === \"number\" ? amount : thresholdNames[amount],\n        }\n\n        const onIntersectionUpdate = (entry: IntersectionObserverEntry) => {\n            const { isIntersecting } = entry\n\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (this.isInView === isIntersecting) return\n\n            this.isInView = isIntersecting\n\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && this.hasEnteredView) {\n                return\n            } else if (isIntersecting) {\n                this.hasEnteredView = true\n            }\n\n            if (this.node.animationState) {\n                this.node.animationState.setActive(\n                    \"whileInView\",\n                    isIntersecting\n                )\n            }\n\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const { onViewportEnter, onViewportLeave } = this.node.getProps()\n            const callback = isIntersecting ? onViewportEnter : onViewportLeave\n            callback && callback(entry)\n        }\n\n        return observeIntersection(\n            this.node.current!,\n            options,\n            onIntersectionUpdate\n        )\n    }\n\n    mount() {\n        this.startObserver()\n    }\n\n    update() {\n        if (typeof IntersectionObserver === \"undefined\") return\n\n        const { props, prevProps } = this.node\n        const hasOptionsChanged = [\"amount\", \"margin\", \"root\"].some(\n            hasViewportOptionChanged(props, prevProps)\n        )\n\n        if (hasOptionsChanged) {\n            this.startObserver()\n        }\n    }\n\n    unmount() {}\n}\n\nfunction hasViewportOptionChanged(\n    { viewport = {} }: MotionProps,\n    { viewport: prevViewport = {} }: MotionProps = {}\n) {\n    return (name: keyof typeof viewport) =>\n        viewport[name] !== prevViewport[name]\n}\n"],"mappings":";;AAIA,MAAMA,cAAc,GAAG;EACnBC,IAAI,EAAE,CAAC;EACPC,GAAG,EAAE;CACR;AAEK,MAAOC,aAAc,SAAQC,OAAgB;EAAnDC,YAAA;;IACY,IAAc,CAAAC,cAAA,GAAG,KAAK;IAEtB,IAAQ,CAAAC,QAAA,GAAG,KAAK;;EAEhBC,aAAaA,CAAA;IACjB,IAAI,CAACC,OAAO,EAAE;IAEd,MAAM;MAAEC,QAAQ,GAAG;IAAE,CAAE,GAAG,IAAI,CAACC,IAAI,CAACC,QAAQ,EAAE;IAC9C,MAAM;MAAEC,IAAI;MAAEC,MAAM,EAAEC,UAAU;MAAEC,MAAM,GAAG,MAAM;MAAEC;IAAI,CAAE,GAAGP,QAAQ;IAEpE,MAAMQ,OAAO,GAAG;MACZL,IAAI,EAAEA,IAAI,GAAGA,IAAI,CAACM,OAAO,GAAGC,SAAS;MACrCL,UAAU;MACVM,SAAS,EACL,OAAOL,MAAM,KAAK,QAAQ,GAAGA,MAAM,GAAGhB,cAAc,CAACgB,MAAM;KAClE;IAED,MAAMM,oBAAoB,GAAIC,KAAgC,IAAI;MAC9D,MAAM;QAAEC;MAAc,CAAE,GAAGD,KAAK;MAEhC;;AAEG;MACH,IAAI,IAAI,CAAChB,QAAQ,KAAKiB,cAAc,EAAE;MAEtC,IAAI,CAACjB,QAAQ,GAAGiB,cAAc;MAE9B;;;AAGG;MACH,IAAIP,IAAI,IAAI,CAACO,cAAc,IAAI,IAAI,CAAClB,cAAc,EAAE;QAChD;OACH,MAAM,IAAIkB,cAAc,EAAE;QACvB,IAAI,CAAClB,cAAc,GAAG,IAAI;;MAG9B,IAAI,IAAI,CAACK,IAAI,CAACc,cAAc,EAAE;QAC1B,IAAI,CAACd,IAAI,CAACc,cAAc,CAACC,SAAS,CAC9B,aAAa,EACbF,cAAc,CACjB;;MAGL;;;AAGG;MACH,MAAM;QAAEG,eAAe;QAAEC;MAAe,CAAE,GAAG,IAAI,CAACjB,IAAI,CAACC,QAAQ,EAAE;MACjE,MAAMiB,QAAQ,GAAGL,cAAc,GAAGG,eAAe,GAAGC,eAAe;MACnEC,QAAQ,IAAIA,QAAQ,CAACN,KAAK,CAAC;IAC/B,CAAC;IAED,OAAOO,mBAAmB,CACtB,IAAI,CAACnB,IAAI,CAACQ,OAAQ,EAClBD,OAAO,EACPI,oBAAoB,CACvB;;EAGLS,KAAKA,CAAA;IACD,IAAI,CAACvB,aAAa,EAAE;;EAGxBwB,MAAMA,CAAA;IACF,IAAI,OAAOC,oBAAoB,KAAK,WAAW,EAAE;IAEjD,MAAM;MAAEC,KAAK;MAAEC;IAAS,CAAE,GAAG,IAAI,CAACxB,IAAI;IACtC,MAAMyB,iBAAiB,GAAG,CAAC,QAAQ,EAAE,QAAQ,EAAE,MAAM,CAAC,CAACnC,IAAI,CACvDoC,wBAAwB,CAACH,KAAK,EAAEC,SAAS,CAAC,CAC7C;IAED,IAAIC,iBAAiB,EAAE;MACnB,IAAI,CAAC5B,aAAa,EAAE;;;EAI5BC,OAAOA,CAAA;AACV;AAED,SAAS4B,wBAAwBA,CAC7B;EAAE3B,QAAQ,GAAG;AAAE,CAAe,EAC9B;EAAEA,QAAQ,EAAE4B,YAAY,GAAG;AAAE,IAAkB,EAAE;EAEjD,OAAQC,IAA2B,IAC/B7B,QAAQ,CAAC6B,IAAI,CAAC,KAAKD,YAAY,CAACC,IAAI,CAAC;AAC7C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}