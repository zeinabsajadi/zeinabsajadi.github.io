{"ast":null,"code":"import { Feature } from 'motion-dom';\nimport { noop } from 'motion-utils';\nimport { VisualElementDragControls } from './VisualElementDragControls.mjs';\nclass DragGesture extends Feature {\n  constructor(node) {\n    super(node);\n    this.removeGroupControls = noop;\n    this.removeListeners = noop;\n    this.controls = new VisualElementDragControls(node);\n  }\n  mount() {\n    // If we've been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    const {\n      dragControls\n    } = this.node.getProps();\n    if (dragControls) {\n      this.removeGroupControls = dragControls.subscribe(this.controls);\n    }\n    this.removeListeners = this.controls.addListeners() || noop;\n  }\n  update() {\n    const {\n      dragControls\n    } = this.node.getProps();\n    const {\n      dragControls: prevDragControls\n    } = this.node.prevProps || {};\n    if (dragControls !== prevDragControls) {\n      this.removeGroupControls();\n      if (dragControls) {\n        this.removeGroupControls = dragControls.subscribe(this.controls);\n      }\n    }\n  }\n  unmount() {\n    this.removeGroupControls();\n    this.removeListeners();\n    /**\n     * In React 19, during list reorder reconciliation, components may\n     * briefly unmount and remount while the drag is still active. If we're\n     * actively dragging, we should NOT end the pan session - it will\n     * continue tracking pointer events via its window-level listeners.\n     *\n     * The pan session will be properly cleaned up when:\n     * 1. The drag ends naturally (pointerup/pointercancel)\n     * 2. The component is truly removed from the DOM\n     */\n    if (!this.controls.isDragging) {\n      this.controls.endPanSession();\n    }\n  }\n}\nexport { DragGesture };","map":{"version":3,"names":["DragGesture","Feature","constructor","node","removeGroupControls","noop","removeListeners","controls","VisualElementDragControls","mount","dragControls","getProps","subscribe","addListeners","update","prevDragControls","prevProps","unmount","isDragging","endPanSession"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/gestures/drag/index.ts"],"sourcesContent":["import { Feature, type VisualElement } from \"motion-dom\"\nimport { noop } from \"motion-utils\"\nimport { VisualElementDragControls } from \"./VisualElementDragControls\"\n\nexport class DragGesture extends Feature<HTMLElement> {\n    controls: VisualElementDragControls\n\n    removeGroupControls: Function = noop\n    removeListeners: Function = noop\n\n    constructor(node: VisualElement<HTMLElement>) {\n        super(node)\n        this.controls = new VisualElementDragControls(node)\n    }\n\n    mount() {\n        // If we've been provided a DragControls for manual control over the drag gesture,\n        // subscribe this component to it on mount.\n        const { dragControls } = this.node.getProps()\n\n        if (dragControls) {\n            this.removeGroupControls = dragControls.subscribe(this.controls)\n        }\n\n        this.removeListeners = this.controls.addListeners() || noop\n    }\n\n    update() {\n        const { dragControls } = this.node.getProps()\n        const { dragControls: prevDragControls } = this.node.prevProps || {}\n\n        if (dragControls !== prevDragControls) {\n            this.removeGroupControls()\n            if (dragControls) {\n                this.removeGroupControls = dragControls.subscribe(this.controls)\n            }\n        }\n    }\n\n    unmount() {\n        this.removeGroupControls()\n        this.removeListeners()\n        /**\n         * In React 19, during list reorder reconciliation, components may\n         * briefly unmount and remount while the drag is still active. If we're\n         * actively dragging, we should NOT end the pan session - it will\n         * continue tracking pointer events via its window-level listeners.\n         *\n         * The pan session will be properly cleaned up when:\n         * 1. The drag ends naturally (pointerup/pointercancel)\n         * 2. The component is truly removed from the DOM\n         */\n        if (!this.controls.isDragging) {\n            this.controls.endPanSession()\n        }\n    }\n}\n"],"mappings":";;;AAIM,MAAOA,WAAY,SAAQC,OAAoB;EAMjDC,YAAYC,IAAgC;IACxC,KAAK,CAACA,IAAI,CAAC;IAJf,IAAmB,CAAAC,mBAAA,GAAaC,IAAI;IACpC,IAAe,CAAAC,eAAA,GAAaD,IAAI;IAI5B,IAAI,CAACE,QAAQ,GAAG,IAAIC,yBAAyB,CAACL,IAAI,CAAC;;EAGvDM,KAAKA,CAAA;;;IAGD,MAAM;MAAEC;IAAY,CAAE,GAAG,IAAI,CAACP,IAAI,CAACQ,QAAQ,EAAE;IAE7C,IAAID,YAAY,EAAE;MACd,IAAI,CAACN,mBAAmB,GAAGM,YAAY,CAACE,SAAS,CAAC,IAAI,CAACL,QAAQ,CAAC;;IAGpE,IAAI,CAACD,eAAe,GAAG,IAAI,CAACC,QAAQ,CAACM,YAAY,EAAE,IAAIR,IAAI;;EAG/DS,MAAMA,CAAA;IACF,MAAM;MAAEJ;IAAY,CAAE,GAAG,IAAI,CAACP,IAAI,CAACQ,QAAQ,EAAE;IAC7C,MAAM;MAAED,YAAY,EAAEK;IAAgB,CAAE,GAAG,IAAI,CAACZ,IAAI,CAACa,SAAS,IAAI,EAAE;IAEpE,IAAIN,YAAY,KAAKK,gBAAgB,EAAE;MACnC,IAAI,CAACX,mBAAmB,EAAE;MAC1B,IAAIM,YAAY,EAAE;QACd,IAAI,CAACN,mBAAmB,GAAGM,YAAY,CAACE,SAAS,CAAC,IAAI,CAACL,QAAQ,CAAC;;;;EAK5EU,OAAOA,CAAA;IACH,IAAI,CAACb,mBAAmB,EAAE;IAC1B,IAAI,CAACE,eAAe,EAAE;IACtB;;;;;;;;;AASG;IACH,IAAI,CAAC,IAAI,CAACC,QAAQ,CAACW,UAAU,EAAE;MAC3B,IAAI,CAACX,QAAQ,CAACY,aAAa,EAAE;;;AAGxC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}