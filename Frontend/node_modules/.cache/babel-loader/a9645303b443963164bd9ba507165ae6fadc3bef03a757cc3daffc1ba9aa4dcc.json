{"ast":null,"code":"import { warnOnce, SubscriptionManager, velocityPerSecond } from 'motion-utils';\nimport { time } from '../frameloop/sync-time.mjs';\nimport { frame } from '../frameloop/frame.mjs';\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30;\nconst isFloat = value => {\n  return !isNaN(parseFloat(value));\n};\nconst collectMotionValues = {\n  current: undefined\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nclass MotionValue {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   */\n  constructor(init, options = {}) {\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    this.canTrackVelocity = null;\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    this.events = {};\n    this.updateAndNotify = v => {\n      const currentTime = time.now();\n      /**\n       * If we're updating the value during another frame or eventloop\n       * than the previous frame, then the we set the previous frame value\n       * to current.\n       */\n      if (this.updatedAt !== currentTime) {\n        this.setPrevFrameValue();\n      }\n      this.prev = this.current;\n      this.setCurrent(v);\n      // Update update subscribers\n      if (this.current !== this.prev) {\n        this.events.change?.notify(this.current);\n        if (this.dependents) {\n          for (const dependent of this.dependents) {\n            dependent.dirty();\n          }\n        }\n      }\n    };\n    this.hasAnimated = false;\n    this.setCurrent(init);\n    this.owner = options.owner;\n  }\n  setCurrent(current) {\n    this.current = current;\n    this.updatedAt = time.now();\n    if (this.canTrackVelocity === null && current !== undefined) {\n      this.canTrackVelocity = isFloat(this.current);\n    }\n  }\n  setPrevFrameValue(prevFrameValue = this.current) {\n    this.prevFrameValue = prevFrameValue;\n    this.prevUpdatedAt = this.updatedAt;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(subscription) {\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`);\n    }\n    return this.on(\"change\", subscription);\n  }\n  on(eventName, callback) {\n    if (!this.events[eventName]) {\n      this.events[eventName] = new SubscriptionManager();\n    }\n    const unsubscribe = this.events[eventName].add(callback);\n    if (eventName === \"change\") {\n      return () => {\n        unsubscribe();\n        /**\n         * If we have no more change listeners by the start\n         * of the next frame, stop active animations.\n         */\n        frame.read(() => {\n          if (!this.events.change.getSize()) {\n            this.stop();\n          }\n        });\n      };\n    }\n    return unsubscribe;\n  }\n  clearListeners() {\n    for (const eventManagers in this.events) {\n      this.events[eventManagers].clear();\n    }\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   */\n  attach(passiveEffect, stopPassiveEffect) {\n    this.passiveEffect = passiveEffect;\n    this.stopPassiveEffect = stopPassiveEffect;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(v) {\n    if (!this.passiveEffect) {\n      this.updateAndNotify(v);\n    } else {\n      this.passiveEffect(v, this.updateAndNotify);\n    }\n  }\n  setWithVelocity(prev, current, delta) {\n    this.set(current);\n    this.prev = undefined;\n    this.prevFrameValue = prev;\n    this.prevUpdatedAt = this.updatedAt - delta;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(v, endAnimation = true) {\n    this.updateAndNotify(v);\n    this.prev = v;\n    this.prevUpdatedAt = this.prevFrameValue = undefined;\n    endAnimation && this.stop();\n    if (this.stopPassiveEffect) this.stopPassiveEffect();\n  }\n  dirty() {\n    this.events.change?.notify(this.current);\n  }\n  addDependent(dependent) {\n    if (!this.dependents) {\n      this.dependents = new Set();\n    }\n    this.dependents.add(dependent);\n  }\n  removeDependent(dependent) {\n    if (this.dependents) {\n      this.dependents.delete(dependent);\n    }\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    if (collectMotionValues.current) {\n      collectMotionValues.current.push(this);\n    }\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    const currentTime = time.now();\n    if (!this.canTrackVelocity || this.prevFrameValue === undefined || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {\n      return 0;\n    }\n    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);\n    // Casts because of parseFloat's poor typing\n    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   */\n  start(startAnimation) {\n    this.stop();\n    return new Promise(resolve => {\n      this.hasAnimated = true;\n      this.animation = startAnimation(resolve);\n      if (this.events.animationStart) {\n        this.events.animationStart.notify();\n      }\n    }).then(() => {\n      if (this.events.animationComplete) {\n        this.events.animationComplete.notify();\n      }\n      this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    if (this.animation) {\n      this.animation.stop();\n      if (this.events.animationCancel) {\n        this.events.animationCancel.notify();\n      }\n    }\n    this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.animation;\n  }\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.dependents?.clear();\n    this.events.destroy?.notify();\n    this.clearListeners();\n    this.stop();\n    if (this.stopPassiveEffect) {\n      this.stopPassiveEffect();\n    }\n  }\n}\nfunction motionValue(init, options) {\n  return new MotionValue(init, options);\n}\nexport { MotionValue, collectMotionValues, motionValue };","map":{"version":3,"names":["MAX_VELOCITY_DELTA","isFloat","value","isNaN","parseFloat","collectMotionValues","current","undefined","MotionValue","constructor","init","options","canTrackVelocity","events","updateAndNotify","v","currentTime","time","now","updatedAt","setPrevFrameValue","prev","setCurrent","change","notify","dependents","dependent","dirty","hasAnimated","owner","prevFrameValue","prevUpdatedAt","onChange","subscription","process","env","NODE_ENV","warnOnce","on","eventName","callback","SubscriptionManager","unsubscribe","add","frame","read","getSize","stop","clearListeners","eventManagers","clear","attach","passiveEffect","stopPassiveEffect","set","setWithVelocity","delta","jump","endAnimation","addDependent","Set","removeDependent","delete","get","push","getPrevious","getVelocity","Math","min","velocityPerSecond","start","startAnimation","Promise","resolve","animation","animationStart","then","animationComplete","clearAnimation","animationCancel","isAnimating","destroy","motionValue"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/value/index.ts"],"sourcesContent":["import {\n    EasingFunction,\n    SubscriptionManager,\n    velocityPerSecond,\n    warnOnce,\n} from \"motion-utils\"\nimport {\n    AnimationPlaybackControlsWithThen,\n    AnyResolvedKeyframe,\n    TransformProperties,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { time } from \"../frameloop/sync-time\"\n\n/**\n * @public\n */\nexport type Subscriber<T> = (v: T) => void\n\n/**\n * @public\n */\nexport type PassiveEffect<T> = (v: T, safeSetter: (v: T) => void) => void\n\nexport type StartAnimation = (\n    complete: () => void\n) => AnimationPlaybackControlsWithThen | undefined\n\nexport interface MotionValueEventCallbacks<V> {\n    animationStart: () => void\n    animationComplete: () => void\n    animationCancel: () => void\n    change: (latestValue: V) => void\n    destroy: () => void\n}\n\n/**\n * Maximum time between the value of two frames, beyond which we\n * assume the velocity has since been 0.\n */\nconst MAX_VELOCITY_DELTA = 30\n\nconst isFloat = (value: any): value is string => {\n    return !isNaN(parseFloat(value))\n}\n\ninterface ResolvedValues {\n    [key: string]: AnyResolvedKeyframe\n}\n\nexport interface Owner {\n    current: HTMLElement | unknown\n    getProps: () => {\n        onUpdate?: (latest: ResolvedValues) => void\n        transformTemplate?: (\n            transform: TransformProperties,\n            generatedTransform: string\n        ) => string\n    }\n}\n\nexport interface AccelerateConfig {\n    factory: (animation: AnimationPlaybackControlsWithThen) => VoidFunction\n    times: number[]\n    keyframes: any[]\n    ease?: EasingFunction | EasingFunction[]\n    duration: number\n    isTransformed?: boolean\n}\n\nexport interface MotionValueOptions {\n    owner?: Owner\n}\n\nexport const collectMotionValues: { current: MotionValue[] | undefined } = {\n    current: undefined,\n}\n\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nexport class MotionValue<V = any> {\n    /**\n     * If a MotionValue has an owner, it was created internally within Motion\n     * and therefore has no external listeners. It is therefore safe to animate via WAAPI.\n     */\n    owner?: Owner\n\n    /**\n     * The current state of the `MotionValue`.\n     */\n    private current: V | undefined\n\n    /**\n     * The previous state of the `MotionValue`.\n     */\n    private prev: V | undefined\n\n    /**\n     * The previous state of the `MotionValue` at the end of the previous frame.\n     */\n    private prevFrameValue: V | undefined\n\n    /**\n     * The last time the `MotionValue` was updated.\n     */\n    updatedAt: number\n\n    /**\n     * The time `prevFrameValue` was updated.\n     */\n    prevUpdatedAt: number | undefined\n\n    /**\n     * Add a passive effect to this `MotionValue`.\n     *\n     * A passive effect intercepts calls to `set`. For instance, `useSpring` adds\n     * a passive effect that attaches a `spring` to the latest\n     * set value. Hypothetically there could be a `useSmooth` that attaches an input smoothing effect.\n     *\n     * @internal\n     */\n    private passiveEffect?: PassiveEffect<V>\n    private stopPassiveEffect?: VoidFunction\n\n    /**\n     * Whether the passive effect is active.\n     */\n    isEffectActive?: boolean\n\n    /**\n     * A reference to the currently-controlling animation.\n     */\n    animation?: AnimationPlaybackControlsWithThen\n\n    /**\n     * Tracks whether this value can output a velocity. Currently this is only true\n     * if the value is numerical, but we might be able to widen the scope here and support\n     * other value types.\n     *\n     * @internal\n     */\n    private canTrackVelocity: boolean | null = null\n\n    /**\n     * A list of MotionValues whose values are computed from this one.\n     * This is a rough start to a proper signal-like dirtying system.\n     */\n    private dependents: Set<MotionValue> | undefined\n\n    /**\n     * Tracks whether this value should be removed\n     */\n    liveStyle?: boolean\n\n    /**\n     * Scroll timeline acceleration metadata. When set, VisualElement\n     * can create a native WAAPI animation attached to a scroll timeline\n     * instead of driving updates through JS.\n     */\n    accelerate?: AccelerateConfig\n\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     */\n    constructor(init: V, options: MotionValueOptions = {}) {\n        this.setCurrent(init)\n        this.owner = options.owner\n    }\n\n    setCurrent(current: V) {\n        this.current = current\n        this.updatedAt = time.now()\n\n        if (this.canTrackVelocity === null && current !== undefined) {\n            this.canTrackVelocity = isFloat(this.current)\n        }\n    }\n\n    setPrevFrameValue(prevFrameValue: V | undefined = this.current) {\n        this.prevFrameValue = prevFrameValue\n        this.prevUpdatedAt = this.updatedAt\n    }\n\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don't add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.on(\"change\", updateOpacity)\n     *     const unsubscribeY = y.on(\"change\", updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @deprecated\n     */\n    onChange(subscription: Subscriber<V>): () => void {\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(\n                false,\n                `value.onChange(callback) is deprecated. Switch to value.on(\"change\", callback).`\n            )\n        }\n        return this.on(\"change\", subscription)\n    }\n\n    /**\n     * An object containing a SubscriptionManager for each active event.\n     */\n    private events: {\n        [key: string]: SubscriptionManager<any>\n    } = {}\n\n    on<EventName extends keyof MotionValueEventCallbacks<V>>(\n        eventName: EventName,\n        callback: MotionValueEventCallbacks<V>[EventName]\n    ) {\n        if (!this.events[eventName]) {\n            this.events[eventName] = new SubscriptionManager()\n        }\n\n        const unsubscribe = this.events[eventName].add(callback)\n\n        if (eventName === \"change\") {\n            return () => {\n                unsubscribe()\n\n                /**\n                 * If we have no more change listeners by the start\n                 * of the next frame, stop active animations.\n                 */\n                frame.read(() => {\n                    if (!this.events.change.getSize()) {\n                        this.stop()\n                    }\n                })\n            }\n        }\n\n        return unsubscribe\n    }\n\n    clearListeners() {\n        for (const eventManagers in this.events) {\n            this.events[eventManagers].clear()\n        }\n    }\n\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     */\n    attach(passiveEffect: PassiveEffect<V>, stopPassiveEffect: VoidFunction) {\n        this.passiveEffect = passiveEffect\n        this.stopPassiveEffect = stopPassiveEffect\n    }\n\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    set(v: V) {\n        if (!this.passiveEffect) {\n            this.updateAndNotify(v)\n        } else {\n            this.passiveEffect(v, this.updateAndNotify)\n        }\n    }\n\n    setWithVelocity(prev: V, current: V, delta: number) {\n        this.set(current)\n        this.prev = undefined\n        this.prevFrameValue = prev\n        this.prevUpdatedAt = this.updatedAt - delta\n    }\n\n    /**\n     * Set the state of the `MotionValue`, stopping any active animations,\n     * effects, and resets velocity to `0`.\n     */\n    jump(v: V, endAnimation = true) {\n        this.updateAndNotify(v)\n        this.prev = v\n        this.prevUpdatedAt = this.prevFrameValue = undefined\n        endAnimation && this.stop()\n        if (this.stopPassiveEffect) this.stopPassiveEffect()\n    }\n\n    dirty() {\n        this.events.change?.notify(this.current)\n    }\n\n    addDependent(dependent: MotionValue) {\n        if (!this.dependents) {\n            this.dependents = new Set()\n        }\n        this.dependents.add(dependent)\n    }\n\n    removeDependent(dependent: MotionValue) {\n        if (this.dependents) {\n            this.dependents.delete(dependent)\n        }\n    }\n\n    updateAndNotify = (v: V) => {\n        const currentTime = time.now()\n\n        /**\n         * If we're updating the value during another frame or eventloop\n         * than the previous frame, then the we set the previous frame value\n         * to current.\n         */\n        if (this.updatedAt !== currentTime) {\n            this.setPrevFrameValue()\n        }\n\n        this.prev = this.current\n\n        this.setCurrent(v)\n\n        // Update update subscribers\n        if (this.current !== this.prev) {\n            this.events.change?.notify(this.current)\n\n            if (this.dependents) {\n                for (const dependent of this.dependents) {\n                    dependent.dirty()\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    get() {\n        if (collectMotionValues.current) {\n            collectMotionValues.current.push(this)\n        }\n\n        return this.current!\n    }\n\n    /**\n     * @public\n     */\n    getPrevious() {\n        return this.prev\n    }\n\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    getVelocity() {\n        const currentTime = time.now()\n\n        if (\n            !this.canTrackVelocity ||\n            this.prevFrameValue === undefined ||\n            currentTime - this.updatedAt > MAX_VELOCITY_DELTA\n        ) {\n            return 0\n        }\n\n        const delta = Math.min(\n            this.updatedAt - this.prevUpdatedAt!,\n            MAX_VELOCITY_DELTA\n        )\n\n        // Casts because of parseFloat's poor typing\n        return velocityPerSecond(\n            parseFloat(this.current as any) -\n                parseFloat(this.prevFrameValue as any),\n            delta\n        )\n    }\n\n    hasAnimated = false\n\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     */\n    start(startAnimation: StartAnimation) {\n        this.stop()\n\n        return new Promise<void>((resolve) => {\n            this.hasAnimated = true\n            this.animation = startAnimation(resolve)\n\n            if (this.events.animationStart) {\n                this.events.animationStart.notify()\n            }\n        }).then(() => {\n            if (this.events.animationComplete) {\n                this.events.animationComplete.notify()\n            }\n            this.clearAnimation()\n        })\n    }\n\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    stop() {\n        if (this.animation) {\n            this.animation.stop()\n            if (this.events.animationCancel) {\n                this.events.animationCancel.notify()\n            }\n        }\n        this.clearAnimation()\n    }\n\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    isAnimating() {\n        return !!this.animation\n    }\n\n    private clearAnimation() {\n        delete this.animation\n    }\n\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    destroy() {\n        this.dependents?.clear()\n        this.events.destroy?.notify()\n        this.clearListeners()\n        this.stop()\n\n        if (this.stopPassiveEffect) {\n            this.stopPassiveEffect()\n        }\n    }\n}\n\nexport function motionValue<V>(init: V, options?: MotionValueOptions) {\n    return new MotionValue<V>(init, options)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}