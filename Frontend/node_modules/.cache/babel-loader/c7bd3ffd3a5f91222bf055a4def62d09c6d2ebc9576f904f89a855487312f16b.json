{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport { globalProjectionState, frame, microtask } from 'motion-dom';\nimport { useContext, Component } from 'react';\nimport { usePresence } from '../../../components/AnimatePresence/use-presence.mjs';\nimport { LayoutGroupContext } from '../../../context/LayoutGroupContext.mjs';\nimport { SwitchLayoutGroupContext } from '../../../context/SwitchLayoutGroupContext.mjs';\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false;\nclass MeasureLayoutWithContext extends Component {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup,\n      layoutId\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (projection) {\n      if (layoutGroup.group) layoutGroup.group.add(projection);\n      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n        switchLayoutGroup.register(projection);\n      }\n      if (hasTakenAnySnapshot) {\n        projection.root.didUpdate();\n      }\n      projection.addEventListener(\"animationComplete\", () => {\n        this.safeToRemove();\n      });\n      projection.setOptions({\n        ...projection.options,\n        layoutDependency: this.props.layoutDependency,\n        onExitComplete: () => this.safeToRemove()\n      });\n    }\n    globalProjectionState.hasEverUpdated = true;\n  }\n  getSnapshotBeforeUpdate(prevProps) {\n    const {\n      layoutDependency,\n      visualElement,\n      drag,\n      isPresent\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    if (!projection) return null;\n    /**\n     * TODO: We use this data in relegate to determine whether to\n     * promote a previous element. There's no guarantee its presence data\n     * will have updated by this point - if a bug like this arises it will\n     * have to be that we markForRelegation and then find a new lead some other way,\n     * perhaps in didUpdate\n     */\n    projection.isPresent = isPresent;\n    if (prevProps.layoutDependency !== layoutDependency) {\n      projection.setOptions({\n        ...projection.options,\n        layoutDependency\n      });\n    }\n    hasTakenAnySnapshot = true;\n    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined || prevProps.isPresent !== isPresent) {\n      projection.willUpdate();\n    } else {\n      this.safeToRemove();\n    }\n    if (prevProps.isPresent !== isPresent) {\n      if (isPresent) {\n        projection.promote();\n      } else if (!projection.relegate()) {\n        /**\n         * If there's another stack member taking over from this one,\n         * it's in charge of the exit animation and therefore should\n         * be in charge of the safe to remove. Otherwise we call it here.\n         */\n        frame.postRender(() => {\n          const stack = projection.getStack();\n          if (!stack || !stack.members.length) {\n            this.safeToRemove();\n          }\n        });\n      }\n    }\n    return null;\n  }\n  componentDidUpdate() {\n    const {\n      projection\n    } = this.props.visualElement;\n    if (projection) {\n      projection.root.didUpdate();\n      microtask.postRender(() => {\n        if (!projection.currentAnimation && projection.isLead()) {\n          this.safeToRemove();\n        }\n      });\n    }\n  }\n  componentWillUnmount() {\n    const {\n      visualElement,\n      layoutGroup,\n      switchLayoutGroup: promoteContext\n    } = this.props;\n    const {\n      projection\n    } = visualElement;\n    hasTakenAnySnapshot = true;\n    if (projection) {\n      projection.scheduleCheckAfterUnmount();\n      if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);\n      if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);\n    }\n  }\n  safeToRemove() {\n    const {\n      safeToRemove\n    } = this.props;\n    safeToRemove && safeToRemove();\n  }\n  render() {\n    return null;\n  }\n}\nfunction MeasureLayout(props) {\n  const [isPresent, safeToRemove] = usePresence();\n  const layoutGroup = useContext(LayoutGroupContext);\n  return jsx(MeasureLayoutWithContext, {\n    ...props,\n    layoutGroup: layoutGroup,\n    switchLayoutGroup: useContext(SwitchLayoutGroupContext),\n    isPresent: isPresent,\n    safeToRemove: safeToRemove\n  });\n}\nexport { MeasureLayout };","map":{"version":3,"names":["hasTakenAnySnapshot","MeasureLayoutWithContext","Component","visualElement","layoutGroup","switchLayoutGroup","layoutId","props","projection","group","add","register","root","didUpdate","addEventListener","layoutDependency","onExitComplete","safeToRemove","globalProjectionState","hasEverUpdated","getSnapshotBeforeUpdate","prevProps","drag","isPresent","undefined","relegate","frame","postRender","stack","getStack","microtask","promoteContext","remove","deregister","MeasureLayout","useContext","LayoutGroupContext"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/motion/features/layout/MeasureLayout.tsx"],"sourcesContent":["\"use client\"\n\nimport { frame, microtask, globalProjectionState, type VisualElement } from \"motion-dom\"\nimport { Component, useContext } from \"react\"\nimport { usePresence } from \"../../../components/AnimatePresence/use-presence\"\nimport {\n    LayoutGroupContext,\n    LayoutGroupContextProps,\n} from \"../../../context/LayoutGroupContext\"\nimport { SwitchLayoutGroupContext } from \"../../../context/SwitchLayoutGroupContext\"\nimport { MotionProps } from \"../../types\"\n\ninterface MeasureContextProps {\n    layoutGroup: LayoutGroupContextProps\n    switchLayoutGroup?: SwitchLayoutGroupContext\n    isPresent: boolean\n    safeToRemove?: VoidFunction | null\n}\n\ntype MeasureProps = MotionProps &\n    MeasureContextProps & { visualElement: VisualElement }\n\n/**\n * Track whether we've taken any snapshots yet. If not,\n * we can safely skip notification of didUpdate.\n *\n * Difficult to capture in a test but to prevent flickering\n * we must set this to true either on update or unmount.\n * Running `next-env/layout-id` in Safari will show this behaviour if broken.\n */\nlet hasTakenAnySnapshot = false\n\nclass MeasureLayoutWithContext extends Component<MeasureProps> {\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    componentDidMount() {\n        const { visualElement, layoutGroup, switchLayoutGroup, layoutId } =\n            this.props\n        const { projection } = visualElement\n\n        if (projection) {\n            if (layoutGroup.group) layoutGroup.group.add(projection)\n\n            if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {\n                switchLayoutGroup.register(projection)\n            }\n\n            if (hasTakenAnySnapshot) {\n                projection.root!.didUpdate()\n            }\n\n            projection.addEventListener(\"animationComplete\", () => {\n                this.safeToRemove()\n            })\n            projection.setOptions({\n                ...projection.options,\n                layoutDependency: this.props.layoutDependency,\n                onExitComplete: () => this.safeToRemove(),\n            })\n        }\n\n        globalProjectionState.hasEverUpdated = true\n    }\n\n    getSnapshotBeforeUpdate(prevProps: MeasureProps) {\n        const { layoutDependency, visualElement, drag, isPresent } = this.props\n        const { projection } = visualElement\n\n        if (!projection) return null\n\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There's no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent\n\n        if (prevProps.layoutDependency !== layoutDependency) {\n            projection.setOptions({\n                ...projection.options,\n                layoutDependency,\n            })\n        }\n\n        hasTakenAnySnapshot = true\n\n        if (\n            drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined ||\n            prevProps.isPresent !== isPresent\n        ) {\n            projection.willUpdate()\n        } else {\n            this.safeToRemove()\n        }\n\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote()\n            } else if (!projection.relegate()) {\n                /**\n                 * If there's another stack member taking over from this one,\n                 * it's in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                frame.postRender(() => {\n                    const stack = projection.getStack()\n                    if (!stack || !stack.members.length) {\n                        this.safeToRemove()\n                    }\n                })\n            }\n        }\n\n        return null\n    }\n\n    componentDidUpdate() {\n        const { projection } = this.props.visualElement\n        if (projection) {\n            projection.root!.didUpdate()\n\n            microtask.postRender(() => {\n                if (!projection.currentAnimation && projection.isLead()) {\n                    this.safeToRemove()\n                }\n            })\n        }\n    }\n\n    componentWillUnmount() {\n        const {\n            visualElement,\n            layoutGroup,\n            switchLayoutGroup: promoteContext,\n        } = this.props\n        const { projection } = visualElement\n\n        hasTakenAnySnapshot = true\n\n        if (projection) {\n            projection.scheduleCheckAfterUnmount()\n            if (layoutGroup && layoutGroup.group)\n                layoutGroup.group.remove(projection)\n            if (promoteContext && promoteContext.deregister)\n                promoteContext.deregister(projection)\n        }\n    }\n\n    safeToRemove() {\n        const { safeToRemove } = this.props\n        safeToRemove && safeToRemove()\n    }\n\n    render() {\n        return null\n    }\n}\n\nexport function MeasureLayout(\n    props: MotionProps & { visualElement: VisualElement }\n) {\n    const [isPresent, safeToRemove] = usePresence()\n    const layoutGroup = useContext(LayoutGroupContext)\n\n    return (\n        <MeasureLayoutWithContext\n            {...props}\n            layoutGroup={layoutGroup}\n            switchLayoutGroup={useContext(SwitchLayoutGroupContext)}\n            isPresent={isPresent}\n            safeToRemove={safeToRemove}\n        />\n    )\n}\n"],"mappings":";;;;;;;;;AAsBA;;;;;;;AAOG;AACH,IAAAA,mBAAA;AAEA,MAAAC,wBAAA,SAAAC,SAAA;EACI;;;;AAIG;;IAEC;MAAAC,aAAA;MAAAC,WAAA;MAAAC,iBAAA;MAAAC;IAAA,SAAAC,KAAA;IAEA;MAAAC;IAAA,IAAAL,aAAA;;6BAG2BC,WAAA,CAAAK,KAAA,CAAAC,GAAA,CAAAF,UAAA;;QAGnBH,iBAAA,CAAAM,QAAA,CAAAH,UAAA;;;QAIAA,UAAA,CAAAI,IAAA,CAAAC,SAAA;;MAGJL,UAAA,CAAAM,gBAAA;;MAEA;;;QAGIC,gBAAA,OAAAR,KAAA,CAAAQ,gBAAA;QACAC,cAAA,EAAAA,CAAA,UAAAC,YAAA;MACH;;IAGLC,qBAAA,CAAAC,cAAA;;EAGJC,wBAAAC,SAAA;IACI;MAAAN,gBAAA;MAAAZ,aAAA;MAAAmB,IAAA;MAAAC;IAAA,SAAAhB,KAAA;IACA;MAAAC;IAAA,IAAAL,aAAA;IAEA,KAAAK,UAAA,EAAiB;IAEjB;;;;;;AAMG;IACHA,UAAA,CAAAe,SAAA,GAAAA,SAAA;IAEA,IAAAF,SAAA,CAAAN,gBAAA,KAAAA,gBAAA;;;;MAIK;;;IAKL,IAAAO,IAAA,I,mDAGIP,gBAAA,KAAAS,SAAA,IACAH,SAAA,CAAAE,SAAA,KAAAA,SAAA;;;;;IAOJ,IAAAF,SAAA,CAAAE,SAAA,KAAAA,SAAA;;;aAGW,KAAAf,UAAA,CAAAiB,QAAA;QACH;;;;AAIG;QACHC,KAAA,CAAAC,UAAA;UACI,MAAAC,KAAA,GAAApB,UAAA,CAAAqB,QAAA;;;;QAIJ;;;IAIR;;;;;;;MAMIrB,UAAA,CAAAI,IAAA,CAAAC,SAAA;MAEAiB,SAAA,CAAAH,UAAA;;;;MAIA;;;;IAKJ;MAAAxB,aAAA;MAAAC,WAAA;MAAAC,iBAAA,EAAA0B;IAAA,SAAAxB,KAAA;IAKA;MAAAC;IAAA,IAAAL,aAAA;;;;MAMI,IAAAC,WAAA,IAAAA,WAAA,CAAAK,KAAA,EACIL,WAAA,CAAAK,KAAA,CAAAuB,MAAA,CAAAxB,UAAA;MACJ,IAAAuB,cAAA,IAAAA,cAAA,CAAAE,UAAA,EACIF,cAAA,CAAAE,UAAA,CAAAzB,UAAA;;;;IAKR;MAAAS;IAAA,SAAAV,KAAA;;;;IAKA;;AAEP;AAEK,SAAA2B,cAAA3B,KAAA;;EAIF,MAAAH,WAAA,GAAA+B,UAAA,CAAAC,kBAAA;;;;;;;;AAWJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}