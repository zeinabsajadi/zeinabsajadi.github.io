{"ast":null,"code":"import _objectWithoutProperties from \"/home/zeinab/ziblog/Frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nconst _excluded = [\"src\", \"toneMapped\", \"alphaTest\", \"alphaHash\", \"chunkSize\"];\nimport _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useLoader, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { version } from '../helpers/constants.js';\nconst SplatMaterial = /* @__PURE__ */shaderMaterial({\n  alphaTest: 0,\n  viewport: /* @__PURE__ */new THREE.Vector2(1980, 1080),\n  focal: 1000.0,\n  centerAndScaleTexture: null,\n  covAndColorTexture: null\n}, /*glsl*/\"\\n    precision highp sampler2D;\\n    precision highp usampler2D;\\n    out vec4 vColor;\\n    out vec3 vPosition;\\n    uniform vec2 resolution;\\n    uniform vec2 viewport;\\n    uniform float focal;\\n    attribute uint splatIndex;\\n    uniform sampler2D centerAndScaleTexture;\\n    uniform usampler2D covAndColorTexture;    \\n\\n    vec2 unpackInt16(in uint value) {\\n      int v = int(value);\\n      int v0 = v >> 16;\\n      int v1 = (v & 0xFFFF);\\n      if((v & 0x8000) != 0)\\n        v1 |= 0xFFFF0000;\\n      return vec2(float(v1), float(v0));\\n    }\\n\\n    void main () {\\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\\n      vec4 camspace = modelViewMatrix * center;\\n      vec4 pos2d = projectionMatrix * camspace;\\n\\n      float bounds = 1.2 * pos2d.w;\\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\\n        || pos2d.y < -bounds || pos2d.y > bounds) {\\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\\n        return;\\n      }\\n\\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\\n      mat3 Vrk = mat3(\\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\\n      );\\n\\n      mat3 J = mat3(\\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\\n        0., 0., 0.\\n      );\\n\\n      mat3 W = transpose(mat3(modelViewMatrix));\\n      mat3 T = W * J;\\n      mat3 cov = transpose(T) * Vrk * T;\\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\\n      float diagonal1 = cov[0][0] + 0.3;\\n      float offDiagonal = cov[0][1];\\n      float diagonal2 = cov[1][1] + 0.3;\\n      float mid = 0.5 * (diagonal1 + diagonal2);\\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\\n      float lambda1 = mid + radius;\\n      float lambda2 = max(mid - radius, 0.1);\\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\\n      uint colorUint = covAndColorData.w;\\n      vColor = vec4(\\n        float(colorUint & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\\n        float(colorUint >> uint(24)) / 255.0\\n      );\\n      vPosition = position;\\n\\n      gl_Position = vec4(\\n        vCenter \\n          + position.x * v2 / viewport * 2.0 \\n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\\n    }\\n    \", /*glsl*/\"\\n    #include <alphatest_pars_fragment>\\n    #include <alphahash_pars_fragment>\\n    in vec4 vColor;\\n    in vec3 vPosition;\\n    void main () {\\n      float A = -dot(vPosition.xy, vPosition.xy);\\n      if (A < -4.0) discard;\\n      float B = exp(A) * vColor.a;\\n      vec4 diffuseColor = vec4(vColor.rgb, B);\\n      #include <alphatest_fragment>\\n      #include <alphahash_fragment>\\n      gl_FragColor = diffuseColor;\\n      #include <tonemapping_fragment>\\n      #include <\".concat(version >= 154 ? 'colorspace_fragment' : 'encodings_fragment', \">\\n    }\\n  \"));\nfunction createWorker(self) {\n  let matrices = null;\n  let offset = 0;\n  function sortSplats(view) {\n    let hashed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const vertexCount = matrices.length / 16;\n    const threshold = -0.0001;\n    let maxDepth = -Infinity;\n    let minDepth = Infinity;\n    const depthList = new Float32Array(vertexCount);\n    const sizeList = new Int32Array(depthList.buffer);\n    const validIndexList = new Int32Array(vertexCount);\n    let validCount = 0;\n    for (let i = 0; i < vertexCount; i++) {\n      // Sign of depth is reversed\n      const depth = view[0] * matrices[i * 16 + 12] + view[1] * matrices[i * 16 + 13] + view[2] * matrices[i * 16 + 14] + view[3];\n      // Skip behind of camera and small, transparent splat\n      if (hashed || depth < 0 && matrices[i * 16 + 15] > threshold * depth) {\n        depthList[validCount] = depth;\n        validIndexList[validCount] = i;\n        validCount++;\n        if (depth > maxDepth) maxDepth = depth;\n        if (depth < minDepth) minDepth = depth;\n      }\n    }\n\n    // This is a 16 bit single-pass counting sort\n    const depthInv = (256 * 256 - 1) / (maxDepth - minDepth);\n    const counts0 = new Uint32Array(256 * 256);\n    for (let i = 0; i < validCount; i++) {\n      sizeList[i] = (depthList[i] - minDepth) * depthInv | 0;\n      counts0[sizeList[i]]++;\n    }\n    const starts0 = new Uint32Array(256 * 256);\n    for (let i = 1; i < 256 * 256; i++) starts0[i] = starts0[i - 1] + counts0[i - 1];\n    const depthIndex = new Uint32Array(validCount);\n    for (let i = 0; i < validCount; i++) depthIndex[starts0[sizeList[i]]++] = validIndexList[i];\n    return depthIndex;\n  }\n  self.onmessage = e => {\n    if (e.data.method == 'push') {\n      if (offset === 0) matrices = new Float32Array(e.data.length);\n      const new_matrices = new Float32Array(e.data.matrices);\n      matrices.set(new_matrices, offset);\n      offset += new_matrices.length;\n    } else if (e.data.method == 'sort') {\n      if (matrices !== null) {\n        const indices = sortSplats(new Float32Array(e.data.view), e.data.hashed);\n        // @ts-ignore\n        self.postMessage({\n          indices,\n          key: e.data.key\n        }, [indices.buffer]);\n      }\n    }\n  };\n}\nclass SplatLoader extends THREE.Loader {\n  constructor() {\n    super(...arguments);\n    // WebGLRenderer, needs to be filled out!\n    this.gl = null;\n    // Default chunk size for lazy loading\n    this.chunkSize = 25000;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const shared = {\n      gl: this.gl,\n      url: this.manager.resolveURL(url),\n      worker: new Worker(URL.createObjectURL(new Blob(['(', createWorker.toString(), ')(self)'], {\n        type: 'application/javascript'\n      }))),\n      manager: this.manager,\n      update: (target, camera, hashed) => update(camera, shared, target, hashed),\n      connect: target => connect(shared, target),\n      loading: false,\n      loaded: false,\n      loadedVertexCount: 0,\n      chunkSize: this.chunkSize,\n      totalDownloadBytes: 0,\n      numVertices: 0,\n      rowLength: 3 * 4 + 3 * 4 + 4 + 4,\n      maxVertexes: 0,\n      bufferTextureWidth: 0,\n      bufferTextureHeight: 0,\n      stream: null,\n      centerAndScaleData: null,\n      covAndColorData: null,\n      covAndColorTexture: null,\n      centerAndScaleTexture: null,\n      onProgress\n    };\n    load(shared).then(onLoad).catch(e => {\n      onError == null || onError(e);\n      shared.manager.itemError(shared.url);\n    });\n  }\n}\nasync function load(shared) {\n  shared.manager.itemStart(shared.url);\n  const data = await fetch(shared.url);\n  if (data.body === null) throw 'Failed to fetch file';\n  let _totalDownloadBytes = data.headers.get('Content-Length');\n  const totalDownloadBytes = _totalDownloadBytes ? parseInt(_totalDownloadBytes) : undefined;\n  if (totalDownloadBytes == undefined) throw 'Failed to get content length';\n  shared.stream = data.body.getReader();\n  shared.totalDownloadBytes = totalDownloadBytes;\n  shared.numVertices = Math.floor(shared.totalDownloadBytes / shared.rowLength);\n  const context = shared.gl.getContext();\n  let maxTextureSize = context.getParameter(context.MAX_TEXTURE_SIZE);\n  shared.maxVertexes = maxTextureSize * maxTextureSize;\n  if (shared.numVertices > shared.maxVertexes) shared.numVertices = shared.maxVertexes;\n  shared.bufferTextureWidth = maxTextureSize;\n  shared.bufferTextureHeight = Math.floor((shared.numVertices - 1) / maxTextureSize) + 1;\n  shared.centerAndScaleData = new Float32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.covAndColorData = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.centerAndScaleTexture = new THREE.DataTexture(shared.centerAndScaleData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAFormat, THREE.FloatType);\n  shared.centerAndScaleTexture.needsUpdate = true;\n  shared.covAndColorTexture = new THREE.DataTexture(shared.covAndColorData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n  shared.covAndColorTexture.internalFormat = 'RGBA32UI';\n  shared.covAndColorTexture.needsUpdate = true;\n  return shared;\n}\nasync function lazyLoad(shared) {\n  shared.loading = true;\n  let bytesDownloaded = 0;\n  let bytesProcessed = 0;\n  const chunks = [];\n  let lastReportedProgress = 0;\n  const lengthComputable = shared.totalDownloadBytes !== 0;\n  while (true) {\n    try {\n      const {\n        value,\n        done\n      } = await shared.stream.read();\n      if (done) break;\n      bytesDownloaded += value.length;\n      if (shared.totalDownloadBytes != undefined) {\n        const percent = bytesDownloaded / shared.totalDownloadBytes * 100;\n        if (shared.onProgress && percent - lastReportedProgress > 1) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: bytesDownloaded,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n          lastReportedProgress = percent;\n        }\n      }\n      chunks.push(value);\n      const bytesRemains = bytesDownloaded - bytesProcessed;\n      if (shared.totalDownloadBytes != undefined && bytesRemains > shared.rowLength * shared.chunkSize) {\n        let vertexCount = Math.floor(bytesRemains / shared.rowLength);\n        const concatenatedChunksbuffer = new Uint8Array(bytesRemains);\n        let offset = 0;\n        for (const chunk of chunks) {\n          concatenatedChunksbuffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n        chunks.length = 0;\n        if (bytesRemains > vertexCount * shared.rowLength) {\n          const extra_data = new Uint8Array(bytesRemains - vertexCount * shared.rowLength);\n          extra_data.set(concatenatedChunksbuffer.subarray(bytesRemains - extra_data.length, bytesRemains), 0);\n          chunks.push(extra_data);\n        }\n        const buffer = new Uint8Array(vertexCount * shared.rowLength);\n        buffer.set(concatenatedChunksbuffer.subarray(0, buffer.byteLength), 0);\n        const matrices = pushDataBuffer(shared, buffer.buffer, vertexCount);\n        shared.worker.postMessage({\n          method: 'push',\n          src: shared.url,\n          length: shared.numVertices * 16,\n          matrices: matrices.buffer\n        }, [matrices.buffer]);\n        bytesProcessed += vertexCount * shared.rowLength;\n        if (shared.onProgress) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: shared.totalDownloadBytes,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n        }\n      }\n    } catch (error) {\n      console.error(error);\n      break;\n    }\n  }\n  if (bytesDownloaded - bytesProcessed > 0) {\n    // Concatenate the chunks into a single Uint8Array\n    let concatenatedChunks = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));\n    let offset = 0;\n    for (const chunk of chunks) {\n      concatenatedChunks.set(chunk, offset);\n      offset += chunk.length;\n    }\n    let numVertices = Math.floor(concatenatedChunks.byteLength / shared.rowLength);\n    const matrices = pushDataBuffer(shared, concatenatedChunks.buffer, numVertices);\n    shared.worker.postMessage({\n      method: 'push',\n      src: shared.url,\n      length: numVertices * 16,\n      matrices: matrices.buffer\n    }, [matrices.buffer]);\n  }\n  shared.loaded = true;\n  shared.manager.itemEnd(shared.url);\n}\nfunction update(camera, shared, target, hashed) {\n  camera.updateMatrixWorld();\n  shared.gl.getCurrentViewport(target.viewport);\n  // @ts-ignore\n  target.material.viewport.x = target.viewport.z;\n  // @ts-ignore\n  target.material.viewport.y = target.viewport.w;\n  target.material.focal = target.viewport.w / 2.0 * Math.abs(camera.projectionMatrix.elements[5]);\n  if (target.ready) {\n    if (hashed && target.sorted) return;\n    target.ready = false;\n    const view = new Float32Array([target.modelViewMatrix.elements[2], -target.modelViewMatrix.elements[6], target.modelViewMatrix.elements[10], target.modelViewMatrix.elements[14]]);\n    shared.worker.postMessage({\n      method: 'sort',\n      src: shared.url,\n      key: target.uuid,\n      view: view.buffer,\n      hashed\n    }, [view.buffer]);\n    if (hashed && shared.loaded) target.sorted = true;\n  }\n}\nfunction connect(shared, target) {\n  if (!shared.loading) lazyLoad(shared);\n  target.ready = false;\n  target.pm = new THREE.Matrix4();\n  target.vm1 = new THREE.Matrix4();\n  target.vm2 = new THREE.Matrix4();\n  target.viewport = new THREE.Vector4();\n  let splatIndexArray = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight);\n  const splatIndexes = new THREE.InstancedBufferAttribute(splatIndexArray, 1, false);\n  splatIndexes.setUsage(THREE.DynamicDrawUsage);\n  const geometry = target.geometry = new THREE.InstancedBufferGeometry();\n  const positionsArray = new Float32Array(6 * 3);\n  const positions = new THREE.BufferAttribute(positionsArray, 3);\n  geometry.setAttribute('position', positions);\n  positions.setXYZ(2, -2.0, 2.0, 0.0);\n  positions.setXYZ(1, 2.0, 2.0, 0.0);\n  positions.setXYZ(0, -2.0, -2.0, 0.0);\n  positions.setXYZ(5, -2.0, -2.0, 0.0);\n  positions.setXYZ(4, 2.0, 2.0, 0.0);\n  positions.setXYZ(3, 2.0, -2.0, 0.0);\n  positions.needsUpdate = true;\n  geometry.setAttribute('splatIndex', splatIndexes);\n  geometry.instanceCount = 1;\n  function listener(e) {\n    if (target && e.data.key === target.uuid) {\n      let indexes = new Uint32Array(e.data.indices);\n      // @ts-ignore\n      geometry.attributes.splatIndex.set(indexes);\n      geometry.attributes.splatIndex.needsUpdate = true;\n      geometry.instanceCount = indexes.length;\n      target.ready = true;\n    }\n  }\n  shared.worker.addEventListener('message', listener);\n  async function wait() {\n    while (true) {\n      const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n      const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n      if (centerAndScaleTextureProperties != null && centerAndScaleTextureProperties.__webglTexture && covAndColorTextureProperties != null && covAndColorTextureProperties.__webglTexture && shared.loadedVertexCount > 0) break;\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    target.ready = true;\n  }\n  wait();\n  return () => shared.worker.removeEventListener('message', listener);\n}\nfunction pushDataBuffer(shared, buffer, vertexCount) {\n  const context = shared.gl.getContext();\n  if (shared.loadedVertexCount + vertexCount > shared.maxVertexes) vertexCount = shared.maxVertexes - shared.loadedVertexCount;\n  if (vertexCount <= 0) throw 'Failed to parse file';\n  const u_buffer = new Uint8Array(buffer);\n  const f_buffer = new Float32Array(buffer);\n  const matrices = new Float32Array(vertexCount * 16);\n  const covAndColorData_uint8 = new Uint8Array(shared.covAndColorData.buffer);\n  const covAndColorData_int16 = new Int16Array(shared.covAndColorData.buffer);\n  for (let i = 0; i < vertexCount; i++) {\n    const quat = new THREE.Quaternion(-(u_buffer[32 * i + 28 + 1] - 128) / 128.0, (u_buffer[32 * i + 28 + 2] - 128) / 128.0, (u_buffer[32 * i + 28 + 3] - 128) / 128.0, -(u_buffer[32 * i + 28 + 0] - 128) / 128.0);\n    quat.invert();\n    const center = new THREE.Vector3(f_buffer[8 * i + 0], f_buffer[8 * i + 1], -f_buffer[8 * i + 2]);\n    const scale = new THREE.Vector3(f_buffer[8 * i + 3 + 0], f_buffer[8 * i + 3 + 1], f_buffer[8 * i + 3 + 2]);\n    const mtx = new THREE.Matrix4();\n    mtx.makeRotationFromQuaternion(quat);\n    mtx.transpose();\n    mtx.scale(scale);\n    const mtx_t = mtx.clone();\n    mtx.transpose();\n    mtx.premultiply(mtx_t);\n    mtx.setPosition(center);\n    const cov_indexes = [0, 1, 2, 5, 6, 10];\n    let max_value = 0.0;\n    for (let j = 0; j < cov_indexes.length; j++) if (Math.abs(mtx.elements[cov_indexes[j]]) > max_value) max_value = Math.abs(mtx.elements[cov_indexes[j]]);\n    let destOffset = shared.loadedVertexCount * 4 + i * 4;\n    shared.centerAndScaleData[destOffset + 0] = center.x;\n    shared.centerAndScaleData[destOffset + 1] = -center.y;\n    shared.centerAndScaleData[destOffset + 2] = center.z;\n    shared.centerAndScaleData[destOffset + 3] = max_value / 32767.0;\n    destOffset = shared.loadedVertexCount * 8 + i * 4 * 2;\n    for (let j = 0; j < cov_indexes.length; j++) covAndColorData_int16[destOffset + j] = mtx.elements[cov_indexes[j]] * 32767.0 / max_value;\n\n    // RGBA\n    destOffset = shared.loadedVertexCount * 16 + (i * 4 + 3) * 4;\n    const col = new THREE.Color(u_buffer[32 * i + 24 + 0] / 255, u_buffer[32 * i + 24 + 1] / 255, u_buffer[32 * i + 24 + 2] / 255);\n    col.convertSRGBToLinear();\n    covAndColorData_uint8[destOffset + 0] = col.r * 255;\n    covAndColorData_uint8[destOffset + 1] = col.g * 255;\n    covAndColorData_uint8[destOffset + 2] = col.b * 255;\n    covAndColorData_uint8[destOffset + 3] = u_buffer[32 * i + 24 + 3];\n\n    // Store scale and transparent to remove splat in sorting process\n    mtx.elements[15] = Math.max(scale.x, scale.y, scale.z) * u_buffer[32 * i + 24 + 3] / 255.0;\n    for (let j = 0; j < 16; j++) matrices[i * 16 + j] = mtx.elements[j];\n  }\n  while (vertexCount > 0) {\n    let width = 0;\n    let height = 0;\n    const xoffset = shared.loadedVertexCount % shared.bufferTextureWidth;\n    const yoffset = Math.floor(shared.loadedVertexCount / shared.bufferTextureWidth);\n    if (shared.loadedVertexCount % shared.bufferTextureWidth != 0) {\n      width = Math.min(shared.bufferTextureWidth, xoffset + vertexCount) - xoffset;\n      height = 1;\n    } else if (Math.floor(vertexCount / shared.bufferTextureWidth) > 0) {\n      width = shared.bufferTextureWidth;\n      height = Math.floor(vertexCount / shared.bufferTextureWidth);\n    } else {\n      width = vertexCount % shared.bufferTextureWidth;\n      height = 1;\n    }\n    const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n    context.bindTexture(context.TEXTURE_2D, centerAndScaleTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height, context.RGBA, context.FLOAT, shared.centerAndScaleData, shared.loadedVertexCount * 4);\n    const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n    context.bindTexture(context.TEXTURE_2D, covAndColorTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height,\n    // @ts-ignore\n    context.RGBA_INTEGER, context.UNSIGNED_INT, shared.covAndColorData, shared.loadedVertexCount * 4);\n    shared.gl.resetState();\n    shared.loadedVertexCount += width * height;\n    vertexCount -= width * height;\n  }\n  return matrices;\n}\nfunction Splat(_ref) {\n  let {\n      src,\n      toneMapped = false,\n      alphaTest = 0,\n      alphaHash = false,\n      chunkSize = 25000\n    } = _ref,\n    props = _objectWithoutProperties(_ref, _excluded);\n  extend({\n    SplatMaterial\n  });\n  const ref = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const camera = useThree(state => state.camera);\n\n  // Shared state, globally memoized, the same url re-uses the same daza\n  const shared = useLoader(SplatLoader, src, loader => {\n    loader.gl = gl;\n    loader.chunkSize = chunkSize;\n  });\n\n  // Listen to worker results, apply them to the target mesh\n  React.useLayoutEffect(() => shared.connect(ref.current), [src]);\n  // Update the worker\n  useFrame(() => shared.update(ref.current, camera, alphaHash));\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref,\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"splatMaterial\", {\n    key: \"\".concat(src, \"/\").concat(alphaTest, \"/\").concat(alphaHash).concat(SplatMaterial.key),\n    transparent: !alphaHash,\n    depthTest: true,\n    alphaTest: alphaHash ? 0 : alphaTest,\n    centerAndScaleTexture: shared.centerAndScaleTexture,\n    covAndColorTexture: shared.covAndColorTexture,\n    depthWrite: alphaHash ? true : alphaTest > 0,\n    blending: alphaHash ? THREE.NormalBlending : THREE.CustomBlending,\n    blendSrcAlpha: THREE.OneFactor,\n    alphaHash: !!alphaHash,\n    toneMapped: toneMapped\n  }));\n}\nexport { Splat };","map":{"version":3,"names":["_extends","THREE","React","extend","useThree","useLoader","useFrame","shaderMaterial","version","SplatMaterial","alphaTest","viewport","Vector2","focal","centerAndScaleTexture","covAndColorTexture","concat","createWorker","self","matrices","offset","sortSplats","view","hashed","arguments","length","undefined","vertexCount","threshold","maxDepth","Infinity","minDepth","depthList","Float32Array","sizeList","Int32Array","buffer","validIndexList","validCount","i","depth","depthInv","counts0","Uint32Array","starts0","depthIndex","onmessage","e","data","method","new_matrices","set","indices","postMessage","key","SplatLoader","Loader","constructor","gl","chunkSize","load","url","onLoad","onProgress","onError","shared","manager","resolveURL","worker","Worker","URL","createObjectURL","Blob","toString","type","update","target","camera","connect","loading","loaded","loadedVertexCount","totalDownloadBytes","numVertices","rowLength","maxVertexes","bufferTextureWidth","bufferTextureHeight","stream","centerAndScaleData","covAndColorData","then","catch","itemError","itemStart","fetch","body","_totalDownloadBytes","headers","get","parseInt","getReader","Math","floor","context","getContext","maxTextureSize","getParameter","MAX_TEXTURE_SIZE","DataTexture","RGBAFormat","FloatType","needsUpdate","RGBAIntegerFormat","UnsignedIntType","internalFormat","lazyLoad","bytesDownloaded","bytesProcessed","chunks","lastReportedProgress","lengthComputable","value","done","read","percent","event","ProgressEvent","total","push","bytesRemains","concatenatedChunksbuffer","Uint8Array","chunk","extra_data","subarray","byteLength","pushDataBuffer","src","error","console","concatenatedChunks","reduce","acc","itemEnd","updateMatrixWorld","getCurrentViewport","material","x","z","y","w","abs","projectionMatrix","elements","ready","sorted","modelViewMatrix","uuid","pm","Matrix4","vm1","vm2","Vector4","splatIndexArray","splatIndexes","InstancedBufferAttribute","setUsage","DynamicDrawUsage","geometry","InstancedBufferGeometry","positionsArray","positions","BufferAttribute","setAttribute","setXYZ","instanceCount","listener","indexes","attributes","splatIndex","addEventListener","wait","centerAndScaleTextureProperties","properties","covAndColorTextureProperties","__webglTexture","Promise","resolve","setTimeout","removeEventListener","u_buffer","f_buffer","covAndColorData_uint8","covAndColorData_int16","Int16Array","quat","Quaternion","invert","center","Vector3","scale","mtx","makeRotationFromQuaternion","transpose","mtx_t","clone","premultiply","setPosition","cov_indexes","max_value","j","destOffset","col","Color","convertSRGBToLinear","r","g","b","max","width","height","xoffset","yoffset","min","bindTexture","TEXTURE_2D","texSubImage2D","RGBA","FLOAT","RGBA_INTEGER","UNSIGNED_INT","resetState","Splat","_ref","toneMapped","alphaHash","props","_objectWithoutProperties","_excluded","ref","useRef","state","loader","useLayoutEffect","current","createElement","frustumCulled","transparent","depthTest","depthWrite","blending","NormalBlending","CustomBlending","blendSrcAlpha","OneFactor"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/@react-three/drei/core/Splat.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { extend, useThree, useLoader, useFrame } from '@react-three/fiber';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { version } from '../helpers/constants.js';\n\nconst SplatMaterial = /* @__PURE__ */shaderMaterial({\n  alphaTest: 0,\n  viewport: /* @__PURE__ */new THREE.Vector2(1980, 1080),\n  focal: 1000.0,\n  centerAndScaleTexture: null,\n  covAndColorTexture: null\n}, /*glsl*/`\n    precision highp sampler2D;\n    precision highp usampler2D;\n    out vec4 vColor;\n    out vec3 vPosition;\n    uniform vec2 resolution;\n    uniform vec2 viewport;\n    uniform float focal;\n    attribute uint splatIndex;\n    uniform sampler2D centerAndScaleTexture;\n    uniform usampler2D covAndColorTexture;    \n\n    vec2 unpackInt16(in uint value) {\n      int v = int(value);\n      int v0 = v >> 16;\n      int v1 = (v & 0xFFFF);\n      if((v & 0x8000) != 0)\n        v1 |= 0xFFFF0000;\n      return vec2(float(v1), float(v0));\n    }\n\n    void main () {\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\n      vec4 camspace = modelViewMatrix * center;\n      vec4 pos2d = projectionMatrix * camspace;\n\n      float bounds = 1.2 * pos2d.w;\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\n        || pos2d.y < -bounds || pos2d.y > bounds) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n      }\n\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\n      mat3 Vrk = mat3(\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\n      );\n\n      mat3 J = mat3(\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\n        0., 0., 0.\n      );\n\n      mat3 W = transpose(mat3(modelViewMatrix));\n      mat3 T = W * J;\n      mat3 cov = transpose(T) * Vrk * T;\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\n      float diagonal1 = cov[0][0] + 0.3;\n      float offDiagonal = cov[0][1];\n      float diagonal2 = cov[1][1] + 0.3;\n      float mid = 0.5 * (diagonal1 + diagonal2);\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n      float lambda1 = mid + radius;\n      float lambda2 = max(mid - radius, 0.1);\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n      uint colorUint = covAndColorData.w;\n      vColor = vec4(\n        float(colorUint & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\n        float(colorUint >> uint(24)) / 255.0\n      );\n      vPosition = position;\n\n      gl_Position = vec4(\n        vCenter \n          + position.x * v2 / viewport * 2.0 \n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\n    }\n    `, /*glsl*/`\n    #include <alphatest_pars_fragment>\n    #include <alphahash_pars_fragment>\n    in vec4 vColor;\n    in vec3 vPosition;\n    void main () {\n      float A = -dot(vPosition.xy, vPosition.xy);\n      if (A < -4.0) discard;\n      float B = exp(A) * vColor.a;\n      vec4 diffuseColor = vec4(vColor.rgb, B);\n      #include <alphatest_fragment>\n      #include <alphahash_fragment>\n      gl_FragColor = diffuseColor;\n      #include <tonemapping_fragment>\n      #include <${version >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n    }\n  `);\nfunction createWorker(self) {\n  let matrices = null;\n  let offset = 0;\n  function sortSplats(view, hashed = false) {\n    const vertexCount = matrices.length / 16;\n    const threshold = -0.0001;\n    let maxDepth = -Infinity;\n    let minDepth = Infinity;\n    const depthList = new Float32Array(vertexCount);\n    const sizeList = new Int32Array(depthList.buffer);\n    const validIndexList = new Int32Array(vertexCount);\n    let validCount = 0;\n    for (let i = 0; i < vertexCount; i++) {\n      // Sign of depth is reversed\n      const depth = view[0] * matrices[i * 16 + 12] + view[1] * matrices[i * 16 + 13] + view[2] * matrices[i * 16 + 14] + view[3];\n      // Skip behind of camera and small, transparent splat\n      if (hashed || depth < 0 && matrices[i * 16 + 15] > threshold * depth) {\n        depthList[validCount] = depth;\n        validIndexList[validCount] = i;\n        validCount++;\n        if (depth > maxDepth) maxDepth = depth;\n        if (depth < minDepth) minDepth = depth;\n      }\n    }\n\n    // This is a 16 bit single-pass counting sort\n    const depthInv = (256 * 256 - 1) / (maxDepth - minDepth);\n    const counts0 = new Uint32Array(256 * 256);\n    for (let i = 0; i < validCount; i++) {\n      sizeList[i] = (depthList[i] - minDepth) * depthInv | 0;\n      counts0[sizeList[i]]++;\n    }\n    const starts0 = new Uint32Array(256 * 256);\n    for (let i = 1; i < 256 * 256; i++) starts0[i] = starts0[i - 1] + counts0[i - 1];\n    const depthIndex = new Uint32Array(validCount);\n    for (let i = 0; i < validCount; i++) depthIndex[starts0[sizeList[i]]++] = validIndexList[i];\n    return depthIndex;\n  }\n  self.onmessage = e => {\n    if (e.data.method == 'push') {\n      if (offset === 0) matrices = new Float32Array(e.data.length);\n      const new_matrices = new Float32Array(e.data.matrices);\n      matrices.set(new_matrices, offset);\n      offset += new_matrices.length;\n    } else if (e.data.method == 'sort') {\n      if (matrices !== null) {\n        const indices = sortSplats(new Float32Array(e.data.view), e.data.hashed);\n        // @ts-ignore\n        self.postMessage({\n          indices,\n          key: e.data.key\n        }, [indices.buffer]);\n      }\n    }\n  };\n}\nclass SplatLoader extends THREE.Loader {\n  constructor(...args) {\n    super(...args);\n    // WebGLRenderer, needs to be filled out!\n    this.gl = null;\n    // Default chunk size for lazy loading\n    this.chunkSize = 25000;\n  }\n  load(url, onLoad, onProgress, onError) {\n    const shared = {\n      gl: this.gl,\n      url: this.manager.resolveURL(url),\n      worker: new Worker(URL.createObjectURL(new Blob(['(', createWorker.toString(), ')(self)'], {\n        type: 'application/javascript'\n      }))),\n      manager: this.manager,\n      update: (target, camera, hashed) => update(camera, shared, target, hashed),\n      connect: target => connect(shared, target),\n      loading: false,\n      loaded: false,\n      loadedVertexCount: 0,\n      chunkSize: this.chunkSize,\n      totalDownloadBytes: 0,\n      numVertices: 0,\n      rowLength: 3 * 4 + 3 * 4 + 4 + 4,\n      maxVertexes: 0,\n      bufferTextureWidth: 0,\n      bufferTextureHeight: 0,\n      stream: null,\n      centerAndScaleData: null,\n      covAndColorData: null,\n      covAndColorTexture: null,\n      centerAndScaleTexture: null,\n      onProgress\n    };\n    load(shared).then(onLoad).catch(e => {\n      onError == null || onError(e);\n      shared.manager.itemError(shared.url);\n    });\n  }\n}\nasync function load(shared) {\n  shared.manager.itemStart(shared.url);\n  const data = await fetch(shared.url);\n  if (data.body === null) throw 'Failed to fetch file';\n  let _totalDownloadBytes = data.headers.get('Content-Length');\n  const totalDownloadBytes = _totalDownloadBytes ? parseInt(_totalDownloadBytes) : undefined;\n  if (totalDownloadBytes == undefined) throw 'Failed to get content length';\n  shared.stream = data.body.getReader();\n  shared.totalDownloadBytes = totalDownloadBytes;\n  shared.numVertices = Math.floor(shared.totalDownloadBytes / shared.rowLength);\n  const context = shared.gl.getContext();\n  let maxTextureSize = context.getParameter(context.MAX_TEXTURE_SIZE);\n  shared.maxVertexes = maxTextureSize * maxTextureSize;\n  if (shared.numVertices > shared.maxVertexes) shared.numVertices = shared.maxVertexes;\n  shared.bufferTextureWidth = maxTextureSize;\n  shared.bufferTextureHeight = Math.floor((shared.numVertices - 1) / maxTextureSize) + 1;\n  shared.centerAndScaleData = new Float32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.covAndColorData = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight * 4);\n  shared.centerAndScaleTexture = new THREE.DataTexture(shared.centerAndScaleData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAFormat, THREE.FloatType);\n  shared.centerAndScaleTexture.needsUpdate = true;\n  shared.covAndColorTexture = new THREE.DataTexture(shared.covAndColorData, shared.bufferTextureWidth, shared.bufferTextureHeight, THREE.RGBAIntegerFormat, THREE.UnsignedIntType);\n  shared.covAndColorTexture.internalFormat = 'RGBA32UI';\n  shared.covAndColorTexture.needsUpdate = true;\n  return shared;\n}\nasync function lazyLoad(shared) {\n  shared.loading = true;\n  let bytesDownloaded = 0;\n  let bytesProcessed = 0;\n  const chunks = [];\n  let lastReportedProgress = 0;\n  const lengthComputable = shared.totalDownloadBytes !== 0;\n  while (true) {\n    try {\n      const {\n        value,\n        done\n      } = await shared.stream.read();\n      if (done) break;\n      bytesDownloaded += value.length;\n      if (shared.totalDownloadBytes != undefined) {\n        const percent = bytesDownloaded / shared.totalDownloadBytes * 100;\n        if (shared.onProgress && percent - lastReportedProgress > 1) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: bytesDownloaded,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n          lastReportedProgress = percent;\n        }\n      }\n      chunks.push(value);\n      const bytesRemains = bytesDownloaded - bytesProcessed;\n      if (shared.totalDownloadBytes != undefined && bytesRemains > shared.rowLength * shared.chunkSize) {\n        let vertexCount = Math.floor(bytesRemains / shared.rowLength);\n        const concatenatedChunksbuffer = new Uint8Array(bytesRemains);\n        let offset = 0;\n        for (const chunk of chunks) {\n          concatenatedChunksbuffer.set(chunk, offset);\n          offset += chunk.length;\n        }\n        chunks.length = 0;\n        if (bytesRemains > vertexCount * shared.rowLength) {\n          const extra_data = new Uint8Array(bytesRemains - vertexCount * shared.rowLength);\n          extra_data.set(concatenatedChunksbuffer.subarray(bytesRemains - extra_data.length, bytesRemains), 0);\n          chunks.push(extra_data);\n        }\n        const buffer = new Uint8Array(vertexCount * shared.rowLength);\n        buffer.set(concatenatedChunksbuffer.subarray(0, buffer.byteLength), 0);\n        const matrices = pushDataBuffer(shared, buffer.buffer, vertexCount);\n        shared.worker.postMessage({\n          method: 'push',\n          src: shared.url,\n          length: shared.numVertices * 16,\n          matrices: matrices.buffer\n        }, [matrices.buffer]);\n        bytesProcessed += vertexCount * shared.rowLength;\n        if (shared.onProgress) {\n          const event = new ProgressEvent('progress', {\n            lengthComputable,\n            loaded: shared.totalDownloadBytes,\n            total: shared.totalDownloadBytes\n          });\n          shared.onProgress(event);\n        }\n      }\n    } catch (error) {\n      console.error(error);\n      break;\n    }\n  }\n  if (bytesDownloaded - bytesProcessed > 0) {\n    // Concatenate the chunks into a single Uint8Array\n    let concatenatedChunks = new Uint8Array(chunks.reduce((acc, chunk) => acc + chunk.length, 0));\n    let offset = 0;\n    for (const chunk of chunks) {\n      concatenatedChunks.set(chunk, offset);\n      offset += chunk.length;\n    }\n    let numVertices = Math.floor(concatenatedChunks.byteLength / shared.rowLength);\n    const matrices = pushDataBuffer(shared, concatenatedChunks.buffer, numVertices);\n    shared.worker.postMessage({\n      method: 'push',\n      src: shared.url,\n      length: numVertices * 16,\n      matrices: matrices.buffer\n    }, [matrices.buffer]);\n  }\n  shared.loaded = true;\n  shared.manager.itemEnd(shared.url);\n}\nfunction update(camera, shared, target, hashed) {\n  camera.updateMatrixWorld();\n  shared.gl.getCurrentViewport(target.viewport);\n  // @ts-ignore\n  target.material.viewport.x = target.viewport.z;\n  // @ts-ignore\n  target.material.viewport.y = target.viewport.w;\n  target.material.focal = target.viewport.w / 2.0 * Math.abs(camera.projectionMatrix.elements[5]);\n  if (target.ready) {\n    if (hashed && target.sorted) return;\n    target.ready = false;\n    const view = new Float32Array([target.modelViewMatrix.elements[2], -target.modelViewMatrix.elements[6], target.modelViewMatrix.elements[10], target.modelViewMatrix.elements[14]]);\n    shared.worker.postMessage({\n      method: 'sort',\n      src: shared.url,\n      key: target.uuid,\n      view: view.buffer,\n      hashed\n    }, [view.buffer]);\n    if (hashed && shared.loaded) target.sorted = true;\n  }\n}\nfunction connect(shared, target) {\n  if (!shared.loading) lazyLoad(shared);\n  target.ready = false;\n  target.pm = new THREE.Matrix4();\n  target.vm1 = new THREE.Matrix4();\n  target.vm2 = new THREE.Matrix4();\n  target.viewport = new THREE.Vector4();\n  let splatIndexArray = new Uint32Array(shared.bufferTextureWidth * shared.bufferTextureHeight);\n  const splatIndexes = new THREE.InstancedBufferAttribute(splatIndexArray, 1, false);\n  splatIndexes.setUsage(THREE.DynamicDrawUsage);\n  const geometry = target.geometry = new THREE.InstancedBufferGeometry();\n  const positionsArray = new Float32Array(6 * 3);\n  const positions = new THREE.BufferAttribute(positionsArray, 3);\n  geometry.setAttribute('position', positions);\n  positions.setXYZ(2, -2.0, 2.0, 0.0);\n  positions.setXYZ(1, 2.0, 2.0, 0.0);\n  positions.setXYZ(0, -2.0, -2.0, 0.0);\n  positions.setXYZ(5, -2.0, -2.0, 0.0);\n  positions.setXYZ(4, 2.0, 2.0, 0.0);\n  positions.setXYZ(3, 2.0, -2.0, 0.0);\n  positions.needsUpdate = true;\n  geometry.setAttribute('splatIndex', splatIndexes);\n  geometry.instanceCount = 1;\n  function listener(e) {\n    if (target && e.data.key === target.uuid) {\n      let indexes = new Uint32Array(e.data.indices);\n      // @ts-ignore\n      geometry.attributes.splatIndex.set(indexes);\n      geometry.attributes.splatIndex.needsUpdate = true;\n      geometry.instanceCount = indexes.length;\n      target.ready = true;\n    }\n  }\n  shared.worker.addEventListener('message', listener);\n  async function wait() {\n    while (true) {\n      const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n      const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n      if (centerAndScaleTextureProperties != null && centerAndScaleTextureProperties.__webglTexture && covAndColorTextureProperties != null && covAndColorTextureProperties.__webglTexture && shared.loadedVertexCount > 0) break;\n      await new Promise(resolve => setTimeout(resolve, 10));\n    }\n    target.ready = true;\n  }\n  wait();\n  return () => shared.worker.removeEventListener('message', listener);\n}\nfunction pushDataBuffer(shared, buffer, vertexCount) {\n  const context = shared.gl.getContext();\n  if (shared.loadedVertexCount + vertexCount > shared.maxVertexes) vertexCount = shared.maxVertexes - shared.loadedVertexCount;\n  if (vertexCount <= 0) throw 'Failed to parse file';\n  const u_buffer = new Uint8Array(buffer);\n  const f_buffer = new Float32Array(buffer);\n  const matrices = new Float32Array(vertexCount * 16);\n  const covAndColorData_uint8 = new Uint8Array(shared.covAndColorData.buffer);\n  const covAndColorData_int16 = new Int16Array(shared.covAndColorData.buffer);\n  for (let i = 0; i < vertexCount; i++) {\n    const quat = new THREE.Quaternion(-(u_buffer[32 * i + 28 + 1] - 128) / 128.0, (u_buffer[32 * i + 28 + 2] - 128) / 128.0, (u_buffer[32 * i + 28 + 3] - 128) / 128.0, -(u_buffer[32 * i + 28 + 0] - 128) / 128.0);\n    quat.invert();\n    const center = new THREE.Vector3(f_buffer[8 * i + 0], f_buffer[8 * i + 1], -f_buffer[8 * i + 2]);\n    const scale = new THREE.Vector3(f_buffer[8 * i + 3 + 0], f_buffer[8 * i + 3 + 1], f_buffer[8 * i + 3 + 2]);\n    const mtx = new THREE.Matrix4();\n    mtx.makeRotationFromQuaternion(quat);\n    mtx.transpose();\n    mtx.scale(scale);\n    const mtx_t = mtx.clone();\n    mtx.transpose();\n    mtx.premultiply(mtx_t);\n    mtx.setPosition(center);\n    const cov_indexes = [0, 1, 2, 5, 6, 10];\n    let max_value = 0.0;\n    for (let j = 0; j < cov_indexes.length; j++) if (Math.abs(mtx.elements[cov_indexes[j]]) > max_value) max_value = Math.abs(mtx.elements[cov_indexes[j]]);\n    let destOffset = shared.loadedVertexCount * 4 + i * 4;\n    shared.centerAndScaleData[destOffset + 0] = center.x;\n    shared.centerAndScaleData[destOffset + 1] = -center.y;\n    shared.centerAndScaleData[destOffset + 2] = center.z;\n    shared.centerAndScaleData[destOffset + 3] = max_value / 32767.0;\n    destOffset = shared.loadedVertexCount * 8 + i * 4 * 2;\n    for (let j = 0; j < cov_indexes.length; j++) covAndColorData_int16[destOffset + j] = mtx.elements[cov_indexes[j]] * 32767.0 / max_value;\n\n    // RGBA\n    destOffset = shared.loadedVertexCount * 16 + (i * 4 + 3) * 4;\n    const col = new THREE.Color(u_buffer[32 * i + 24 + 0] / 255, u_buffer[32 * i + 24 + 1] / 255, u_buffer[32 * i + 24 + 2] / 255);\n    col.convertSRGBToLinear();\n    covAndColorData_uint8[destOffset + 0] = col.r * 255;\n    covAndColorData_uint8[destOffset + 1] = col.g * 255;\n    covAndColorData_uint8[destOffset + 2] = col.b * 255;\n    covAndColorData_uint8[destOffset + 3] = u_buffer[32 * i + 24 + 3];\n\n    // Store scale and transparent to remove splat in sorting process\n    mtx.elements[15] = Math.max(scale.x, scale.y, scale.z) * u_buffer[32 * i + 24 + 3] / 255.0;\n    for (let j = 0; j < 16; j++) matrices[i * 16 + j] = mtx.elements[j];\n  }\n  while (vertexCount > 0) {\n    let width = 0;\n    let height = 0;\n    const xoffset = shared.loadedVertexCount % shared.bufferTextureWidth;\n    const yoffset = Math.floor(shared.loadedVertexCount / shared.bufferTextureWidth);\n    if (shared.loadedVertexCount % shared.bufferTextureWidth != 0) {\n      width = Math.min(shared.bufferTextureWidth, xoffset + vertexCount) - xoffset;\n      height = 1;\n    } else if (Math.floor(vertexCount / shared.bufferTextureWidth) > 0) {\n      width = shared.bufferTextureWidth;\n      height = Math.floor(vertexCount / shared.bufferTextureWidth);\n    } else {\n      width = vertexCount % shared.bufferTextureWidth;\n      height = 1;\n    }\n    const centerAndScaleTextureProperties = shared.gl.properties.get(shared.centerAndScaleTexture);\n    context.bindTexture(context.TEXTURE_2D, centerAndScaleTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height, context.RGBA, context.FLOAT, shared.centerAndScaleData, shared.loadedVertexCount * 4);\n    const covAndColorTextureProperties = shared.gl.properties.get(shared.covAndColorTexture);\n    context.bindTexture(context.TEXTURE_2D, covAndColorTextureProperties.__webglTexture);\n    context.texSubImage2D(context.TEXTURE_2D, 0, xoffset, yoffset, width, height,\n    // @ts-ignore\n    context.RGBA_INTEGER, context.UNSIGNED_INT, shared.covAndColorData, shared.loadedVertexCount * 4);\n    shared.gl.resetState();\n    shared.loadedVertexCount += width * height;\n    vertexCount -= width * height;\n  }\n  return matrices;\n}\nfunction Splat({\n  src,\n  toneMapped = false,\n  alphaTest = 0,\n  alphaHash = false,\n  chunkSize = 25000,\n  ...props\n}) {\n  extend({\n    SplatMaterial\n  });\n  const ref = React.useRef(null);\n  const gl = useThree(state => state.gl);\n  const camera = useThree(state => state.camera);\n\n  // Shared state, globally memoized, the same url re-uses the same daza\n  const shared = useLoader(SplatLoader, src, loader => {\n    loader.gl = gl;\n    loader.chunkSize = chunkSize;\n  });\n\n  // Listen to worker results, apply them to the target mesh\n  React.useLayoutEffect(() => shared.connect(ref.current), [src]);\n  // Update the worker\n  useFrame(() => shared.update(ref.current, camera, alphaHash));\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({\n    ref: ref,\n    frustumCulled: false\n  }, props), /*#__PURE__*/React.createElement(\"splatMaterial\", {\n    key: `${src}/${alphaTest}/${alphaHash}${SplatMaterial.key}`,\n    transparent: !alphaHash,\n    depthTest: true,\n    alphaTest: alphaHash ? 0 : alphaTest,\n    centerAndScaleTexture: shared.centerAndScaleTexture,\n    covAndColorTexture: shared.covAndColorTexture,\n    depthWrite: alphaHash ? true : alphaTest > 0,\n    blending: alphaHash ? THREE.NormalBlending : THREE.CustomBlending,\n    blendSrcAlpha: THREE.OneFactor,\n    alphaHash: !!alphaHash,\n    toneMapped: toneMapped\n  }));\n}\n\nexport { Splat };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}