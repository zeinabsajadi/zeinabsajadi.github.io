{"ast":null,"code":"\"use client\";\n\nimport { motionValue } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nimport { useRef, useCallback, useEffect } from 'react';\nimport { scroll } from '../render/dom/scroll/index.mjs';\nimport { canUseNativeTimeline } from '../render/dom/scroll/utils/can-use-native-timeline.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nconst createScrollMotionValues = () => ({\n  scrollX: motionValue(0),\n  scrollY: motionValue(0),\n  scrollXProgress: motionValue(0),\n  scrollYProgress: motionValue(0)\n});\nconst isRefPending = ref => {\n  if (!ref) return false;\n  return !ref.current;\n};\nfunction makeAccelerateConfig(axis, options, container) {\n  return {\n    factory: animation => scroll(animation, {\n      ...options,\n      axis,\n      container\n    }),\n    times: [0, 1],\n    keyframes: [0, 1],\n    ease: v => v,\n    duration: 1\n  };\n}\nfunction useScroll({\n  container,\n  target,\n  ...options\n} = {}) {\n  const values = useConstant(createScrollMotionValues);\n  if (!target && canUseNativeTimeline()) {\n    const resolvedContainer = container?.current || undefined;\n    values.scrollXProgress.accelerate = makeAccelerateConfig(\"x\", options, resolvedContainer);\n    values.scrollYProgress.accelerate = makeAccelerateConfig(\"y\", options, resolvedContainer);\n  }\n  const scrollAnimation = useRef(null);\n  const needsStart = useRef(false);\n  const start = useCallback(() => {\n    scrollAnimation.current = scroll((_progress, {\n      x,\n      y\n    }) => {\n      values.scrollX.set(x.current);\n      values.scrollXProgress.set(x.progress);\n      values.scrollY.set(y.current);\n      values.scrollYProgress.set(y.progress);\n    }, {\n      ...options,\n      container: container?.current || undefined,\n      target: target?.current || undefined\n    });\n    return () => {\n      scrollAnimation.current?.();\n    };\n  }, [container, target, JSON.stringify(options.offset)]);\n  useIsomorphicLayoutEffect(() => {\n    needsStart.current = false;\n    if (isRefPending(container) || isRefPending(target)) {\n      needsStart.current = true;\n      return;\n    } else {\n      return start();\n    }\n  }, [start]);\n  useEffect(() => {\n    if (needsStart.current) {\n      invariant(!isRefPending(container), \"Container ref is defined but not hydrated\", \"use-scroll-ref\");\n      invariant(!isRefPending(target), \"Target ref is defined but not hydrated\", \"use-scroll-ref\");\n      return start();\n    } else {\n      return;\n    }\n  }, [start]);\n  return values;\n}\nexport { useScroll };","map":{"version":3,"names":["createScrollMotionValues","scrollX","motionValue","scrollY","scrollXProgress","scrollYProgress","isRefPending","ref","current","makeAccelerateConfig","axis","options","container","factory","animation","scroll","times","keyframes","ease","v","duration","useScroll","target","values","useConstant","canUseNativeTimeline","resolvedContainer","undefined","accelerate","scrollAnimation","useRef","needsStart","start","useCallback","_progress","x","y","JSON","stringify","offset"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/value/use-scroll.ts"],"sourcesContent":["\"use client\"\n\nimport { AnimationPlaybackControls, motionValue } from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\nimport { RefObject, useCallback, useEffect, useRef } from \"react\"\nimport { scroll } from \"../render/dom/scroll\"\nimport { ScrollInfoOptions } from \"../render/dom/scroll/types\"\nimport { canUseNativeTimeline } from \"../render/dom/scroll/utils/can-use-native-timeline\"\nimport { useConstant } from \"../utils/use-constant\"\nimport { useIsomorphicLayoutEffect } from \"../utils/use-isomorphic-effect\"\n\nexport interface UseScrollOptions\n    extends Omit<ScrollInfoOptions, \"container\" | \"target\"> {\n    container?: RefObject<HTMLElement | null>\n    target?: RefObject<HTMLElement | null>\n}\n\nconst createScrollMotionValues = () => ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n})\n\nconst isRefPending = (ref?: RefObject<HTMLElement | null>) => {\n    if (!ref) return false\n    return !ref.current\n}\n\nfunction makeAccelerateConfig(\n    axis: \"x\" | \"y\",\n    options: Omit<UseScrollOptions, \"container\" | \"target\">,\n    container?: Element\n) {\n    return {\n        factory: (animation: AnimationPlaybackControls) =>\n            scroll(animation, { ...options, axis, container }),\n        times: [0, 1],\n        keyframes: [0, 1],\n        ease: (v: number) => v,\n        duration: 1,\n    }\n}\n\nexport function useScroll({\n    container,\n    target,\n    ...options\n}: UseScrollOptions = {}) {\n    const values = useConstant(createScrollMotionValues)\n\n    if (!target && canUseNativeTimeline()) {\n        const resolvedContainer = container?.current || undefined\n        values.scrollXProgress.accelerate = makeAccelerateConfig(\n            \"x\",\n            options,\n            resolvedContainer\n        )\n        values.scrollYProgress.accelerate = makeAccelerateConfig(\n            \"y\",\n            options,\n            resolvedContainer\n        )\n    }\n\n    const scrollAnimation = useRef<VoidFunction | null>(null)\n    const needsStart = useRef(false)\n\n    const start = useCallback(() => {\n        scrollAnimation.current = scroll(\n            (\n                _progress: number,\n                {\n                    x,\n                    y,\n                }: {\n                    x: { current: number; progress: number }\n                    y: { current: number; progress: number }\n                }\n            ) => {\n                values.scrollX.set(x.current)\n                values.scrollXProgress.set(x.progress)\n                values.scrollY.set(y.current)\n                values.scrollYProgress.set(y.progress)\n            },\n            {\n                ...options,\n                container: container?.current || undefined,\n                target: target?.current || undefined,\n            }\n        )\n\n        return () => {\n            scrollAnimation.current?.()\n        }\n    }, [container, target, JSON.stringify(options.offset)])\n\n    useIsomorphicLayoutEffect(() => {\n        needsStart.current = false\n\n        if (isRefPending(container) || isRefPending(target)) {\n            needsStart.current = true\n            return\n        } else {\n            return start()\n        }\n    }, [start])\n\n    useEffect(() => {\n        if (needsStart.current) {\n            invariant(\n                !isRefPending(container),\n                \"Container ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            invariant(\n                !isRefPending(target),\n                \"Target ref is defined but not hydrated\",\n                \"use-scroll-ref\"\n            )\n            return start()\n        } else {\n            return\n        }\n    }, [start])\n\n    return values\n}\n"],"mappings":";;;;;;;;;AAiBA,MAAAA,wBAAA,GAAAA,CAAA;EACIC,OAAA,EAAAC,WAAA;EACAC,OAAA,EAAAD,WAAA;EACAE,eAAA,EAAAF,WAAA;EACAG,eAAA,EAAAH,WAAA;AACH;AAED,MAAAI,YAAA,GAAAC,GAAA;EACI,KAAAA,GAAA,EAAU;EACV,QAAAA,GAAA,CAAAC,OAAA;AACJ;AAEA,SAAAC,qBAAAC,IAAA,EAAAC,OAAA,EAAAC,SAAA;;IAMQC,OAAA,EAAAC,SAAA,IAAAC,MAAA,CAAAD,SAAA;MAAA,GAAAH,OAAA;MAAAD,IAAA;MAAAE;IAAA;IAEAI,KAAA;IACAC,SAAA;IACAC,IAAA,EAAAC,CAAA,IAAAA,CAAA;IACAC,QAAA;;AAER;AAEM,SAAAC,UAAA;EAAAT,SAAA;EAAAU,MAAA;EAAA,GAAAX;AAAA;EAKF,MAAAY,MAAA,GAAAC,WAAA,CAAAxB,wBAAA;EAEA,KAAAsB,MAAA,IAAAG,oBAAA;IACI,MAAAC,iBAAA,GAAAd,SAAA,EAAAJ,OAAA,IAAAmB,SAAA;IACAJ,MAAA,CAAAnB,eAAA,CAAAwB,UAAA,GAAAnB,oBAAA,MAAAE,OAAA,EAAAe,iBAAA;IAKAH,MAAA,CAAAlB,eAAA,CAAAuB,UAAA,GAAAnB,oBAAA,MAAAE,OAAA,EAAAe,iBAAA;;EAOJ,MAAAG,eAAA,GAAAC,MAAA;EACA,MAAAC,UAAA,GAAAD,MAAA;EAEA,MAAAE,KAAA,GAAAC,WAAA;IACIJ,eAAA,CAAArB,OAAA,GAAAO,MAAA,EAAAmB,SAAA;MAAAC,CAAA;MAAAC;IAAA;;;;;IAeI;MAEI,GAAAzB,OAAA;MACAC,SAAA,EAAAA,SAAA,EAAAJ,OAAA,IAAAmB,SAAA;MACAL,MAAA,EAAAA,MAAA,EAAAd,OAAA,IAAAmB;IACH;IAGL;MACIE,eAAA,CAAArB,OAAA;IACJ;EACJ,IAAAI,SAAA,EAAAU,MAAA,EAAAe,IAAA,CAAAC,SAAA,CAAA3B,OAAA,CAAA4B,MAAA;;IAGIR,UAAA,CAAAvB,OAAA;;MAGIuB,UAAA,CAAAvB,OAAA;;;;;EAKR,IAAAwB,KAAA;;IAGI,IAAAD,UAAA,CAAAvB,OAAA;;;;;;;EAeJ,IAAAwB,KAAA;EAEA,OAAAT,MAAA;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}