{"ast":null,"code":"import * as React from 'react';\n\n/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs(...refs) {\n  return node => {\n    let hasCleanup = false;\n    const cleanups = refs.map(ref => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup === \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup === \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs(...refs) {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\nexport { useComposedRefs };","map":{"version":3,"names":["setRef","ref","value","undefined","current","composeRefs","refs","node","hasCleanup","cleanups","map","cleanup","i","length","useComposedRefs","React","useCallback"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/utils/use-composed-ref.ts"],"sourcesContent":["/**\n * Taken from https://github.com/radix-ui/primitives/blob/main/packages/react/compose-refs/src/compose-refs.tsx\n */\nimport * as React from \"react\"\n\ntype PossibleRef<T> = React.Ref<T> | undefined\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T): void | (() => void) {\n    if (typeof ref === \"function\") {\n        return ref(value)\n    } else if (ref !== null && ref !== undefined) {\n        ;(ref as React.MutableRefObject<T>).current = value\n    }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    return (node) => {\n        let hasCleanup = false\n        const cleanups = refs.map((ref) => {\n            const cleanup = setRef(ref, node)\n            if (!hasCleanup && typeof cleanup === \"function\") {\n                hasCleanup = true\n            }\n            return cleanup\n        })\n        // React <19 will log an error to the console if a callback ref returns a\n        // value. We don't use ref cleanups internally so this will only happen if a\n        // user's ref callback returns a value, which we only expect if they are\n        // using the cleanup functionality added in React 19.\n        if (hasCleanup) {\n            return () => {\n                for (let i = 0; i < cleanups.length; i++) {\n                    const cleanup = cleanups[i]\n                    if (typeof cleanup === \"function\") {\n                        cleanup()\n                    } else {\n                        setRef(refs[i], null)\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    return React.useCallback(composeRefs(...refs), refs)\n}\n\nexport { useComposedRefs }\n"],"mappings":";;AAAA;;AAEG;AAKH;;;AAGG;AACH,SAASA,MAAMA,CAAIC,GAAmB,EAAEC,KAAQ;EAC5C,IAAI,OAAOD,GAAG,KAAK,UAAU,EAAE;IAC3B,OAAOA,GAAG,CAACC,KAAK,CAAC;GACpB,MAAM,IAAID,GAAG,KAAK,IAAI,IAAIA,GAAG,KAAKE,SAAS,EAAE;IACxCF,GAAiC,CAACG,OAAO,GAAGF,KAAK;;AAE3D;AAEA;;;AAGG;AACH,SAASG,WAAWA,CAAI,GAAGC,IAAsB;EAC7C,OAAQC,IAAI,IAAI;IACZ,IAAIC,UAAU,GAAG,KAAK;IACtB,MAAMC,QAAQ,GAAGH,IAAI,CAACI,GAAG,CAAET,GAAG,IAAI;MAC9B,MAAMU,OAAO,GAAGX,MAAM,CAACC,GAAG,EAAEM,IAAI,CAAC;MACjC,IAAI,CAACC,UAAU,IAAI,OAAOG,OAAO,KAAK,UAAU,EAAE;QAC9CH,UAAU,GAAG,IAAI;;MAErB,OAAOG,OAAO;IAClB,CAAC,CAAC;;;;;IAKF,IAAIH,UAAU,EAAE;MACZ,OAAO,MAAK;QACR,KAAK,IAAII,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,QAAQ,CAACI,MAAM,EAAED,CAAC,EAAE,EAAE;UACtC,MAAMD,OAAO,GAAGF,QAAQ,CAACG,CAAC,CAAC;UAC3B,IAAI,OAAOD,OAAO,KAAK,UAAU,EAAE;YAC/BA,OAAO,EAAE;WACZ,MAAM;YACHX,MAAM,CAACM,IAAI,CAACM,CAAC,CAAC,EAAE,IAAI,CAAC;;;MAGjC,CAAC;;EAET,CAAC;AACL;AAEA;;;AAGG;AACH,SAASE,eAAeA,CAAI,GAAGR,IAAsB;;EAEjD,OAAOS,KAAK,CAACC,WAAW,CAACX,WAAW,CAAC,GAAGC,IAAI,CAAC,EAAEA,IAAI,CAAC;AACxD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}