{"ast":null,"code":"import { GroupAnimation } from '../animation/GroupAnimation.mjs';\nimport { copyBoxInto } from '../projection/geometry/copy.mjs';\nimport { createBox } from '../projection/geometry/models.mjs';\nimport { HTMLProjectionNode } from '../projection/node/HTMLProjectionNode.mjs';\nimport { HTMLVisualElement } from '../render/html/HTMLVisualElement.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { resolveElements } from '../utils/resolve-elements.mjs';\nimport { frame } from '../frameloop/frame.mjs';\nconst layoutSelector = \"[data-layout], [data-layout-id]\";\nconst noop = () => {};\nfunction snapshotFromTarget(projection) {\n  const target = projection.targetWithTransforms || projection.target;\n  if (!target) return undefined;\n  const measuredBox = createBox();\n  const layoutBox = createBox();\n  copyBoxInto(measuredBox, target);\n  copyBoxInto(layoutBox, target);\n  return {\n    animationId: projection.root?.animationId ?? 0,\n    measuredBox,\n    layoutBox,\n    latestValues: projection.animationValues || projection.latestValues || {},\n    source: projection.id\n  };\n}\nclass LayoutAnimationBuilder {\n  constructor(scope, updateDom, defaultOptions) {\n    this.sharedTransitions = new Map();\n    this.notifyReady = noop;\n    this.rejectReady = noop;\n    this.scope = scope;\n    this.updateDom = updateDom;\n    this.defaultOptions = defaultOptions;\n    this.readyPromise = new Promise((resolve, reject) => {\n      this.notifyReady = resolve;\n      this.rejectReady = reject;\n    });\n    frame.postRender(() => {\n      this.start().then(this.notifyReady).catch(this.rejectReady);\n    });\n  }\n  shared(id, transition) {\n    this.sharedTransitions.set(id, transition);\n    return this;\n  }\n  then(resolve, reject) {\n    return this.readyPromise.then(resolve, reject);\n  }\n  async start() {\n    const beforeElements = collectLayoutElements(this.scope);\n    const beforeRecords = this.buildRecords(beforeElements);\n    beforeRecords.forEach(({\n      projection\n    }) => {\n      const hasCurrentAnimation = Boolean(projection.currentAnimation);\n      const isSharedLayout = Boolean(projection.options.layoutId);\n      if (hasCurrentAnimation && isSharedLayout) {\n        const snapshot = snapshotFromTarget(projection);\n        if (snapshot) {\n          projection.snapshot = snapshot;\n        } else if (projection.snapshot) {\n          projection.snapshot = undefined;\n        }\n      } else if (projection.snapshot && (projection.currentAnimation || projection.isProjecting())) {\n        projection.snapshot = undefined;\n      }\n      projection.isPresent = true;\n      projection.willUpdate();\n    });\n    await this.updateDom();\n    const afterElements = collectLayoutElements(this.scope);\n    const afterRecords = this.buildRecords(afterElements);\n    this.handleExitingElements(beforeRecords, afterRecords);\n    afterRecords.forEach(({\n      projection\n    }) => {\n      const instance = projection.instance;\n      const resumeFromInstance = projection.resumeFrom?.instance;\n      if (!instance || !resumeFromInstance) return;\n      if (!(\"style\" in instance)) return;\n      const currentTransform = instance.style.transform;\n      const resumeFromTransform = resumeFromInstance.style.transform;\n      if (currentTransform && resumeFromTransform && currentTransform === resumeFromTransform) {\n        instance.style.transform = \"\";\n        instance.style.transformOrigin = \"\";\n      }\n    });\n    afterRecords.forEach(({\n      projection\n    }) => {\n      projection.isPresent = true;\n    });\n    const root = getProjectionRoot(afterRecords, beforeRecords);\n    root?.didUpdate();\n    await new Promise(resolve => {\n      frame.postRender(() => resolve());\n    });\n    const animations = collectAnimations(afterRecords);\n    const animation = new GroupAnimation(animations);\n    return animation;\n  }\n  buildRecords(elements) {\n    const records = [];\n    const recordMap = new Map();\n    for (const element of elements) {\n      const parentRecord = findParentRecord(element, recordMap, this.scope);\n      const {\n        layout,\n        layoutId\n      } = readLayoutAttributes(element);\n      const override = layoutId ? this.sharedTransitions.get(layoutId) : undefined;\n      const transition = override || this.defaultOptions;\n      const record = getOrCreateRecord(element, parentRecord?.projection, {\n        layout,\n        layoutId,\n        animationType: typeof layout === \"string\" ? layout : \"both\",\n        transition: transition\n      });\n      recordMap.set(element, record);\n      records.push(record);\n    }\n    return records;\n  }\n  handleExitingElements(beforeRecords, afterRecords) {\n    const afterElementsSet = new Set(afterRecords.map(record => record.element));\n    beforeRecords.forEach(record => {\n      if (afterElementsSet.has(record.element)) return;\n      // For shared layout elements, relegate to set up resumeFrom\n      // so the remaining element animates from this position\n      if (record.projection.options.layoutId) {\n        record.projection.isPresent = false;\n        record.projection.relegate();\n      }\n      record.visualElement.unmount();\n      visualElementStore.delete(record.element);\n    });\n    // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n    // This prevents crossfade animation when the source element was removed entirely\n    // But preserve resumeFrom for NEW nodes so they can animate from the old position\n    // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n    const beforeElementsSet = new Set(beforeRecords.map(record => record.element));\n    afterRecords.forEach(({\n      element,\n      projection\n    }) => {\n      if (beforeElementsSet.has(element) && projection.resumeFrom && !projection.resumeFrom.instance && !projection.isLead()) {\n        projection.resumeFrom = undefined;\n        projection.snapshot = undefined;\n      }\n    });\n  }\n}\nfunction parseAnimateLayoutArgs(scopeOrUpdateDom, updateDomOrOptions, options) {\n  // animateLayout(updateDom)\n  if (typeof scopeOrUpdateDom === \"function\") {\n    return {\n      scope: document,\n      updateDom: scopeOrUpdateDom,\n      defaultOptions: updateDomOrOptions\n    };\n  }\n  // animateLayout(scope, updateDom, options?)\n  const elements = resolveElements(scopeOrUpdateDom);\n  const scope = elements[0] || document;\n  return {\n    scope,\n    updateDom: updateDomOrOptions,\n    defaultOptions: options\n  };\n}\nfunction collectLayoutElements(scope) {\n  const elements = Array.from(scope.querySelectorAll(layoutSelector));\n  if (scope instanceof Element && scope.matches(layoutSelector)) {\n    if (!elements.includes(scope)) {\n      elements.unshift(scope);\n    }\n  }\n  return elements;\n}\nfunction readLayoutAttributes(element) {\n  const layoutId = element.getAttribute(\"data-layout-id\") || undefined;\n  const rawLayout = element.getAttribute(\"data-layout\");\n  let layout;\n  if (rawLayout === \"\" || rawLayout === \"true\") {\n    layout = true;\n  } else if (rawLayout) {\n    layout = rawLayout;\n  }\n  return {\n    layout,\n    layoutId\n  };\n}\nfunction createVisualState() {\n  return {\n    latestValues: {},\n    renderState: {\n      transform: {},\n      transformOrigin: {},\n      style: {},\n      vars: {}\n    }\n  };\n}\nfunction getOrCreateRecord(element, parentProjection, projectionOptions) {\n  const existing = visualElementStore.get(element);\n  const visualElement = existing ?? new HTMLVisualElement({\n    props: {},\n    presenceContext: null,\n    visualState: createVisualState()\n  }, {\n    allowProjection: true\n  });\n  if (!existing || !visualElement.projection) {\n    visualElement.projection = new HTMLProjectionNode(visualElement.latestValues, parentProjection);\n  }\n  visualElement.projection.setOptions({\n    ...projectionOptions,\n    visualElement\n  });\n  if (!visualElement.current) {\n    visualElement.mount(element);\n  } else if (!visualElement.projection.instance) {\n    // Mount projection if VisualElement is already mounted but projection isn't\n    // This happens when animate() was called before animateLayout()\n    visualElement.projection.mount(element);\n  }\n  if (!existing) {\n    visualElementStore.set(element, visualElement);\n  }\n  return {\n    element,\n    visualElement,\n    projection: visualElement.projection\n  };\n}\nfunction findParentRecord(element, recordMap, scope) {\n  let parent = element.parentElement;\n  while (parent) {\n    const record = recordMap.get(parent);\n    if (record) return record;\n    if (parent === scope) break;\n    parent = parent.parentElement;\n  }\n  return undefined;\n}\nfunction getProjectionRoot(afterRecords, beforeRecords) {\n  const record = afterRecords[0] || beforeRecords[0];\n  return record?.projection.root;\n}\nfunction collectAnimations(afterRecords) {\n  const animations = new Set();\n  afterRecords.forEach(record => {\n    const animation = record.projection.currentAnimation;\n    if (animation) animations.add(animation);\n  });\n  return Array.from(animations);\n}\nexport { LayoutAnimationBuilder, parseAnimateLayoutArgs };","map":{"version":3,"names":["layoutSelector","noop","snapshotFromTarget","projection","target","targetWithTransforms","undefined","measuredBox","createBox","layoutBox","copyBoxInto","animationId","root","latestValues","animationValues","source","id","LayoutAnimationBuilder","constructor","scope","updateDom","defaultOptions","sharedTransitions","Map","notifyReady","rejectReady","readyPromise","Promise","resolve","reject","frame","postRender","start","then","catch","shared","transition","set","beforeElements","collectLayoutElements","beforeRecords","buildRecords","forEach","hasCurrentAnimation","Boolean","currentAnimation","isSharedLayout","options","layoutId","snapshot","isProjecting","isPresent","willUpdate","afterElements","afterRecords","handleExitingElements","instance","resumeFromInstance","resumeFrom","currentTransform","style","transform","resumeFromTransform","transformOrigin","getProjectionRoot","didUpdate","animations","collectAnimations","animation","GroupAnimation","elements","records","recordMap","element","parentRecord","findParentRecord","layout","readLayoutAttributes","override","get","record","getOrCreateRecord","animationType","push","afterElementsSet","Set","map","has","relegate","visualElement","unmount","visualElementStore","delete","beforeElementsSet","isLead","parseAnimateLayoutArgs","scopeOrUpdateDom","updateDomOrOptions","document","resolveElements","Array","from","querySelectorAll","Element","matches","includes","unshift","getAttribute","rawLayout","createVisualState","renderState","vars","parentProjection","projectionOptions","existing","HTMLVisualElement","props","presenceContext","visualState","allowProjection","HTMLProjectionNode","setOptions","current","mount","parent","parentElement","add"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/layout/LayoutAnimationBuilder.ts"],"sourcesContent":["import type { Box } from \"motion-utils\"\nimport { GroupAnimation } from \"../animation/GroupAnimation\"\nimport type {\n    AnimationOptions,\n    AnimationPlaybackControls,\n    Transition,\n} from \"../animation/types\"\nimport { frame } from \"../frameloop\"\nimport { copyBoxInto } from \"../projection/geometry/copy\"\nimport { createBox } from \"../projection/geometry/models\"\nimport { HTMLProjectionNode } from \"../projection/node/HTMLProjectionNode\"\nimport type { IProjectionNode } from \"../projection/node/types\"\nimport { HTMLVisualElement } from \"../render/html/HTMLVisualElement\"\nimport { visualElementStore } from \"../render/store\"\nimport type { VisualElement } from \"../render/VisualElement\"\nimport { resolveElements, type ElementOrSelector } from \"../utils/resolve-elements\"\n\ntype LayoutAnimationScope = Element | Document\n\ninterface LayoutElementRecord {\n    element: Element\n    visualElement: VisualElement\n    projection: IProjectionNode\n}\n\ninterface LayoutAttributes {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n}\n\ntype LayoutBuilderResolve = (animation: GroupAnimation) => void\ntype LayoutBuilderReject = (error: unknown) => void\n\ninterface ProjectionOptions {\n    layout?: boolean | \"position\" | \"size\" | \"preserve-aspect\"\n    layoutId?: string\n    animationType?: \"size\" | \"position\" | \"both\" | \"preserve-aspect\"\n    transition?: Transition\n    crossfade?: boolean\n}\n\nconst layoutSelector = \"[data-layout], [data-layout-id]\"\nconst noop = () => {}\nfunction snapshotFromTarget(projection: IProjectionNode): LayoutElementRecord[\"projection\"][\"snapshot\"] {\n    const target = projection.targetWithTransforms || projection.target\n    if (!target) return undefined\n\n    const measuredBox = createBox()\n    const layoutBox = createBox()\n    copyBoxInto(measuredBox, target as Box)\n    copyBoxInto(layoutBox, target as Box)\n\n    return {\n        animationId: projection.root?.animationId ?? 0,\n        measuredBox,\n        layoutBox,\n        latestValues: projection.animationValues || projection.latestValues || {},\n        source: projection.id,\n    }\n}\n\nexport class LayoutAnimationBuilder {\n    private scope: LayoutAnimationScope\n    private updateDom: () => void | Promise<void>\n    private defaultOptions?: AnimationOptions\n    private sharedTransitions = new Map<string, AnimationOptions>()\n    private notifyReady: LayoutBuilderResolve = noop\n    private rejectReady: LayoutBuilderReject = noop\n    private readyPromise: Promise<GroupAnimation>\n\n    constructor(\n        scope: LayoutAnimationScope,\n        updateDom: () => void | Promise<void>,\n        defaultOptions?: AnimationOptions\n    ) {\n        this.scope = scope\n        this.updateDom = updateDom\n        this.defaultOptions = defaultOptions\n\n        this.readyPromise = new Promise<GroupAnimation>((resolve, reject) => {\n            this.notifyReady = resolve\n            this.rejectReady = reject\n        })\n\n        frame.postRender(() => {\n            this.start().then(this.notifyReady).catch(this.rejectReady)\n        })\n    }\n\n    shared(id: string, transition: AnimationOptions): this {\n        this.sharedTransitions.set(id, transition)\n        return this\n    }\n\n    then(\n        resolve: LayoutBuilderResolve,\n        reject?: LayoutBuilderReject\n    ): Promise<void> {\n        return this.readyPromise.then(resolve, reject)\n    }\n\n    private async start(): Promise<GroupAnimation> {\n        const beforeElements = collectLayoutElements(this.scope)\n        const beforeRecords = this.buildRecords(beforeElements)\n\n        beforeRecords.forEach(({ projection }) => {\n            const hasCurrentAnimation = Boolean(projection.currentAnimation)\n            const isSharedLayout = Boolean(projection.options.layoutId)\n            if (hasCurrentAnimation && isSharedLayout) {\n                const snapshot = snapshotFromTarget(projection)\n                if (snapshot) {\n                    projection.snapshot = snapshot\n                } else if (projection.snapshot) {\n                    projection.snapshot = undefined\n                }\n            } else if (\n                projection.snapshot &&\n                (projection.currentAnimation || projection.isProjecting())\n            ) {\n                projection.snapshot = undefined\n            }\n            projection.isPresent = true\n            projection.willUpdate()\n        })\n\n        await this.updateDom()\n\n        const afterElements = collectLayoutElements(this.scope)\n        const afterRecords = this.buildRecords(afterElements)\n        this.handleExitingElements(beforeRecords, afterRecords)\n\n        afterRecords.forEach(({ projection }) => {\n            const instance = projection.instance as HTMLElement | undefined\n            const resumeFromInstance = projection.resumeFrom\n                ?.instance as HTMLElement | undefined\n            if (!instance || !resumeFromInstance) return\n            if (!(\"style\" in instance)) return\n\n            const currentTransform = instance.style.transform\n            const resumeFromTransform = resumeFromInstance.style.transform\n\n            if (\n                currentTransform &&\n                resumeFromTransform &&\n                currentTransform === resumeFromTransform\n            ) {\n                instance.style.transform = \"\"\n                instance.style.transformOrigin = \"\"\n            }\n        })\n\n        afterRecords.forEach(({ projection }) => {\n            projection.isPresent = true\n        })\n\n        const root = getProjectionRoot(afterRecords, beforeRecords)\n        root?.didUpdate()\n\n        await new Promise<void>((resolve) => {\n            frame.postRender(() => resolve())\n        })\n\n        const animations = collectAnimations(afterRecords)\n        const animation = new GroupAnimation(animations)\n\n        return animation\n    }\n\n    private buildRecords(elements: Element[]): LayoutElementRecord[] {\n        const records: LayoutElementRecord[] = []\n        const recordMap = new Map<Element, LayoutElementRecord>()\n\n        for (const element of elements) {\n            const parentRecord = findParentRecord(element, recordMap, this.scope)\n            const { layout, layoutId } = readLayoutAttributes(element)\n            const override = layoutId\n                ? this.sharedTransitions.get(layoutId)\n                : undefined\n            const transition = override || this.defaultOptions\n            const record = getOrCreateRecord(element, parentRecord?.projection, {\n                layout,\n                layoutId,\n                animationType: typeof layout === \"string\" ? layout : \"both\",\n                transition: transition as Transition,\n            })\n            recordMap.set(element, record)\n            records.push(record)\n        }\n\n        return records\n    }\n\n    private handleExitingElements(\n        beforeRecords: LayoutElementRecord[],\n        afterRecords: LayoutElementRecord[]\n    ): void {\n        const afterElementsSet = new Set(afterRecords.map((record) => record.element))\n\n        beforeRecords.forEach((record) => {\n            if (afterElementsSet.has(record.element)) return\n\n            // For shared layout elements, relegate to set up resumeFrom\n            // so the remaining element animates from this position\n            if (record.projection.options.layoutId) {\n                record.projection.isPresent = false\n                record.projection.relegate()\n            }\n\n            record.visualElement.unmount()\n            visualElementStore.delete(record.element)\n        })\n\n        // Clear resumeFrom on EXISTING nodes that point to unmounted projections\n        // This prevents crossfade animation when the source element was removed entirely\n        // But preserve resumeFrom for NEW nodes so they can animate from the old position\n        // Also preserve resumeFrom for lead nodes that were just promoted via relegate\n        const beforeElementsSet = new Set(beforeRecords.map((record) => record.element))\n        afterRecords.forEach(({ element, projection }) => {\n            if (\n                beforeElementsSet.has(element) &&\n                projection.resumeFrom &&\n                !projection.resumeFrom.instance &&\n                !projection.isLead()\n            ) {\n                projection.resumeFrom = undefined\n                projection.snapshot = undefined\n            }\n        })\n    }\n}\n\nexport function parseAnimateLayoutArgs(\n    scopeOrUpdateDom: ElementOrSelector | (() => void),\n    updateDomOrOptions?: (() => void) | AnimationOptions,\n    options?: AnimationOptions\n): {\n    scope: Element | Document\n    updateDom: () => void\n    defaultOptions?: AnimationOptions\n} {\n    // animateLayout(updateDom)\n    if (typeof scopeOrUpdateDom === \"function\") {\n        return {\n            scope: document,\n            updateDom: scopeOrUpdateDom,\n            defaultOptions: updateDomOrOptions as AnimationOptions | undefined,\n        }\n    }\n\n    // animateLayout(scope, updateDom, options?)\n    const elements = resolveElements(scopeOrUpdateDom)\n    const scope = elements[0] || document\n\n    return {\n        scope,\n        updateDom: updateDomOrOptions as () => void,\n        defaultOptions: options,\n    }\n}\n\nfunction collectLayoutElements(scope: LayoutAnimationScope): Element[] {\n    const elements = Array.from(scope.querySelectorAll(layoutSelector))\n\n    if (scope instanceof Element && scope.matches(layoutSelector)) {\n        if (!elements.includes(scope)) {\n            elements.unshift(scope)\n        }\n    }\n\n    return elements\n}\n\nfunction readLayoutAttributes(element: Element): LayoutAttributes {\n    const layoutId = element.getAttribute(\"data-layout-id\") || undefined\n    const rawLayout = element.getAttribute(\"data-layout\")\n    let layout: LayoutAttributes[\"layout\"]\n\n    if (rawLayout === \"\" || rawLayout === \"true\") {\n        layout = true\n    } else if (rawLayout) {\n        layout = rawLayout as LayoutAttributes[\"layout\"]\n    }\n\n    return {\n        layout,\n        layoutId,\n    }\n}\n\nfunction createVisualState() {\n    return {\n        latestValues: {},\n        renderState: {\n            transform: {},\n            transformOrigin: {},\n            style: {},\n            vars: {},\n        },\n    }\n}\n\nfunction getOrCreateRecord(\n    element: Element,\n    parentProjection?: IProjectionNode,\n    projectionOptions?: ProjectionOptions\n): LayoutElementRecord {\n    const existing = visualElementStore.get(element) as VisualElement | undefined\n    const visualElement =\n        existing ??\n        new HTMLVisualElement(\n            {\n                props: {},\n                presenceContext: null,\n                visualState: createVisualState(),\n            },\n            { allowProjection: true }\n        )\n\n    if (!existing || !visualElement.projection) {\n        visualElement.projection = new HTMLProjectionNode(\n            visualElement.latestValues,\n            parentProjection\n        )\n    }\n\n    visualElement.projection.setOptions({\n        ...projectionOptions,\n        visualElement,\n    })\n\n    if (!visualElement.current) {\n        visualElement.mount(element as HTMLElement)\n    } else if (!visualElement.projection.instance) {\n        // Mount projection if VisualElement is already mounted but projection isn't\n        // This happens when animate() was called before animateLayout()\n        visualElement.projection.mount(element as HTMLElement)\n    }\n\n    if (!existing) {\n        visualElementStore.set(element, visualElement)\n    }\n\n    return {\n        element,\n        visualElement,\n        projection: visualElement.projection as IProjectionNode,\n    }\n}\n\nfunction findParentRecord(\n    element: Element,\n    recordMap: Map<Element, LayoutElementRecord>,\n    scope: LayoutAnimationScope\n) {\n    let parent = element.parentElement\n\n    while (parent) {\n        const record = recordMap.get(parent)\n        if (record) return record\n\n        if (parent === scope) break\n        parent = parent.parentElement\n    }\n\n    return undefined\n}\n\nfunction getProjectionRoot(\n    afterRecords: LayoutElementRecord[],\n    beforeRecords: LayoutElementRecord[]\n) {\n    const record = afterRecords[0] || beforeRecords[0]\n    return record?.projection.root\n}\n\nfunction collectAnimations(afterRecords: LayoutElementRecord[]) {\n    const animations = new Set<AnimationPlaybackControls>()\n\n    afterRecords.forEach((record) => {\n        const animation = record.projection.currentAnimation\n        if (animation) animations.add(animation)\n    })\n\n    return Array.from(animations)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}