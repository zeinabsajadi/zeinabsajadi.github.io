{"ast":null,"code":"import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { calcChildStagger } from '../utils/calc-child-stagger.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\nfunction animateVariant(visualElement, variant, options = {}) {\n  const resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? visualElement.presenceContext?.custom : undefined);\n  let {\n    transition = visualElement.getDefaultTransition() || {}\n  } = resolved || {};\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {\n    const {\n      delayChildren = 0,\n      staggerChildren,\n      staggerDirection\n    } = transition;\n    return animateChildren(visualElement, variant, forwardDelay, delayChildren, staggerChildren, staggerDirection, options);\n  } : () => Promise.resolve();\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  const {\n    when\n  } = transition;\n  if (when) {\n    const [first, last] = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];\n    return first().then(() => last());\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\nfunction animateChildren(visualElement, variant, delay = 0, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n  const animations = [];\n  for (const child of visualElement.variantChildren) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, {\n      ...options,\n      delay: delay + (typeof delayChildren === \"function\" ? 0 : delayChildren) + calcChildStagger(visualElement.variantChildren, child, delayChildren, staggerChildren, staggerDirection)\n    }).then(() => child.notify(\"AnimationComplete\", variant)));\n  }\n  return Promise.all(animations);\n}\nexport { animateVariant };","map":{"version":3,"names":["animateVariant","visualElement","variant","options","resolved","resolveVariant","type","presenceContext","custom","undefined","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","animateTarget","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","then","delay","animations","child","notify","push","calcChildStagger"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/animation/interfaces/visual-element-variant.ts"],"sourcesContent":["import { resolveVariant } from \"../../render/utils/resolve-dynamic-variants\"\nimport { calcChildStagger } from \"../utils/calc-child-stagger\"\nimport type { VisualElementAnimationOptions } from \"./types\"\nimport { animateTarget } from \"./visual-element-target\"\nimport type { DynamicOption } from \"../types\"\nimport type { VisualElement } from \"../../render/VisualElement\"\n\nexport function animateVariant(\n    visualElement: VisualElement,\n    variant: string,\n    options: VisualElementAnimationOptions = {}\n): Promise<any> {\n    const resolved = resolveVariant(\n        visualElement,\n        variant,\n        options.type === \"exit\"\n            ? visualElement.presenceContext?.custom\n            : undefined\n    )\n\n    let { transition = visualElement.getDefaultTransition() || {} } =\n        resolved || {}\n\n    if (options.transitionOverride) {\n        transition = options.transitionOverride\n    }\n\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation: () => Promise<any> = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve()\n\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations =\n        visualElement.variantChildren && visualElement.variantChildren.size\n            ? (forwardDelay = 0) => {\n                  const {\n                      delayChildren = 0,\n                      staggerChildren,\n                      staggerDirection,\n                  } = transition\n\n                  return animateChildren(\n                      visualElement,\n                      variant,\n                      forwardDelay,\n                      delayChildren,\n                      staggerChildren,\n                      staggerDirection,\n                      options\n                  )\n              }\n            : () => Promise.resolve()\n\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition\n    if (when) {\n        const [first, last] =\n            when === \"beforeChildren\"\n                ? [getAnimation, getChildAnimations]\n                : [getChildAnimations, getAnimation]\n\n        return first().then(() => last())\n    } else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)])\n    }\n}\n\nfunction animateChildren(\n    visualElement: VisualElement,\n    variant: string,\n    delay: number = 0,\n    delayChildren: number | DynamicOption<number> = 0,\n    staggerChildren = 0,\n    staggerDirection = 1,\n    options: VisualElementAnimationOptions\n) {\n    const animations: Promise<any>[] = []\n\n    for (const child of visualElement.variantChildren!) {\n        child.notify(\"AnimationStart\", variant)\n        animations.push(\n            animateVariant(child, variant, {\n                ...options,\n                delay:\n                    delay +\n                    (typeof delayChildren === \"function\" ? 0 : delayChildren) +\n                    calcChildStagger(\n                        visualElement.variantChildren!,\n                        child,\n                        delayChildren,\n                        staggerChildren,\n                        staggerDirection\n                    ),\n            }).then(() => child.notify(\"AnimationComplete\", variant))\n        )\n    }\n\n    return Promise.all(animations)\n}\n"],"mappings":";;;AAOM,SAAUA,cAAcA,CAC1BC,aAA4B,EAC5BC,OAAe,EACfC,OAAA,GAAyC,EAAE;EAE3C,MAAMC,QAAQ,GAAGC,cAAc,CAC3BJ,aAAa,EACbC,OAAO,EACPC,OAAO,CAACG,IAAI,KAAK,MAAM,GACjBL,aAAa,CAACM,eAAe,EAAEC,MAAM,GACrCC,SAAS,CAClB;EAED,IAAI;IAAEC,UAAU,GAAGT,aAAa,CAACU,oBAAoB,EAAE,IAAI;EAAE,CAAE,GAC3DP,QAAQ,IAAI,EAAE;EAElB,IAAID,OAAO,CAACS,kBAAkB,EAAE;IAC5BF,UAAU,GAAGP,OAAO,CAACS,kBAAkB;;EAG3C;;;AAGG;EACH,MAAMC,YAAY,GAAuBT,QAAQ,GAC3C,MAAMU,OAAO,CAACC,GAAG,CAACC,aAAa,CAACf,aAAa,EAAEG,QAAQ,EAAED,OAAO,CAAC,CAAC,GAClE,MAAMW,OAAO,CAACG,OAAO,EAAE;EAE7B;;;AAGG;EACH,MAAMC,kBAAkB,GACpBjB,aAAa,CAACkB,eAAe,IAAIlB,aAAa,CAACkB,eAAe,CAACC,IAAI,GAC7D,CAACC,YAAY,GAAG,CAAC,KAAI;IACjB,MAAM;MACFC,aAAa,GAAG,CAAC;MACjBC,eAAe;MACfC;IAAgB,CACnB,GAAGd,UAAU;IAEd,OAAOe,eAAe,CAClBxB,aAAa,EACbC,OAAO,EACPmB,YAAY,EACZC,aAAa,EACbC,eAAe,EACfC,gBAAgB,EAChBrB,OAAO,CACV;GACJ,GACD,MAAMW,OAAO,CAACG,OAAO,EAAE;EAEjC;;;AAGG;EACH,MAAM;IAAES;EAAI,CAAE,GAAGhB,UAAU;EAC3B,IAAIgB,IAAI,EAAE;IACN,MAAM,CAACC,KAAK,EAAEC,IAAI,CAAC,GACfF,IAAI,KAAK,gBAAgB,GACnB,CAACb,YAAY,EAAEK,kBAAkB,CAAC,GAClC,CAACA,kBAAkB,EAAEL,YAAY,CAAC;IAE5C,OAAOc,KAAK,EAAE,CAACE,IAAI,CAAC,MAAMD,IAAI,EAAE,CAAC;GACpC,MAAM;IACH,OAAOd,OAAO,CAACC,GAAG,CAAC,CAACF,YAAY,EAAE,EAAEK,kBAAkB,CAACf,OAAO,CAAC2B,KAAK,CAAC,CAAC,CAAC;;AAE/E;AAEA,SAASL,eAAeA,CACpBxB,aAA4B,EAC5BC,OAAe,EACf4B,KAAA,GAAgB,CAAC,EACjBR,aAAA,GAAgD,CAAC,EACjDC,eAAe,GAAG,CAAC,EACnBC,gBAAgB,GAAG,CAAC,EACpBrB,OAAsC;EAEtC,MAAM4B,UAAU,GAAmB,EAAE;EAErC,KAAK,MAAMC,KAAK,IAAI/B,aAAa,CAACkB,eAAgB,EAAE;IAChDa,KAAK,CAACC,MAAM,CAAC,gBAAgB,EAAE/B,OAAO,CAAC;IACvC6B,UAAU,CAACG,IAAI,CACXlC,cAAc,CAACgC,KAAK,EAAE9B,OAAO,EAAE;MAC3B,GAAGC,OAAO;MACV2B,KAAK,EACDA,KAAK,IACJ,OAAOR,aAAa,KAAK,UAAU,GAAG,CAAC,GAAGA,aAAa,CAAC,GACzDa,gBAAgB,CACZlC,aAAa,CAACkB,eAAgB,EAC9Ba,KAAK,EACLV,aAAa,EACbC,eAAe,EACfC,gBAAgB;IAE3B,EAAC,CAACK,IAAI,CAAC,MAAMG,KAAK,CAACC,MAAM,CAAC,mBAAmB,EAAE/B,OAAO,CAAC,CAAC,CAC5D;;EAGL,OAAOY,OAAO,CAACC,GAAG,CAACgB,UAAU,CAAC;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}