{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\nconst PresenceChild = ({\n  children,\n  initial,\n  isPresent,\n  onExitComplete,\n  custom,\n  presenceAffectsLayout,\n  mode,\n  anchorX,\n  anchorY,\n  root\n}) => {\n  const presenceChildren = useConstant(newChildrenMap);\n  const id = useId();\n  let isReusedContext = true;\n  let context = useMemo(() => {\n    isReusedContext = false;\n    return {\n      id,\n      initial,\n      isPresent,\n      custom,\n      onExitComplete: childId => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n          if (!isComplete) return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n      },\n      register: childId => {\n        presenceChildren.set(childId, false);\n        return () => presenceChildren.delete(childId);\n      }\n    };\n  }, [isPresent, presenceChildren, onExitComplete]);\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  if (presenceAffectsLayout && isReusedContext) {\n    context = {\n      ...context\n    };\n  }\n  useMemo(() => {\n    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n  React.useEffect(() => {\n    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent]);\n  children = jsx(PopChild, {\n    pop: mode === \"popLayout\",\n    isPresent: isPresent,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    root: root,\n    children: children\n  });\n  return jsx(PresenceContext.Provider, {\n    value: context,\n    children: children\n  });\n};\nfunction newChildrenMap() {\n  return new Map();\n}\nexport { PresenceChild };","map":{"version":3,"names":["PresenceChild","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","anchorX","anchorY","root","presenceChildren","useConstant","newChildrenMap","id","useId","context","useMemo","childId","set","isComplete","register","isReusedContext","forEach","_","key","React","useEffect","jsx","PopChild","pop","PresenceContext","Provider","value"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/components/AnimatePresence/PresenceChild.tsx"],"sourcesContent":["\"use client\"\n\nimport * as React from \"react\"\nimport { useId, useMemo } from \"react\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { VariantLabels } from \"../../motion/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { PopChild } from \"./PopChild\"\n\ninterface PresenceChildProps {\n    children: React.ReactElement\n    isPresent: boolean\n    onExitComplete?: () => void\n    initial?: false | VariantLabels\n    custom?: any\n    presenceAffectsLayout: boolean\n    mode: \"sync\" | \"popLayout\" | \"wait\"\n    anchorX?: \"left\" | \"right\"\n    anchorY?: \"top\" | \"bottom\"\n    root?: HTMLElement | ShadowRoot\n}\n\nexport const PresenceChild = ({\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode,\n    anchorX,\n    anchorY,\n    root\n}: PresenceChildProps) => {\n    const presenceChildren = useConstant(newChildrenMap)\n    const id = useId()\n\n    let isReusedContext = true\n    let context = useMemo((): PresenceContextProps => {\n        isReusedContext = false\n        return {\n            id,\n            initial,\n            isPresent,\n            custom,\n            onExitComplete: (childId: string) => {\n                presenceChildren.set(childId, true)\n\n                for (const isComplete of presenceChildren.values()) {\n                    if (!isComplete) return // can stop searching when any is incomplete\n                }\n\n                onExitComplete && onExitComplete()\n            },\n            register: (childId: string) => {\n                presenceChildren.set(childId, false)\n                return () => presenceChildren.delete(childId)\n            },\n        }\n    }, [isPresent, presenceChildren, onExitComplete])\n\n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    if (presenceAffectsLayout && isReusedContext) {\n        context = { ...context }\n    }\n\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false))\n    }, [isPresent])\n\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete()\n    }, [isPresent])\n\n    children = (\n        <PopChild pop={mode === \"popLayout\"} isPresent={isPresent} anchorX={anchorX} anchorY={anchorY} root={root}>\n            {children}\n        </PopChild>\n    )\n\n    return (\n        <PresenceContext.Provider value={context}>\n            {children}\n        </PresenceContext.Provider>\n    )\n}\n\nfunction newChildrenMap(): Map<string, boolean> {\n    return new Map()\n}\n"],"mappings":";;;;;;;;AAyBa,MAAAA,aAAA,GAAAA,CAAA;EAAAC,QAAA;EAAAC,OAAA;EAAAC,SAAA;EAAAC,cAAA;EAAAC,MAAA;EAAAC,qBAAA;EAAAC,IAAA;EAAAC,OAAA;EAAAC,OAAA;EAAAC;AAAA;EAYT,MAAAC,gBAAA,GAAAC,WAAA,CAAAC,cAAA;EACA,MAAAC,EAAA,GAAAC,KAAA;;EAGA,IAAAC,OAAA,GAAAC,OAAA;;;;;;;MAOQb,cAAA,EAAAc,OAAA;QACIP,gBAAA,CAAAQ,GAAA,CAAAD,OAAA;;UAGI,KAAAE,UAAA,EAAiB;;;;MAKzBC,QAAA,EAAAH,OAAA;QACIP,gBAAA,CAAAQ,GAAA,CAAAD,OAAA;;;;;EAMZ;;;;AAIG;EACH,IAAAZ,qBAAA,IAAAgB,eAAA;IACIN,OAAA;MAAA,GAAAA;IAAA;;;IAIAL,gBAAA,CAAAY,OAAA,EAAAC,CAAA,EAAAC,GAAA,KAAAd,gBAAA,CAAAQ,GAAA,CAAAM,GAAA;EACJ,IAAAtB,SAAA;EAEA;;;AAGG;EACHuB,KAAA,CAAAC,SAAA;IACI,CAAAxB,SAAA,I,4CAGIC,cAAA;EACR,IAAAD,SAAA;EAEAF,QAAA,GAAA2B,GAAA,CAAAC,QAAA;IAAAC,GAAA,EAAAvB,IAAA;IAAAJ,SAAA,EAAAA,SAAA;IAAAK,OAAA,EAAAA,OAAA;IAAAC,OAAA,EAAAA,OAAA;IAAAC,IAAA,EAAAA,IAAA;IAAAT,QAAA,EAAAA;EAAA;EAMA,OAAA2B,GAAA,CAAAG,eAAA,CAAAC,QAAA;IAAAC,KAAA,EAAAjB,OAAA;IAAAf,QAAA,EAAAA;EAAA;AAKJ;AAEA,SAAAY,eAAA;;AAEA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}