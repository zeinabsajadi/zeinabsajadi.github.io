{"ast":null,"code":"import { removeItem } from 'motion-utils';\nimport { microtask } from '../frameloop/microtask.mjs';\nimport { startViewAnimation } from './start.mjs';\nlet builders = [];\nlet current = null;\nfunction next() {\n  current = null;\n  const [nextBuilder] = builders;\n  if (nextBuilder) start(nextBuilder);\n}\nfunction start(builder) {\n  removeItem(builders, builder);\n  current = builder;\n  startViewAnimation(builder).then(animation => {\n    builder.notifyReady(animation);\n    animation.finished.finally(next);\n  });\n}\nfunction processQueue() {\n  /**\n   * Iterate backwards over the builders array. We can ignore the\n   * \"wait\" animations. If we have an interrupting animation in the\n   * queue then we need to batch all preceeding animations into it.\n   * Currently this only batches the update functions but will also\n   * need to batch the targets.\n   */\n  for (let i = builders.length - 1; i >= 0; i--) {\n    const builder = builders[i];\n    const {\n      interrupt\n    } = builder.options;\n    if (interrupt === \"immediate\") {\n      const batchedUpdates = builders.slice(0, i + 1).map(b => b.update);\n      const remaining = builders.slice(i + 1);\n      builder.update = () => {\n        batchedUpdates.forEach(update => update());\n      };\n      // Put the current builder at the front, followed by any \"wait\" builders\n      builders = [builder, ...remaining];\n      break;\n    }\n  }\n  if (!current || builders[0]?.options.interrupt === \"immediate\") {\n    next();\n  }\n}\nfunction addToQueue(builder) {\n  builders.push(builder);\n  microtask.render(processQueue);\n}\nexport { addToQueue };","map":{"version":3,"names":["builders","current","next","nextBuilder","start","builder","removeItem","startViewAnimation","then","animation","notifyReady","finished","finally","processQueue","i","length","interrupt","options","batchedUpdates","slice","map","b","update","remaining","forEach","addToQueue","push","microtask","render"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/view/queue.ts"],"sourcesContent":["import { removeItem } from \"motion-utils\"\nimport type { ViewTransitionBuilder } from \".\"\nimport { microtask } from \"../frameloop/microtask\"\nimport { startViewAnimation } from \"./start\"\n\nlet builders: ViewTransitionBuilder[] = []\n\nlet current: ViewTransitionBuilder | null = null\n\nfunction next() {\n    current = null\n    const [nextBuilder] = builders\n    if (nextBuilder) start(nextBuilder)\n}\n\nfunction start(builder: ViewTransitionBuilder) {\n    removeItem(builders, builder)\n    current = builder\n    startViewAnimation(builder).then((animation) => {\n        builder.notifyReady(animation)\n        animation.finished.finally(next)\n    })\n}\n\nfunction processQueue() {\n    /**\n     * Iterate backwards over the builders array. We can ignore the\n     * \"wait\" animations. If we have an interrupting animation in the\n     * queue then we need to batch all preceeding animations into it.\n     * Currently this only batches the update functions but will also\n     * need to batch the targets.\n     */\n    for (let i = builders.length - 1; i >= 0; i--) {\n        const builder = builders[i]\n        const { interrupt } = builder.options\n\n        if (interrupt === \"immediate\") {\n            const batchedUpdates = builders.slice(0, i + 1).map((b) => b.update)\n            const remaining = builders.slice(i + 1)\n\n            builder.update = () => {\n                batchedUpdates.forEach((update) => update())\n            }\n\n            // Put the current builder at the front, followed by any \"wait\" builders\n            builders = [builder, ...remaining]\n\n            break\n        }\n    }\n\n    if (!current || builders[0]?.options.interrupt === \"immediate\") {\n        next()\n    }\n}\n\nexport function addToQueue(builder: ViewTransitionBuilder) {\n    builders.push(builder)\n    microtask.render(processQueue)\n}\n"],"mappings":";;;AAKA,IAAIA,QAAQ,GAA4B,EAAE;AAE1C,IAAIC,OAAO,GAAiC,IAAI;AAEhD,SAASC,IAAIA,CAAA;EACTD,OAAO,GAAG,IAAI;EACd,MAAM,CAACE,WAAW,CAAC,GAAGH,QAAQ;EAC9B,IAAIG,WAAW,EAAEC,KAAK,CAACD,WAAW,CAAC;AACvC;AAEA,SAASC,KAAKA,CAACC,OAA8B;EACzCC,UAAU,CAACN,QAAQ,EAAEK,OAAO,CAAC;EAC7BJ,OAAO,GAAGI,OAAO;EACjBE,kBAAkB,CAACF,OAAO,CAAC,CAACG,IAAI,CAAEC,SAAS,IAAI;IAC3CJ,OAAO,CAACK,WAAW,CAACD,SAAS,CAAC;IAC9BA,SAAS,CAACE,QAAQ,CAACC,OAAO,CAACV,IAAI,CAAC;EACpC,CAAC,CAAC;AACN;AAEA,SAASW,YAAYA,CAAA;EACjB;;;;;;AAMG;EACH,KAAK,IAAIC,CAAC,GAAGd,QAAQ,CAACe,MAAM,GAAG,CAAC,EAAED,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC3C,MAAMT,OAAO,GAAGL,QAAQ,CAACc,CAAC,CAAC;IAC3B,MAAM;MAAEE;IAAS,CAAE,GAAGX,OAAO,CAACY,OAAO;IAErC,IAAID,SAAS,KAAK,WAAW,EAAE;MAC3B,MAAME,cAAc,GAAGlB,QAAQ,CAACmB,KAAK,CAAC,CAAC,EAAEL,CAAC,GAAG,CAAC,CAAC,CAACM,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,CAAC;MACpE,MAAMC,SAAS,GAAGvB,QAAQ,CAACmB,KAAK,CAACL,CAAC,GAAG,CAAC,CAAC;MAEvCT,OAAO,CAACiB,MAAM,GAAG,MAAK;QAClBJ,cAAc,CAACM,OAAO,CAAEF,MAAM,IAAKA,MAAM,EAAE,CAAC;MAChD,CAAC;;MAGDtB,QAAQ,GAAG,CAACK,OAAO,EAAE,GAAGkB,SAAS,CAAC;MAElC;;;EAIR,IAAI,CAACtB,OAAO,IAAID,QAAQ,CAAC,CAAC,CAAC,EAAEiB,OAAO,CAACD,SAAS,KAAK,WAAW,EAAE;IAC5Dd,IAAI,EAAE;;AAEd;AAEM,SAAUuB,UAAUA,CAACpB,OAA8B;EACrDL,QAAQ,CAAC0B,IAAI,CAACrB,OAAO,CAAC;EACtBsB,SAAS,CAACC,MAAM,CAACf,YAAY,CAAC;AAClC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}