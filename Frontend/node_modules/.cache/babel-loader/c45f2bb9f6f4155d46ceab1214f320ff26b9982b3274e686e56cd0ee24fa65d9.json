{"ast":null,"code":"import { floatRegex } from '../utils/float-regex.mjs';\nimport { isNullish } from '../utils/is-nullish.mjs';\nimport { singleColorRegex } from '../utils/single-color-regex.mjs';\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nconst isColorString = (type, testProp) => v => {\n  return Boolean(typeof v === \"string\" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));\n};\nconst splitColor = (aName, bName, cName) => v => {\n  if (typeof v !== \"string\") return v;\n  const [a, b, c, alpha] = v.match(floatRegex);\n  return {\n    [aName]: parseFloat(a),\n    [bName]: parseFloat(b),\n    [cName]: parseFloat(c),\n    alpha: alpha !== undefined ? parseFloat(alpha) : 1\n  };\n};\nexport { isColorString, splitColor };","map":{"version":3,"names":["isColorString","type","testProp","v","Boolean","singleColorRegex","test","startsWith","isNullish","Object","prototype","hasOwnProperty","call","splitColor","aName","bName","cName","a","b","c","alpha","match","floatRegex","parseFloat","undefined"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/value/types/color/utils.ts"],"sourcesContent":["import { Color, HSLA, RGBA } from \"../types\"\nimport { floatRegex } from \"../utils/float-regex\"\nimport { isNullish } from \"../utils/is-nullish\"\nimport { singleColorRegex } from \"../utils/single-color-regex\"\n\n/**\n * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,\n * but false if a number or multiple colors\n */\nexport const isColorString = (type: string, testProp?: string) => (v: any) => {\n    return Boolean(\n        (typeof v === \"string\" &&\n            singleColorRegex.test(v) &&\n            v.startsWith(type)) ||\n            (testProp &&\n                !isNullish(v) &&\n                Object.prototype.hasOwnProperty.call(v, testProp))\n    )\n}\n\nexport const splitColor =\n    <V extends RGBA | HSLA>(aName: string, bName: string, cName: string) =>\n    (v: string | Color): V => {\n        if (typeof v !== \"string\") return v as any\n\n        const [a, b, c, alpha] = v.match(floatRegex) as any\n\n        return {\n            [aName]: parseFloat(a),\n            [bName]: parseFloat(b),\n            [cName]: parseFloat(c),\n            alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n        } as V\n    }\n"],"mappings":";;;;AAKA;;;AAGG;AACI,MAAMA,aAAa,GAAGA,CAACC,IAAY,EAAEC,QAAiB,KAAMC,CAAM,IAAI;EACzE,OAAOC,OAAO,CACT,OAAOD,CAAC,KAAK,QAAQ,IAClBE,gBAAgB,CAACC,IAAI,CAACH,CAAC,CAAC,IACxBA,CAAC,CAACI,UAAU,CAACN,IAAI,CAAC,IACjBC,QAAQ,IACL,CAACM,SAAS,CAACL,CAAC,CAAC,IACbM,MAAM,CAACC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACT,CAAC,EAAED,QAAQ,CAAE,CAC7D;AACL;AAEa,MAAAW,UAAU,GACnBA,CAAwBC,KAAa,EAAEC,KAAa,EAAEC,KAAa,KAClEb,CAAiB,IAAO;EACrB,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOA,CAAQ;EAE1C,MAAM,CAACc,CAAC,EAAEC,CAAC,EAAEC,CAAC,EAAEC,KAAK,CAAC,GAAGjB,CAAC,CAACkB,KAAK,CAACC,UAAU,CAAQ;EAEnD,OAAO;IACH,CAACR,KAAK,GAAGS,UAAU,CAACN,CAAC,CAAC;IACtB,CAACF,KAAK,GAAGQ,UAAU,CAACL,CAAC,CAAC;IACtB,CAACF,KAAK,GAAGO,UAAU,CAACJ,CAAC,CAAC;IACtBC,KAAK,EAAEA,KAAK,KAAKI,SAAS,GAAGD,UAAU,CAACH,KAAK,CAAC,GAAG;GAC/C;AACV","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}