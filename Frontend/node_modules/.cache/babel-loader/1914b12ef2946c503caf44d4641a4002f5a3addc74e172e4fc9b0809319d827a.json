{"ast":null,"code":"\"use client\";\n\nimport { resolveMotionValue, isControllingVariants, isVariantNode, isAnimationControls, resolveVariantFromProps } from 'motion-dom';\nimport { useContext } from 'react';\nimport { MotionContext } from '../../context/MotionContext/index.mjs';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nfunction makeState({\n  scrapeMotionValuesFromProps,\n  createRenderState\n}, props, context, presenceContext) {\n  const state = {\n    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n    renderState: createRenderState()\n  };\n  return state;\n}\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n  const values = {};\n  const motionValues = scrapeMotionValues(props, {});\n  for (const key in motionValues) {\n    values[key] = resolveMotionValue(motionValues[key]);\n  }\n  let {\n    initial,\n    animate\n  } = props;\n  const isControllingVariants$1 = isControllingVariants(props);\n  const isVariantNode$1 = isVariantNode(props);\n  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {\n    if (initial === undefined) initial = context.initial;\n    if (animate === undefined) animate = context.animate;\n  }\n  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;\n  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;\n  const variantToSet = isInitialAnimationBlocked ? animate : initial;\n  if (variantToSet && typeof variantToSet !== \"boolean\" && !isAnimationControls(variantToSet)) {\n    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n    for (let i = 0; i < list.length; i++) {\n      const resolved = resolveVariantFromProps(props, list[i]);\n      if (resolved) {\n        const {\n          transitionEnd,\n          transition,\n          ...target\n        } = resolved;\n        for (const key in target) {\n          let valueTarget = target[key];\n          if (Array.isArray(valueTarget)) {\n            /**\n             * Take final keyframe if the initial animation is blocked because\n             * we want to initialise at the end of that blocked animation.\n             */\n            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;\n            valueTarget = valueTarget[index];\n          }\n          if (valueTarget !== null) {\n            values[key] = valueTarget;\n          }\n        }\n        for (const key in transitionEnd) {\n          values[key] = transitionEnd[key];\n        }\n      }\n    }\n  }\n  return values;\n}\nconst makeUseVisualState = config => (props, isStatic) => {\n  const context = useContext(MotionContext);\n  const presenceContext = useContext(PresenceContext);\n  const make = () => makeState(config, props, context, presenceContext);\n  return isStatic ? make() : useConstant(make);\n};\nexport { makeUseVisualState };","map":{"version":3,"names":["makeState","scrapeMotionValuesFromProps","createRenderState","props","context","presenceContext","state","makeLatestValues","scrapeMotionValues","key","motionValues","initial","animate","isControllingVariants$1","isControllingVariants","isVariantNode$1","isVariantNode","inherit","isInitialAnimationBlocked","variantToSet","isAnimationControls","list","Array","isArray","i","length","target","valueTarget","index","values","transitionEnd","makeUseVisualState","config","isStatic","useContext","MotionContext","PresenceContext","make","useConstant"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/motion/utils/use-visual-state.ts"],"sourcesContent":["\"use client\"\n\nimport {\n    AnyResolvedKeyframe,\n    isAnimationControls,\n    isControllingVariants as checkIsControllingVariants,\n    isVariantNode as checkIsVariantNode,\n    ResolvedValues,\n    resolveVariantFromProps,\n} from \"motion-dom\"\nimport { useContext } from \"react\"\nimport { MotionContext, MotionContextProps } from \"../../context/MotionContext\"\nimport {\n    PresenceContext,\n    type PresenceContextProps,\n} from \"../../context/PresenceContext\"\nimport { ScrapeMotionValuesFromProps } from \"../../render/types\"\nimport { useConstant } from \"../../utils/use-constant\"\nimport { resolveMotionValue } from \"motion-dom\"\nimport { MotionProps } from \"../types\"\n\nexport interface VisualState<Instance, RenderState> {\n    renderState: RenderState\n    latestValues: ResolvedValues\n    onMount?: (instance: Instance) => void\n}\n\nexport type UseVisualState<Instance, RenderState> = (\n    props: MotionProps,\n    isStatic: boolean\n) => VisualState<Instance, RenderState>\n\nexport interface UseVisualStateConfig<RenderState> {\n    scrapeMotionValuesFromProps: ScrapeMotionValuesFromProps\n    createRenderState: () => RenderState\n}\n\nfunction makeState<I, RS>(\n    {\n        scrapeMotionValuesFromProps,\n        createRenderState,\n    }: UseVisualStateConfig<RS>,\n    props: MotionProps,\n    context: MotionContextProps,\n    presenceContext: PresenceContextProps | null\n) {\n    const state: VisualState<I, RS> = {\n        latestValues: makeLatestValues(\n            props,\n            context,\n            presenceContext,\n            scrapeMotionValuesFromProps\n        ),\n        renderState: createRenderState(),\n    }\n\n    return state\n}\n\nfunction makeLatestValues(\n    props: MotionProps,\n    context: MotionContextProps,\n    presenceContext: PresenceContextProps | null,\n    scrapeMotionValues: ScrapeMotionValuesFromProps\n) {\n    const values: ResolvedValues = {}\n\n    const motionValues = scrapeMotionValues(props, {})\n    for (const key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key])\n    }\n\n    let { initial, animate } = props\n    const isControllingVariants = checkIsControllingVariants(props)\n    const isVariantNode = checkIsVariantNode(props)\n\n    if (\n        context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false\n    ) {\n        if (initial === undefined) initial = context.initial\n        if (animate === undefined) animate = context.animate\n    }\n\n    let isInitialAnimationBlocked = presenceContext\n        ? presenceContext.initial === false\n        : false\n    isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false\n\n    const variantToSet = isInitialAnimationBlocked ? animate : initial\n\n    if (\n        variantToSet &&\n        typeof variantToSet !== \"boolean\" &&\n        !isAnimationControls(variantToSet)\n    ) {\n        const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet]\n        for (let i = 0; i < list.length; i++) {\n            const resolved = resolveVariantFromProps(props, list[i] as any)\n            if (resolved) {\n                const { transitionEnd, transition, ...target } = resolved\n                for (const key in target) {\n                    let valueTarget = target[key as keyof typeof target]\n\n                    if (Array.isArray(valueTarget)) {\n                        /**\n                         * Take final keyframe if the initial animation is blocked because\n                         * we want to initialise at the end of that blocked animation.\n                         */\n                        const index = isInitialAnimationBlocked\n                            ? valueTarget.length - 1\n                            : 0\n                        valueTarget = valueTarget[index] as any\n                    }\n\n                    if (valueTarget !== null) {\n                        values[key] = valueTarget as AnyResolvedKeyframe\n                    }\n                }\n                for (const key in transitionEnd) {\n                    values[key] = transitionEnd[\n                        key as keyof typeof transitionEnd\n                    ] as AnyResolvedKeyframe\n                }\n            }\n        }\n    }\n\n    return values\n}\n\nexport const makeUseVisualState =\n    <I, RS>(config: UseVisualStateConfig<RS>): UseVisualState<I, RS> =>\n    (props: MotionProps, isStatic: boolean): VisualState<I, RS> => {\n        const context = useContext(MotionContext)\n        const presenceContext = useContext(PresenceContext)\n        const make = () => makeState(config, props, context, presenceContext)\n\n        return isStatic ? make() : useConstant(make)\n    }\n"],"mappings":";;;;;;;AAqCA,SAAAA,UAAA;EAAAC,2BAAA;EAAAC;AAAA,GAAAC,KAAA,EAAAC,OAAA,EAAAC,eAAA;EASI,MAAAC,KAAA;;;;EAUA,OAAAA,KAAA;AACJ;AAEA,SAAAC,iBAAAJ,KAAA,EAAAC,OAAA,EAAAC,eAAA,EAAAG,kBAAA;;;EASI,WAAAC,GAAA,IAAAC,YAAA;;;EAIA;IAAAC,OAAA;IAAAC;EAAA,IAAAT,KAAA;EACA,MAAAU,uBAAA,GAAAC,qBAAA,CAAAX,KAAA;EACA,MAAAY,eAAA,GAAAC,aAAA,CAAAb,KAAA;EAEA,IAAAC,OAAA,I,mBAGI,CAAAS,uBAAA,IACAV,KAAA,CAAAc,OAAA;+BAE2BN,OAAA,GAAAP,OAAA,CAAAO,OAAA;+BACAC,OAAA,GAAAR,OAAA,CAAAQ,OAAA;;oDAI3BP,eAAA,CAAAM,OAAA,a;EAEJO,yBAAA,GAAAA,yBAAA,IAAAP,OAAA;;EAIA,IAAAQ,YAAA,I,qCAGI,CAAAC,mBAAA,CAAAD,YAAA;IAEA,MAAAE,IAAA,GAAAC,KAAA,CAAAC,OAAA,CAAAJ,YAAA,IAAAA,YAAA,IAAAA,YAAA;IACA,SAAAK,CAAA,MAAAA,CAAA,GAAAH,IAAA,CAAAI,MAAA,EAAAD,CAAA;;;;;;;;QAIQ,WAAAf,GAAA,IAAAiB,MAAA;UACI,IAAAC,WAAA,GAAAD,MAAA,CAAAjB,GAAA;UAEA,IAAAa,KAAA,CAAAC,OAAA,CAAAI,WAAA;YACI;;;AAGG;sDAECA,WAAA,CAAAF,MAAA,O;YAEJE,WAAA,GAAAA,WAAA,CAAAC,KAAA;;UAGJ,IAAAD,WAAA;YACIE,MAAA,CAAApB,GAAA,IAAAkB,WAAA;;;QAGR,WAAAlB,GAAA,IAAAqB,aAAA;;;;;;EASZ,OAAAD,MAAA;AACJ;AAEO,MAAAE,kBAAA,GAAAC,MAAA,KAAA7B,KAAA,EAAA8B,QAAA;EAGC,MAAA7B,OAAA,GAAA8B,UAAA,CAAAC,aAAA;EACA,MAAA9B,eAAA,GAAA6B,UAAA,CAAAE,eAAA;EACA,MAAAC,IAAA,GAAAA,CAAA,KAAArC,SAAA,CAAAgC,MAAA,EAAA7B,KAAA,EAAAC,OAAA,EAAAC,eAAA;EAEA,OAAA4B,QAAA,GAAAI,IAAA,KAAAC,WAAA,CAAAD,IAAA;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}