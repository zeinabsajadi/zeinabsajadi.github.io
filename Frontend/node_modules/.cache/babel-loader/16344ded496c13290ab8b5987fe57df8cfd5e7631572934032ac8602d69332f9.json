{"ast":null,"code":"import { animateVisualElement, setTarget } from 'motion-dom';\nimport { invariant } from 'motion-utils';\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(value => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n  const reversedLabels = [...variantLabels].reverse();\n  reversedLabels.forEach(key => {\n    const variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(child => {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n/**\n * @public\n */\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  let hasMounted = false;\n  /**\n   * A collection of linked component animation controls.\n   */\n  const subscribers = new Set();\n  const controls = {\n    subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return () => void subscribers.delete(visualElement);\n    },\n    start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      const animations = [];\n      subscribers.forEach(visualElement => {\n        animations.push(animateVisualElement(visualElement, definition, {\n          transitionOverride\n        }));\n      });\n      return Promise.all(animations);\n    },\n    set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(visualElement => {\n        setValues(visualElement, definition);\n      });\n    },\n    stop() {\n      subscribers.forEach(visualElement => {\n        stopAnimation(visualElement);\n      });\n    },\n    mount() {\n      hasMounted = true;\n      return () => {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\nexport { animationControls, setValues };","map":{"version":3,"names":["stopAnimation","visualElement","values","forEach","value","stop","setVariants","variantLabels","reversedLabels","reverse","key","variant","getVariant","setTarget","variantChildren","child","setValues","definition","Array","isArray","animationControls","hasMounted","subscribers","Set","controls","subscribe","add","delete","start","transitionOverride","invariant","animations","push","animateVisualElement","Promise","all","set","mount"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/framer-motion/src/animation/hooks/animation-controls.ts"],"sourcesContent":["import {\n    animateVisualElement,\n    setTarget,\n    type AnimationDefinition,\n    type LegacyAnimationControls,\n    type VisualElement,\n} from \"motion-dom\"\nimport { invariant } from \"motion-utils\"\n\nfunction stopAnimation(visualElement: VisualElement) {\n    visualElement.values.forEach((value) => value.stop())\n}\n\nfunction setVariants(visualElement: VisualElement, variantLabels: string[]) {\n    const reversedLabels = [...variantLabels].reverse()\n\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key)\n        variant && setTarget(visualElement, variant)\n\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels)\n            })\n        }\n    })\n}\n\nexport function setValues(\n    visualElement: VisualElement,\n    definition: AnimationDefinition\n) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition)\n    } else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition])\n    } else {\n        setTarget(visualElement, definition as any)\n    }\n}\n\n/**\n * @public\n */\nexport function animationControls(): LegacyAnimationControls {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false\n\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set<VisualElement>()\n\n    const controls: LegacyAnimationControls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement)\n            return () => void subscribers.delete(visualElement)\n        },\n\n        start(definition, transitionOverride) {\n            invariant(\n                hasMounted,\n                \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\"\n            )\n\n            const animations: Array<Promise<any>> = []\n            subscribers.forEach((visualElement) => {\n                animations.push(\n                    animateVisualElement(visualElement, definition, {\n                        transitionOverride,\n                    })\n                )\n            })\n\n            return Promise.all(animations)\n        },\n\n        set(definition) {\n            invariant(\n                hasMounted,\n                \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\"\n            )\n\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition)\n            })\n        },\n\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement)\n            })\n        },\n\n        mount() {\n            hasMounted = true\n\n            return () => {\n                hasMounted = false\n                controls.stop()\n            }\n        },\n    }\n\n    return controls\n}\n"],"mappings":";;AASA,SAASA,aAAaA,CAACC,aAA4B;EAC/CA,aAAa,CAACC,MAAM,CAACC,OAAO,CAAEC,KAAK,IAAKA,KAAK,CAACC,IAAI,EAAE,CAAC;AACzD;AAEA,SAASC,WAAWA,CAACL,aAA4B,EAAEM,aAAuB;EACtE,MAAMC,cAAc,GAAG,CAAC,GAAGD,aAAa,CAAC,CAACE,OAAO,EAAE;EAEnDD,cAAc,CAACL,OAAO,CAAEO,GAAG,IAAI;IAC3B,MAAMC,OAAO,GAAGV,aAAa,CAACW,UAAU,CAACF,GAAG,CAAC;IAC7CC,OAAO,IAAIE,SAAS,CAACZ,aAAa,EAAEU,OAAO,CAAC;IAE5C,IAAIV,aAAa,CAACa,eAAe,EAAE;MAC/Bb,aAAa,CAACa,eAAe,CAACX,OAAO,CAAEY,KAAK,IAAI;QAC5CT,WAAW,CAACS,KAAK,EAAER,aAAa,CAAC;MACrC,CAAC,CAAC;;EAEV,CAAC,CAAC;AACN;AAEgB,SAAAS,SAASA,CACrBf,aAA4B,EAC5BgB,UAA+B;EAE/B,IAAIC,KAAK,CAACC,OAAO,CAACF,UAAU,CAAC,EAAE;IAC3B,OAAOX,WAAW,CAACL,aAAa,EAAEgB,UAAU,CAAC;GAChD,MAAM,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;IACvC,OAAOX,WAAW,CAACL,aAAa,EAAE,CAACgB,UAAU,CAAC,CAAC;GAClD,MAAM;IACHJ,SAAS,CAACZ,aAAa,EAAEgB,UAAiB,CAAC;;AAEnD;AAEA;;AAEG;SACaG,iBAAiBA,CAAA;EAC7B;;AAEG;EACH,IAAIC,UAAU,GAAG,KAAK;EAEtB;;AAEG;EACH,MAAMC,WAAW,GAAG,IAAIC,GAAG,EAAiB;EAE5C,MAAMC,QAAQ,GAA4B;IACtCC,SAASA,CAACxB,aAAa;MACnBqB,WAAW,CAACI,GAAG,CAACzB,aAAa,CAAC;MAC9B,OAAO,MAAM,KAAKqB,WAAW,CAACK,MAAM,CAAC1B,aAAa,CAAC;KACtD;IAED2B,KAAKA,CAACX,UAAU,EAAEY,kBAAkB;MAChCC,SAAS,CACLT,UAAU,EACV,iHAAiH,CACpH;MAED,MAAMU,UAAU,GAAwB,EAAE;MAC1CT,WAAW,CAACnB,OAAO,CAAEF,aAAa,IAAI;QAClC8B,UAAU,CAACC,IAAI,CACXC,oBAAoB,CAAChC,aAAa,EAAEgB,UAAU,EAAE;UAC5CY;QACH,EAAC,CACL;MACL,CAAC,CAAC;MAEF,OAAOK,OAAO,CAACC,GAAG,CAACJ,UAAU,CAAC;KACjC;IAEDK,GAAGA,CAACnB,UAAU;MACVa,SAAS,CACLT,UAAU,EACV,+GAA+G,CAClH;MAED,OAAOC,WAAW,CAACnB,OAAO,CAAEF,aAAa,IAAI;QACzCe,SAAS,CAACf,aAAa,EAAEgB,UAAU,CAAC;MACxC,CAAC,CAAC;KACL;IAEDZ,IAAIA,CAAA;MACAiB,WAAW,CAACnB,OAAO,CAAEF,aAAa,IAAI;QAClCD,aAAa,CAACC,aAAa,CAAC;MAChC,CAAC,CAAC;KACL;IAEDoC,KAAKA,CAAA;MACDhB,UAAU,GAAG,IAAI;MAEjB,OAAO,MAAK;QACRA,UAAU,GAAG,KAAK;QAClBG,QAAQ,CAACnB,IAAI,EAAE;MACnB,CAAC;;GAER;EAED,OAAOmB,QAAQ;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}