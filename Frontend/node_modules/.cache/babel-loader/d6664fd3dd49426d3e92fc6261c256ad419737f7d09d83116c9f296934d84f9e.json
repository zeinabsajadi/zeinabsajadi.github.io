{"ast":null,"code":"import { secondsToMilliseconds, MotionGlobalConfig } from 'motion-utils';\nimport { AsyncMotionValueAnimation } from '../AsyncMotionValueAnimation.mjs';\nimport { JSAnimation } from '../JSAnimation.mjs';\nimport { getValueTransition } from '../utils/get-value-transition.mjs';\nimport { makeAnimationInstant } from '../utils/make-animation-instant.mjs';\nimport { getDefaultTransition } from '../utils/default-transitions.mjs';\nimport { getFinalKeyframe } from '../utils/get-final-keyframe.mjs';\nimport { isTransitionDefined } from '../utils/is-transition-defined.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nconst animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => onComplete => {\n  const valueTransition = getValueTransition(transition, name) || {};\n  /**\n   * Most transition values are currently completely overwritten by value-specific\n   * transitions. In the future it'd be nicer to blend these transitions. But for now\n   * delay actually does inherit from the root transition if not value-specific.\n   */\n  const delay = valueTransition.delay || transition.delay || 0;\n  /**\n   * Elapsed isn't a public transition option but can be passed through from\n   * optimized appear effects in milliseconds.\n   */\n  let {\n    elapsed = 0\n  } = transition;\n  elapsed = elapsed - secondsToMilliseconds(delay);\n  const options = {\n    keyframes: Array.isArray(target) ? target : [null, target],\n    ease: \"easeOut\",\n    velocity: value.getVelocity(),\n    ...valueTransition,\n    delay: -elapsed,\n    onUpdate: v => {\n      value.set(v);\n      valueTransition.onUpdate && valueTransition.onUpdate(v);\n    },\n    onComplete: () => {\n      onComplete();\n      valueTransition.onComplete && valueTransition.onComplete();\n    },\n    name,\n    motionValue: value,\n    element: isHandoff ? undefined : element\n  };\n  /**\n   * If there's no transition defined for this value, we can generate\n   * unique transition settings for this value.\n   */\n  if (!isTransitionDefined(valueTransition)) {\n    Object.assign(options, getDefaultTransition(name, options));\n  }\n  /**\n   * Both WAAPI and our internal animation functions use durations\n   * as defined by milliseconds, while our external API defines them\n   * as seconds.\n   */\n  options.duration && (options.duration = secondsToMilliseconds(options.duration));\n  options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));\n  /**\n   * Support deprecated way to set initial value. Prefer keyframe syntax.\n   */\n  if (options.from !== undefined) {\n    options.keyframes[0] = options.from;\n  }\n  let shouldSkip = false;\n  if (options.type === false || options.duration === 0 && !options.repeatDelay) {\n    makeAnimationInstant(options);\n    if (options.delay === 0) {\n      shouldSkip = true;\n    }\n  }\n  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations || element?.shouldSkipAnimations) {\n    shouldSkip = true;\n    makeAnimationInstant(options);\n    options.delay = 0;\n  }\n  /**\n   * If the transition type or easing has been explicitly set by the user\n   * then we don't want to allow flattening the animation.\n   */\n  options.allowFlatten = !valueTransition.type && !valueTransition.ease;\n  /**\n   * If we can or must skip creating the animation, and apply only\n   * the final keyframe, do so. We also check once keyframes are resolved but\n   * this early check prevents the need to create an animation at all.\n   */\n  if (shouldSkip && !isHandoff && value.get() !== undefined) {\n    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);\n    if (finalKeyframe !== undefined) {\n      frame.update(() => {\n        options.onUpdate(finalKeyframe);\n        options.onComplete();\n      });\n      return;\n    }\n  }\n  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);\n};\nexport { animateMotionValue };","map":{"version":3,"names":["animateMotionValue","name","value","target","transition","element","isHandoff","onComplete","valueTransition","getValueTransition","delay","elapsed","secondsToMilliseconds","options","keyframes","Array","isArray","ease","velocity","getVelocity","onUpdate","v","set","motionValue","undefined","isTransitionDefined","Object","assign","getDefaultTransition","duration","repeatDelay","from","shouldSkip","type","makeAnimationInstant","MotionGlobalConfig","instantAnimations","skipAnimations","shouldSkipAnimations","allowFlatten","get","finalKeyframe","getFinalKeyframe","frame","update","isSync","JSAnimation","AsyncMotionValueAnimation"],"sources":["/home/zeinab/ziblog/Frontend/node_modules/motion-dom/src/animation/interfaces/motion-value.ts"],"sourcesContent":["import { MotionGlobalConfig, secondsToMilliseconds } from \"motion-utils\"\nimport { AsyncMotionValueAnimation } from \"../AsyncMotionValueAnimation\"\nimport { JSAnimation } from \"../JSAnimation\"\nimport type {\n    AnyResolvedKeyframe,\n    ValueAnimationOptions,\n    ValueTransition,\n} from \"../types\"\nimport type { UnresolvedKeyframes } from \"../keyframes/KeyframesResolver\"\nimport { getValueTransition } from \"../utils/get-value-transition\"\nimport { makeAnimationInstant } from \"../utils/make-animation-instant\"\nimport { getDefaultTransition } from \"../utils/default-transitions\"\nimport { getFinalKeyframe } from \"../utils/get-final-keyframe\"\nimport { isTransitionDefined } from \"../utils/is-transition-defined\"\nimport { frame } from \"../../frameloop\"\nimport type { MotionValue, StartAnimation } from \"../../value\"\nimport type { VisualElement } from \"../../render/VisualElement\"\n\nexport const animateMotionValue =\n    <V extends AnyResolvedKeyframe>(\n        name: string,\n        value: MotionValue<V>,\n        target: V | UnresolvedKeyframes<V>,\n        transition: ValueTransition & { elapsed?: number } = {},\n        element?: VisualElement<any>,\n        isHandoff?: boolean\n    ): StartAnimation =>\n    (onComplete) => {\n        const valueTransition = getValueTransition(transition, name) || {}\n\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0\n\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition\n        elapsed = elapsed - secondsToMilliseconds(delay)\n\n        const options: ValueAnimationOptions = {\n            keyframes: Array.isArray(target) ? target : [null, target],\n            ease: \"easeOut\",\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            delay: -elapsed,\n            onUpdate: (v) => {\n                value.set(v)\n                valueTransition.onUpdate && valueTransition.onUpdate(v)\n            },\n            onComplete: () => {\n                onComplete()\n                valueTransition.onComplete && valueTransition.onComplete()\n            },\n            name,\n            motionValue: value,\n            element: isHandoff ? undefined : element,\n        }\n\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unique transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            Object.assign(options, getDefaultTransition(name, options))\n        }\n\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        options.duration &&= secondsToMilliseconds(options.duration)\n        options.repeatDelay &&= secondsToMilliseconds(options.repeatDelay)\n\n        /**\n         * Support deprecated way to set initial value. Prefer keyframe syntax.\n         */\n        if (options.from !== undefined) {\n            options.keyframes[0] = options.from as any\n        }\n\n        let shouldSkip = false\n\n        if (\n            (options as any).type === false ||\n            (options.duration === 0 && !options.repeatDelay)\n        ) {\n            makeAnimationInstant(options)\n\n            if (options.delay === 0) {\n                shouldSkip = true\n            }\n        }\n\n        if (\n            MotionGlobalConfig.instantAnimations ||\n            MotionGlobalConfig.skipAnimations ||\n            element?.shouldSkipAnimations\n        ) {\n            shouldSkip = true\n            makeAnimationInstant(options)\n            options.delay = 0\n        }\n\n        /**\n         * If the transition type or easing has been explicitly set by the user\n         * then we don't want to allow flattening the animation.\n         */\n        options.allowFlatten = !valueTransition.type && !valueTransition.ease\n\n        /**\n         * If we can or must skip creating the animation, and apply only\n         * the final keyframe, do so. We also check once keyframes are resolved but\n         * this early check prevents the need to create an animation at all.\n         */\n        if (shouldSkip && !isHandoff && value.get() !== undefined) {\n            const finalKeyframe = getFinalKeyframe<V>(\n                options.keyframes as V[],\n                valueTransition\n            )\n\n            if (finalKeyframe !== undefined) {\n                frame.update(() => {\n                    options.onUpdate!(finalKeyframe)\n                    options.onComplete!()\n                })\n\n                return\n            }\n        }\n\n        return valueTransition.isSync\n            ? new JSAnimation(options)\n            : new AsyncMotionValueAnimation(options)\n    }\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}